{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Entwicklung und Betrieb mobiler Informationssysteme Themenblock 1: Android","title":"Home"},{"location":"#entwicklung-und-betrieb-mobiler-informationssysteme","text":"","title":"Entwicklung und Betrieb mobiler Informationssysteme"},{"location":"#themenblock-1-android","text":"","title":"Themenblock 1: Android"},{"location":"android/apps-ausf%C3%BChren/","text":"Apps ausf\u00fchren Apps k\u00f6nnen am Emulator oder auf einem Android Smartphone ausgef\u00fchrt werden. Eine detailierte Dokumentation f\u00fcr die beiden Optionen findet man in der Android Dokumentation: Emulator Android Smartphone Emulator H\u00e4ufige Probleme Troubleshooting Intel\u00ae HAXM Android Smartphone Die Ausf\u00fchrung der App ist am Android Smartphone oft schneller und einfacher als am Emulator. Damit ein Smartphone zur Ausf\u00fchrung von Apps in Entwicklung verwendet werden kann, m\u00fcssen die Entwickleroptionen freigeschalten werden: Entwickleroptionen freischalten Dazu muss am Android Smartphone in Einstellungen > Telefoninfo nach der Buildnummer gesucht werden. Diese findet sich zB unter Einstellungen > Telefoninfo > Softwareinformationen . Es muss dann ca. 7-mal auf die Buildnummer geklickt werden, dann werden die Entwickleroptionen freigeschalten. USB-Debugging aktivieren Nachdem die Entwickleroptionen freigeschalten wurden, finden sich diese unter Einstellungen > Entwickleroptionen . Dort muss USB-Debugging aktiviert werden und das Smartphone muss \u00fcber USB-Kabel am Rechner angeschlossen sein.","title":"Apps ausf\u00fchren"},{"location":"android/apps-ausf%C3%BChren/#apps-ausfuhren","text":"Apps k\u00f6nnen am Emulator oder auf einem Android Smartphone ausgef\u00fchrt werden. Eine detailierte Dokumentation f\u00fcr die beiden Optionen findet man in der Android Dokumentation: Emulator Android Smartphone","title":"Apps ausf\u00fchren"},{"location":"android/apps-ausf%C3%BChren/#emulator","text":"","title":"Emulator"},{"location":"android/apps-ausf%C3%BChren/#haufige-probleme","text":"Troubleshooting Intel\u00ae HAXM","title":"H\u00e4ufige Probleme"},{"location":"android/apps-ausf%C3%BChren/#android-smartphone","text":"Die Ausf\u00fchrung der App ist am Android Smartphone oft schneller und einfacher als am Emulator. Damit ein Smartphone zur Ausf\u00fchrung von Apps in Entwicklung verwendet werden kann, m\u00fcssen die Entwickleroptionen freigeschalten werden:","title":"Android Smartphone"},{"location":"android/apps-ausf%C3%BChren/#entwickleroptionen-freischalten","text":"Dazu muss am Android Smartphone in Einstellungen > Telefoninfo nach der Buildnummer gesucht werden. Diese findet sich zB unter Einstellungen > Telefoninfo > Softwareinformationen . Es muss dann ca. 7-mal auf die Buildnummer geklickt werden, dann werden die Entwickleroptionen freigeschalten.","title":"Entwickleroptionen freischalten"},{"location":"android/apps-ausf%C3%BChren/#usb-debugging-aktivieren","text":"Nachdem die Entwickleroptionen freigeschalten wurden, finden sich diese unter Einstellungen > Entwickleroptionen . Dort muss USB-Debugging aktiviert werden und das Smartphone muss \u00fcber USB-Kabel am Rechner angeschlossen sein.","title":"USB-Debugging aktivieren"},{"location":"android/einf%C3%BChrung/","text":"Einf\u00fchrung Android Apps Android Apps werden in Java oder Kotlin programmiert. F\u00fcr spezielle hardwarenahme Teile einer App kann auch C/C++ verwendet werden (siehe Android NDK ). Eine Android App wird in eine APK-Datei ( .apk ) kompiliert, diese Datei kann dann zum Beispiel in einen Android App Market zur Ver\u00f6ffentlichung geladen werden. Android ist ein Linux-basiertes Betriebssystem. Dabei gibt es einige wichtige Sicherheitsaspekte die daraus resultieren: Jede App bekommt zum Installationszeitpunkt eine Linux User-ID zugewiesen. Nur diese User-ID hat Lese- und Schreibrechte innerhalb des App-Ordners. Jede App wird grunds\u00e4tzlich innerhalb eines eigenen Betriebssystem-Prozesses ausgef\u00fchrt. Jeder Prozess hat eine eigene Virtual Machine (Dalvik, ART), welche die App innerhalb einer Sandbox (isoliert von anderen Apps)ausf\u00fchrt. Grundstruktur einer Android App Eine Android App besteht im Wesentlichen aus 3 Bestandteilen: Jede App besitzt ein Manifest als zentrale Konfigurationsdatei in XML. Anwendungskomponenten werden als Quellcode implementiert. Apps ben\u00f6tigen auch Ressourcen, zum Beispiel: Mediendateien (Bilder, Sound, Videos, \u2026) Texte (zB f\u00fcr \u00dcbersetzung in andere Sprachen) Layout Definitionen in XML Android Apps werden in eine APK-Datei (Android Package) kompiliert. Der Quellcode wird dabei im ersten Schritt in Java-Bytecode \u00fcberf\u00fchrt und im weiteren \u00fcber einen speziellen Compiler in Dex Bytecode \u00fcberf\u00fchrt. Alle Ressourcen werden komprimiert und als .arsc Dateien in die APK verpackt. Ebenfalls wird das Manifest ( AndroidManifest.xml ) in die APK mit aufgenommen. Hinweis Das kompilierte APK kann direkt weitergegeben werden oder \u00fcber einen App Market ver\u00f6ffentlicht werden. F\u00fcr die Ver\u00f6ffentlichung muss die APK signiert werden. Kernkomponenten in Android Android Apps sind aus unterschiedlichen Kernkomponenten zusammengesetzt. Diese Kernkomponenten werden in Quellcode realisiert. Es k\u00f6nnen generell 4 Komponenten unterschieden werden: Activity: Eine Activity repr\u00e4sentiert einen \u201eScreen\u201c einer App (Darstellung und Benutzerinteraktionen). Beispiel: Eine Email Anwendung hat eine Activity , welche das Verfassen der Email abwickelt. Service: L\u00e4ngere Arbeitsschritte werden in Services ausgelagert und k\u00f6nnen so im Hintergrund ausgef\u00fchrt werden. Beispiel: Abspielen von Musik (auch wenn die App geschlossen wird). Content Provider: Verwalten globale Daten, welche f\u00fcr alle Apps relevant sind. Beispiel: Kontakte werden in einem Content Provider verwaltet. Broadcast Receiver: Ereignisse, welche Systemweit kommuniziert werden, k\u00f6nnen \u00fcber Broadcast Receiver abgefangen werden. Beispiel: Anwendungen k\u00f6nnen auf den \"Low Battery\" Event reagieren. Android Manifest Jede Android App muss ein Manifest enthalten, welches unterschiedliche Metadaten \u00fcber die App enth\u00e4lt. Das Manifest ist ein XML-Dokument im Wurzelverzeichnis der App mit Namen AndroidManifest.xml . Inhalte des Manifests sind folgende: Alle Komponenten die zur App geh\u00f6ren Definiert die \u00f6ffentlichen Interaktionsm\u00f6glichkeiten f\u00fcr andere Apps Definiert alle Berechtigungen, welche die App ben\u00f6tigt (zB Zugriff auf das Internet) Kann alle Hardware-Features definieren, welche die App ben\u00f6tigt (zB Kamera) Weitere Metadaten wie App Name, App Icon, Versionsnummer, \u2026 <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android= \"http://schemas.android.com/apk/res/android\" package= \"fhku.exampleapp\" > <uses-permission android:name= \"android.permission.INTERNET\" /> <application android:icon= \"@mipmap/ic_launcher\" android:label= \"@string/app_name\" > <activity android:name= \".MainActivity\" > <intent-filter> <action android:name= \"android.intent.action.MAIN\" /> <category android:name= \"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest> Android API Level Ein API Level klassifiziert die verf\u00fcgbaren Funktionalit\u00e4ten des Android Frameworks eindeutig. Erweiterungen der Framework API, welche durch eine neue Android Version eingef\u00fchrt werden, sind additiv (Vorw\u00e4rtskompatibel). Eine alte App (f\u00fcr alte Android Version entwickelt) funktioniert auf einer neuen Android Version. Um eine R\u00fcckw\u00e4rtskompatibilit\u00e4t sicher zu stellen, bietet Android sog. Support Libraries. Mit Support Libraries k\u00f6nnen neue Features auf alten Android Versionen hergestellt werden. Minimal, Maximal und Ziel API Level k\u00f6nnen f\u00fcr die jeweilige App innerhalb des Manifestes festgelegt werden. Support Libraries Die unterschiedlichen Android Versionen sind unterschiedlich stark verbreitet. Android Apps sind vorw\u00e4rtskompatibel. Eine App welche f\u00fcr das SDK 8.0 kompiliert wurde, funktioniert auch auf Android > 8.0 (8.1, 9.0, \u2026). Falls Features innerhalb einer Android App genutzt werden, welche zum Beispiel mit Android Version 6 eingef\u00fchrt wurden, sind diese auf Android Ger\u00e4te mit einer Version < 6 nicht nutzbar. Android Apps werden durch Support Libraries r\u00fcckw\u00e4rtskompatibel. Eine App welche mit Support Libraries entwickelt wird, kann auch auf \u00e4lteren Android Versionen ausgef\u00fchrt werden. Hierbei gibt es jedoch f\u00fcr jedes Feature auch eine untere Grenze! Wichtige UI-Konzepte Android hat einige allgemeine Bedien-Konzepte die folgend kurz zusammengefasst werden. Homescreen Der Homescreen ist von der Benutzerin anpassbar, dort finden sich App Icons bzw. App Shortcuts. Es k\u00f6nnen auch sog. App Widgets eingef\u00fcgt werden. Auch Ordner k\u00f6nnen erstellt werden zur besseren Organisation. All-Apps Screen Am All-Apps Screen finden sich alle Apps, welche am Smartphone installiert sind. System Toolbars Die Statusbar zeigt Notifications und Status Icons . Die Hauptnavigation zeigt den Zur\u00fcckbutton (siehe Activities ), den Homebutton (zum Homescreen) bzw. Recents (zum Recents-Screen) Recents Screen Am Recents-Screen werden alle aktiven Apps bzw. Tasks gezeigt. Die Liste ist sortiert nach der letzen Nutzung. Activities F\u00fcr jede eigenst\u00e4ndige Oberfl\u00e4che einer Android App wird eine eigene Activity ben\u00f6tigt. Eine App besteht meist aus vielen Activities . Als einfache Regeln gelten: Je komplexer eine App, desto mehr Activities werden ben\u00f6tigt. Jede Activity sollte eine Benutzeraktion abdecken (zB Schreiben einer Email). Eine App hat eine Start- oder Hauptactivity, welche beim Start der App (Klick auf Icon am Homescreen ) ausgef\u00fchrt wird. F\u00fcr jede Activity wird eine ContentView definiert, welche den rechteckigen Bereich am Bildschirm definiert auf dem die Oberfl\u00e4che der Activity gerendert wird. Activities k\u00f6nnen so definiert sein, dass sie nur innerhalb der App nutzbar sind. Es gibt jedoch auch Activities , welche zur Nutzung f\u00fcr andere Apps ge\u00f6ffnet sein k\u00f6nnen. Organisation als Stack Alle Activities (Ansichen oder Screens) einer App sind als Stack organisiert. Die oberste Activity im Stack befindet sich im Vordergrund und reagiert auf Benutzerinteraktionen. Beim Start einer neuen Activity wird sie oben auf den Stack gelegt (push). \u00dcber den Zur\u00fcck-Button am Smartphone/Tablet wird die oberste Activity vom Stack genommen (pop). Die Navigation \u00fcber den Zur\u00fcck-Button endet immer am Homescreen . Eine App, welche in Ausf\u00fchrung gebracht wird, wird als Task bezeichnet und findet sich im Recents-Screen . Eine App wird immer innerhalb eines eigenen Prozesses ausgef\u00fchrt. Activities einer App k\u00f6nnen auch innerhalb eines anderen Tasks (innerhalb einer anderen App) genutzt werden. Zum Beispiel stellt Android eine allgemeine Kamera App zur Verf\u00fcgung. Innerhalb einer anderen App, welche eine Kamera-Funktion ben\u00f6tigt, kann die Activity der allgemeinen Kamera App verwendet werden. Dies hat unter anderem den Vorteil, dass keine eigene Kamera Funktion implementiert werden muss. Lebenszyklus einer Activity Activities sind an einen Lebenszyklus gebunden, welcher sich anhand der Sichtbarkeit einer Activity orientiert. Folgende Lebensphasen sind dabei definiert: Aktive (vordergr\u00fcndige) Lebensphase Die Activity ist sichtbar und wartet auf Benutzereingaben. \u00dcberg\u00e4nge in und aus dieser Lebensphase k\u00f6nnen h\u00e4ufig vorkommen. Die Methoden onResume und onPause sollen daher nur sehr leichtgewichtige Verarbeitungen durchf\u00fchren. Sichtbare Lebensphase Transparente (zB unter einem Dialog) bzw. nicht aktive sichtbare Aktivit\u00e4t (zB Splitscreen) Innerhalb der Methoden onStart und onPause bearbeiten Gestoppte Lebensphase Activity bleibt unsichtbar im Stack Ressourcen sollen freigegeben werden innerhalb der Methode onStop . Zum Beispiel um Animationen zu stoppen, Sensoren freigeben oder GPS freigeben. \u00dcber die Methoden onStart bzw. onRestart k\u00f6nnen die Ressourcen wieder aktiviert werden. Intents Intents sind ein sehr wichtiges Konzept in Android. Android Apps sind grunds\u00e4tzlich nach dem Prinzip der losen Kopplung aufgebaut: Jede Komponente hat eine klare Verantwortung und ist unabh\u00e4ngig von anderen Komponenten. Komponenten kommunizieren \u00fcber wohldefinierte Schnittstellen (Intents). Komponenten werden dadurch systemweit wiederverwendbar. Activities (Fotos machen, SMS schreiben, E-Mail schreiben, Beitr\u00e4ge teilen, Telefonanruf durchf\u00fchren, Kontakt ausw\u00e4hlen) k\u00f6nnen in anderen Apps wiederverwendet werden. Komponenten k\u00f6nnen isoliert getestet werden (Unit Test). Intents werden zum Nachrichtenaustausch zwischen Komponenten verwendet. So kann eine Activity mit der Methode startActivity und als Parameter einen Intent eine neue Activity starten. Der Intent wird dabei an das Android Betriebssystem \u00fcbergeben, dieses w\u00e4hlt die passende Activity aus. Arten von Intents Es sind explizite Intents und implizite Intents in Android zu unterscheiden. Ein expliziter Intent wird verwendet um eine Komponente der eigene App zu identifizieren und zu starten. Ein impliziter Intent wird verwendet um eine Komponente einer anderen App zu identifizieren und zu starten. Ein expliziter Intent gibt dabei den FQN (Fully-Qualified Classname) der Komponente an, um diese eindeutig zu identifizieren. Im folgenden Beispiel wird innerhalb eine Activity eine andere GameActivity gestartet: Intent intent = new Intent ( this , GameActivity . class ); startActivity ( intent ); F\u00fcr implizite Intents kann kein FQN angegeben werden. Deshalb wird \u00fcber Attribute spezifiziert, welche Funktionen und Eigenschaften eine Komponente erf\u00fcllen muss. Es werden dazu unterschiedliche Attribute verwendet: Action: Eine abstrakte Beschreibung der Operation die ausgef\u00fchrt werden soll. Zum Beispiel die ACTION_DIAL um einen Anruf zu t\u00e4tigen. Data: Eine Referenz auf die Daten auf denen die Aktion ausgef\u00fchrt werden soll. Zum Beispiel kann \u00fcber eine URI ( tel:123 ) ein Kontakt angegeben werden. Der implizite Intent wird potenziell von unterschiedlichen Komponenten erf\u00fcllt. Die Auswahl f\u00fcr die entsprechende Komponente wird letztlich der Benutzerin \u00fcberlassen. Nachrichtenaustausch \u00dcber Intents k\u00f6nnen auch Schl\u00fcssel/Wert Paare von einer Komponente an eine andere \u00fcbertragen werden. Dazu werden sog. Extras verwendet. Es soll von einer Activity eine andere Activity gestartet werden. Dabei soll ein Parameter speed \u00fcbergeben wreden. Dieser Parameter steuert zum Beispiel die Geschwindigkeit innerhalb eines Spieles. Intent intent = new Intent ( this , GameActivity . class ); intent . putExtra ( \"speed\" , 350 ); startActivity ( intent ); Innerhalb des Ziels kann der Intent mit der Methode getIntent abgefragt werden. Dabei k\u00f6nnen die Extras genutzt werden. Es kann gepr\u00fcft werden, ob ein entsprechendes Extra mit dem Schl\u00fcssel existiert (Methode hasExtra ). Des Weiteren kann das Extra \u00fcber eine typisierte Methode getIntExtra abgefragt werden. Ebenfalls kann ein Default-Wert angegeben werden (hier 500 ). Intent intent = getIntent (); if ( intent . hasExtra ( \"speed\" )) { int speed = intent . getIntExtra ( \"speed\" , 500 ); } Logging Um den Zustand einer App zu \u00fcberwachen (Monitoring) oder auch zum Debugging kann unter anderem Logging verwendet werden. Eine Anwendung kann eigenst\u00e4ndige Logfiles erzeugen und Ereignisse loggen. Logeintr\u00e4ge k\u00f6nnen eine Wichtigkeit bzw. Hierarchie aufweisen (RFC 5424): VERBOSE: Lautes Logging DEBUG: Wichtige Debugging Informationen INFO: Wichtige Ereignisse der Anwendung WARN: Ein unvorhergesehenes Ereignis ERROR: Fehler in der Anwendung Die Klasse Log mit den entsprechenden statischen Logging-Funktionen kann genutzt werden um Logs zu erzeugen. Zum besseren Auffinden im gesamten Log-Stream des Android Ger\u00e4ts k\u00f6nnen sog. TAGs eingesetzt werden. \u00dcber folgende Aufrufe k\u00f6nnen die entsprechenden Logs erzeugt werden: Log . v ( \"MEINE APP\" , \"Verbose Log-Nachricht\" ); Log . d ( \"MEINE APP\" , \"Debug Log-Nachricht\" ); Log . i ( \"MEINE APP\" , \"Info Log-Nachricht\" ); Log . w ( \"MEINE APP\" , \"Warn Log-Nachricht\" ); Log . e ( \"MEINE APP\" , \"Error Log-Nachricht\" ); Log-Eintr\u00e4ge in Logcat In Android Studio k\u00f6nnen mit dem Programm Logcat die entsprechenden Log-Eintr\u00e4ge gefunden werden: Beispiel: Activity-\u00dcberg\u00e4nge loggen Weiterf\u00fchrende Details und Referenzen Application Fundamentals : Grundlagen zu Android Apps. Android Manifest Intro Activities Activity Lifecycle Tasks und Stack Intents","title":"Einf\u00fchrung"},{"location":"android/einf%C3%BChrung/#einfuhrung","text":"","title":"Einf\u00fchrung"},{"location":"android/einf%C3%BChrung/#android-apps","text":"Android Apps werden in Java oder Kotlin programmiert. F\u00fcr spezielle hardwarenahme Teile einer App kann auch C/C++ verwendet werden (siehe Android NDK ). Eine Android App wird in eine APK-Datei ( .apk ) kompiliert, diese Datei kann dann zum Beispiel in einen Android App Market zur Ver\u00f6ffentlichung geladen werden. Android ist ein Linux-basiertes Betriebssystem. Dabei gibt es einige wichtige Sicherheitsaspekte die daraus resultieren: Jede App bekommt zum Installationszeitpunkt eine Linux User-ID zugewiesen. Nur diese User-ID hat Lese- und Schreibrechte innerhalb des App-Ordners. Jede App wird grunds\u00e4tzlich innerhalb eines eigenen Betriebssystem-Prozesses ausgef\u00fchrt. Jeder Prozess hat eine eigene Virtual Machine (Dalvik, ART), welche die App innerhalb einer Sandbox (isoliert von anderen Apps)ausf\u00fchrt.","title":"Android Apps"},{"location":"android/einf%C3%BChrung/#grundstruktur-einer-android-app","text":"Eine Android App besteht im Wesentlichen aus 3 Bestandteilen: Jede App besitzt ein Manifest als zentrale Konfigurationsdatei in XML. Anwendungskomponenten werden als Quellcode implementiert. Apps ben\u00f6tigen auch Ressourcen, zum Beispiel: Mediendateien (Bilder, Sound, Videos, \u2026) Texte (zB f\u00fcr \u00dcbersetzung in andere Sprachen) Layout Definitionen in XML Android Apps werden in eine APK-Datei (Android Package) kompiliert. Der Quellcode wird dabei im ersten Schritt in Java-Bytecode \u00fcberf\u00fchrt und im weiteren \u00fcber einen speziellen Compiler in Dex Bytecode \u00fcberf\u00fchrt. Alle Ressourcen werden komprimiert und als .arsc Dateien in die APK verpackt. Ebenfalls wird das Manifest ( AndroidManifest.xml ) in die APK mit aufgenommen. Hinweis Das kompilierte APK kann direkt weitergegeben werden oder \u00fcber einen App Market ver\u00f6ffentlicht werden. F\u00fcr die Ver\u00f6ffentlichung muss die APK signiert werden.","title":"Grundstruktur einer Android App"},{"location":"android/einf%C3%BChrung/#kernkomponenten-in-android","text":"Android Apps sind aus unterschiedlichen Kernkomponenten zusammengesetzt. Diese Kernkomponenten werden in Quellcode realisiert. Es k\u00f6nnen generell 4 Komponenten unterschieden werden: Activity: Eine Activity repr\u00e4sentiert einen \u201eScreen\u201c einer App (Darstellung und Benutzerinteraktionen). Beispiel: Eine Email Anwendung hat eine Activity , welche das Verfassen der Email abwickelt. Service: L\u00e4ngere Arbeitsschritte werden in Services ausgelagert und k\u00f6nnen so im Hintergrund ausgef\u00fchrt werden. Beispiel: Abspielen von Musik (auch wenn die App geschlossen wird). Content Provider: Verwalten globale Daten, welche f\u00fcr alle Apps relevant sind. Beispiel: Kontakte werden in einem Content Provider verwaltet. Broadcast Receiver: Ereignisse, welche Systemweit kommuniziert werden, k\u00f6nnen \u00fcber Broadcast Receiver abgefangen werden. Beispiel: Anwendungen k\u00f6nnen auf den \"Low Battery\" Event reagieren.","title":"Kernkomponenten in Android"},{"location":"android/einf%C3%BChrung/#android-manifest","text":"Jede Android App muss ein Manifest enthalten, welches unterschiedliche Metadaten \u00fcber die App enth\u00e4lt. Das Manifest ist ein XML-Dokument im Wurzelverzeichnis der App mit Namen AndroidManifest.xml . Inhalte des Manifests sind folgende: Alle Komponenten die zur App geh\u00f6ren Definiert die \u00f6ffentlichen Interaktionsm\u00f6glichkeiten f\u00fcr andere Apps Definiert alle Berechtigungen, welche die App ben\u00f6tigt (zB Zugriff auf das Internet) Kann alle Hardware-Features definieren, welche die App ben\u00f6tigt (zB Kamera) Weitere Metadaten wie App Name, App Icon, Versionsnummer, \u2026 <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android= \"http://schemas.android.com/apk/res/android\" package= \"fhku.exampleapp\" > <uses-permission android:name= \"android.permission.INTERNET\" /> <application android:icon= \"@mipmap/ic_launcher\" android:label= \"@string/app_name\" > <activity android:name= \".MainActivity\" > <intent-filter> <action android:name= \"android.intent.action.MAIN\" /> <category android:name= \"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest>","title":"Android Manifest"},{"location":"android/einf%C3%BChrung/#android-api-level","text":"Ein API Level klassifiziert die verf\u00fcgbaren Funktionalit\u00e4ten des Android Frameworks eindeutig. Erweiterungen der Framework API, welche durch eine neue Android Version eingef\u00fchrt werden, sind additiv (Vorw\u00e4rtskompatibel). Eine alte App (f\u00fcr alte Android Version entwickelt) funktioniert auf einer neuen Android Version. Um eine R\u00fcckw\u00e4rtskompatibilit\u00e4t sicher zu stellen, bietet Android sog. Support Libraries. Mit Support Libraries k\u00f6nnen neue Features auf alten Android Versionen hergestellt werden. Minimal, Maximal und Ziel API Level k\u00f6nnen f\u00fcr die jeweilige App innerhalb des Manifestes festgelegt werden.","title":"Android API Level"},{"location":"android/einf%C3%BChrung/#support-libraries","text":"Die unterschiedlichen Android Versionen sind unterschiedlich stark verbreitet. Android Apps sind vorw\u00e4rtskompatibel. Eine App welche f\u00fcr das SDK 8.0 kompiliert wurde, funktioniert auch auf Android > 8.0 (8.1, 9.0, \u2026). Falls Features innerhalb einer Android App genutzt werden, welche zum Beispiel mit Android Version 6 eingef\u00fchrt wurden, sind diese auf Android Ger\u00e4te mit einer Version < 6 nicht nutzbar. Android Apps werden durch Support Libraries r\u00fcckw\u00e4rtskompatibel. Eine App welche mit Support Libraries entwickelt wird, kann auch auf \u00e4lteren Android Versionen ausgef\u00fchrt werden. Hierbei gibt es jedoch f\u00fcr jedes Feature auch eine untere Grenze!","title":"Support Libraries"},{"location":"android/einf%C3%BChrung/#wichtige-ui-konzepte","text":"Android hat einige allgemeine Bedien-Konzepte die folgend kurz zusammengefasst werden.","title":"Wichtige UI-Konzepte"},{"location":"android/einf%C3%BChrung/#homescreen","text":"Der Homescreen ist von der Benutzerin anpassbar, dort finden sich App Icons bzw. App Shortcuts. Es k\u00f6nnen auch sog. App Widgets eingef\u00fcgt werden. Auch Ordner k\u00f6nnen erstellt werden zur besseren Organisation.","title":"Homescreen"},{"location":"android/einf%C3%BChrung/#all-apps-screen","text":"Am All-Apps Screen finden sich alle Apps, welche am Smartphone installiert sind.","title":"All-Apps Screen"},{"location":"android/einf%C3%BChrung/#system-toolbars","text":"Die Statusbar zeigt Notifications und Status Icons . Die Hauptnavigation zeigt den Zur\u00fcckbutton (siehe Activities ), den Homebutton (zum Homescreen) bzw. Recents (zum Recents-Screen)","title":"System Toolbars"},{"location":"android/einf%C3%BChrung/#recents-screen","text":"Am Recents-Screen werden alle aktiven Apps bzw. Tasks gezeigt. Die Liste ist sortiert nach der letzen Nutzung.","title":"Recents Screen"},{"location":"android/einf%C3%BChrung/#activities","text":"F\u00fcr jede eigenst\u00e4ndige Oberfl\u00e4che einer Android App wird eine eigene Activity ben\u00f6tigt. Eine App besteht meist aus vielen Activities . Als einfache Regeln gelten: Je komplexer eine App, desto mehr Activities werden ben\u00f6tigt. Jede Activity sollte eine Benutzeraktion abdecken (zB Schreiben einer Email). Eine App hat eine Start- oder Hauptactivity, welche beim Start der App (Klick auf Icon am Homescreen ) ausgef\u00fchrt wird. F\u00fcr jede Activity wird eine ContentView definiert, welche den rechteckigen Bereich am Bildschirm definiert auf dem die Oberfl\u00e4che der Activity gerendert wird. Activities k\u00f6nnen so definiert sein, dass sie nur innerhalb der App nutzbar sind. Es gibt jedoch auch Activities , welche zur Nutzung f\u00fcr andere Apps ge\u00f6ffnet sein k\u00f6nnen.","title":"Activities"},{"location":"android/einf%C3%BChrung/#organisation-als-stack","text":"Alle Activities (Ansichen oder Screens) einer App sind als Stack organisiert. Die oberste Activity im Stack befindet sich im Vordergrund und reagiert auf Benutzerinteraktionen. Beim Start einer neuen Activity wird sie oben auf den Stack gelegt (push). \u00dcber den Zur\u00fcck-Button am Smartphone/Tablet wird die oberste Activity vom Stack genommen (pop). Die Navigation \u00fcber den Zur\u00fcck-Button endet immer am Homescreen . Eine App, welche in Ausf\u00fchrung gebracht wird, wird als Task bezeichnet und findet sich im Recents-Screen . Eine App wird immer innerhalb eines eigenen Prozesses ausgef\u00fchrt. Activities einer App k\u00f6nnen auch innerhalb eines anderen Tasks (innerhalb einer anderen App) genutzt werden. Zum Beispiel stellt Android eine allgemeine Kamera App zur Verf\u00fcgung. Innerhalb einer anderen App, welche eine Kamera-Funktion ben\u00f6tigt, kann die Activity der allgemeinen Kamera App verwendet werden. Dies hat unter anderem den Vorteil, dass keine eigene Kamera Funktion implementiert werden muss.","title":"Organisation als Stack"},{"location":"android/einf%C3%BChrung/#lebenszyklus-einer-activity","text":"Activities sind an einen Lebenszyklus gebunden, welcher sich anhand der Sichtbarkeit einer Activity orientiert. Folgende Lebensphasen sind dabei definiert: Aktive (vordergr\u00fcndige) Lebensphase Die Activity ist sichtbar und wartet auf Benutzereingaben. \u00dcberg\u00e4nge in und aus dieser Lebensphase k\u00f6nnen h\u00e4ufig vorkommen. Die Methoden onResume und onPause sollen daher nur sehr leichtgewichtige Verarbeitungen durchf\u00fchren. Sichtbare Lebensphase Transparente (zB unter einem Dialog) bzw. nicht aktive sichtbare Aktivit\u00e4t (zB Splitscreen) Innerhalb der Methoden onStart und onPause bearbeiten Gestoppte Lebensphase Activity bleibt unsichtbar im Stack Ressourcen sollen freigegeben werden innerhalb der Methode onStop . Zum Beispiel um Animationen zu stoppen, Sensoren freigeben oder GPS freigeben. \u00dcber die Methoden onStart bzw. onRestart k\u00f6nnen die Ressourcen wieder aktiviert werden.","title":"Lebenszyklus einer Activity"},{"location":"android/einf%C3%BChrung/#intents","text":"Intents sind ein sehr wichtiges Konzept in Android. Android Apps sind grunds\u00e4tzlich nach dem Prinzip der losen Kopplung aufgebaut: Jede Komponente hat eine klare Verantwortung und ist unabh\u00e4ngig von anderen Komponenten. Komponenten kommunizieren \u00fcber wohldefinierte Schnittstellen (Intents). Komponenten werden dadurch systemweit wiederverwendbar. Activities (Fotos machen, SMS schreiben, E-Mail schreiben, Beitr\u00e4ge teilen, Telefonanruf durchf\u00fchren, Kontakt ausw\u00e4hlen) k\u00f6nnen in anderen Apps wiederverwendet werden. Komponenten k\u00f6nnen isoliert getestet werden (Unit Test). Intents werden zum Nachrichtenaustausch zwischen Komponenten verwendet. So kann eine Activity mit der Methode startActivity und als Parameter einen Intent eine neue Activity starten. Der Intent wird dabei an das Android Betriebssystem \u00fcbergeben, dieses w\u00e4hlt die passende Activity aus.","title":"Intents"},{"location":"android/einf%C3%BChrung/#arten-von-intents","text":"Es sind explizite Intents und implizite Intents in Android zu unterscheiden. Ein expliziter Intent wird verwendet um eine Komponente der eigene App zu identifizieren und zu starten. Ein impliziter Intent wird verwendet um eine Komponente einer anderen App zu identifizieren und zu starten. Ein expliziter Intent gibt dabei den FQN (Fully-Qualified Classname) der Komponente an, um diese eindeutig zu identifizieren. Im folgenden Beispiel wird innerhalb eine Activity eine andere GameActivity gestartet: Intent intent = new Intent ( this , GameActivity . class ); startActivity ( intent ); F\u00fcr implizite Intents kann kein FQN angegeben werden. Deshalb wird \u00fcber Attribute spezifiziert, welche Funktionen und Eigenschaften eine Komponente erf\u00fcllen muss. Es werden dazu unterschiedliche Attribute verwendet: Action: Eine abstrakte Beschreibung der Operation die ausgef\u00fchrt werden soll. Zum Beispiel die ACTION_DIAL um einen Anruf zu t\u00e4tigen. Data: Eine Referenz auf die Daten auf denen die Aktion ausgef\u00fchrt werden soll. Zum Beispiel kann \u00fcber eine URI ( tel:123 ) ein Kontakt angegeben werden. Der implizite Intent wird potenziell von unterschiedlichen Komponenten erf\u00fcllt. Die Auswahl f\u00fcr die entsprechende Komponente wird letztlich der Benutzerin \u00fcberlassen.","title":"Arten von Intents"},{"location":"android/einf%C3%BChrung/#nachrichtenaustausch","text":"\u00dcber Intents k\u00f6nnen auch Schl\u00fcssel/Wert Paare von einer Komponente an eine andere \u00fcbertragen werden. Dazu werden sog. Extras verwendet. Es soll von einer Activity eine andere Activity gestartet werden. Dabei soll ein Parameter speed \u00fcbergeben wreden. Dieser Parameter steuert zum Beispiel die Geschwindigkeit innerhalb eines Spieles. Intent intent = new Intent ( this , GameActivity . class ); intent . putExtra ( \"speed\" , 350 ); startActivity ( intent ); Innerhalb des Ziels kann der Intent mit der Methode getIntent abgefragt werden. Dabei k\u00f6nnen die Extras genutzt werden. Es kann gepr\u00fcft werden, ob ein entsprechendes Extra mit dem Schl\u00fcssel existiert (Methode hasExtra ). Des Weiteren kann das Extra \u00fcber eine typisierte Methode getIntExtra abgefragt werden. Ebenfalls kann ein Default-Wert angegeben werden (hier 500 ). Intent intent = getIntent (); if ( intent . hasExtra ( \"speed\" )) { int speed = intent . getIntExtra ( \"speed\" , 500 ); }","title":"Nachrichtenaustausch"},{"location":"android/einf%C3%BChrung/#logging","text":"Um den Zustand einer App zu \u00fcberwachen (Monitoring) oder auch zum Debugging kann unter anderem Logging verwendet werden. Eine Anwendung kann eigenst\u00e4ndige Logfiles erzeugen und Ereignisse loggen. Logeintr\u00e4ge k\u00f6nnen eine Wichtigkeit bzw. Hierarchie aufweisen (RFC 5424): VERBOSE: Lautes Logging DEBUG: Wichtige Debugging Informationen INFO: Wichtige Ereignisse der Anwendung WARN: Ein unvorhergesehenes Ereignis ERROR: Fehler in der Anwendung Die Klasse Log mit den entsprechenden statischen Logging-Funktionen kann genutzt werden um Logs zu erzeugen. Zum besseren Auffinden im gesamten Log-Stream des Android Ger\u00e4ts k\u00f6nnen sog. TAGs eingesetzt werden. \u00dcber folgende Aufrufe k\u00f6nnen die entsprechenden Logs erzeugt werden: Log . v ( \"MEINE APP\" , \"Verbose Log-Nachricht\" ); Log . d ( \"MEINE APP\" , \"Debug Log-Nachricht\" ); Log . i ( \"MEINE APP\" , \"Info Log-Nachricht\" ); Log . w ( \"MEINE APP\" , \"Warn Log-Nachricht\" ); Log . e ( \"MEINE APP\" , \"Error Log-Nachricht\" );","title":"Logging"},{"location":"android/einf%C3%BChrung/#log-eintrage-in-logcat","text":"In Android Studio k\u00f6nnen mit dem Programm Logcat die entsprechenden Log-Eintr\u00e4ge gefunden werden:","title":"Log-Eintr\u00e4ge in Logcat"},{"location":"android/einf%C3%BChrung/#beispiel-activity-ubergange-loggen","text":"","title":"Beispiel: Activity-\u00dcberg\u00e4nge loggen"},{"location":"android/einf%C3%BChrung/#weiterfuhrende-details-und-referenzen","text":"Application Fundamentals : Grundlagen zu Android Apps. Android Manifest Intro Activities Activity Lifecycle Tasks und Stack Intents","title":"Weiterf\u00fchrende Details und Referenzen"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/","text":"Grafische Benutzeroberfl\u00e4che Eine grafische Benutzerschnittstelle in Android besteht aus 3 Bestandteilen: Interaktionselementen die Benutzer der App sehen und damit interagieren k\u00f6nnen. In Android sind dies alle Klassen, welche von android.view.View erben (zB Button , TextView , \u2026). Die Anordnung der Interaktionselemente (Layout) auf der jeweils verf\u00fcgbaren Bildschirmfl\u00e4che. In Android wird dies von Layout Managern \u00fcbernommen. Alle Layout Manager (zB LinearLayout , ConstraintLayout , \u2026) erben von der Klasse android.view.ViewGroup . Dabei erbt ViewGroup auch von View Mechanismen zur Erkennung und der Reaktion auf Interaktionen der Benutzer (Eventhandling). In Android werden dazu Events erzeugt und von EventListenern abgearbeitet (zB OnClickListener ). View Klassen-Hierarchie Android liefert eine umfangreiche Bibliothek an GUI-Elementen. Dabei gibt es die Klasse android.view.View , welche als Elternklasse aller Views fungiert. Neben der Klasse View gibt es die Klasse android.view.ViewGroup , welche zur Gruppierung von einzelnen Views verwendet wird. Im folgenden findet sich ein kleiner Auszug aus der Android View-Klassen Hierarchie: View Instanzen-Hierarchie F\u00fcr die Realisierung der einzelnen Sichten innerhalb einer Android App werden die entsprechenden Views instanziert und \u00fcber ViewGroups in eine Hierarchie verschachtelt. In der Benutzerschnittstelle nimmt eine Instanz der Klasse View einen rechteckigen Bereich ein. Auf diesem Bereich wird die View gezeichnet. Im Instanzen-Baum sind Views immer Blattknoten und ViewGroups bilden Teilb\u00e4ume. In der Darstellung wird eine Benutzerschnittstelle gezeigt und die zugeh\u00f6rige Hierarchie der View-Instanzen. Dabei ist ersichtlich das die ContentView das Wurzelelement ist. Jeder Activity ist eine ContentView zugeordnet, welche den gesamten rechteckigen Bereich angibt, der zur Verf\u00fcgung steht um die Benutzerschnittstelle zu realisieren. Layouts in Android Zur Anordung der Interaktionselemente auf der Benutzerschnittstelle werden Layouts verwendet. Diese k\u00f6nnen in Android entweder deklarativ durch die Definition eines XML-Dokumentes oder programmatisch \u00fcber Quellcode erstellt werden. Ebenfalls eine Kombination aus deklarativen Teilen (eher f\u00fcr statische Teile des Layouts) und programmatischen Teilen (eher f\u00fcr dynamische Teile des Layouts) ist m\u00f6glich. In Android gibt eine gro\u00dfe Anzahl unterschiedlicher Layouts. Im Prinzip sind alle Klassen, welche von ViewGroup erben als Layout nutzbar. Im Prinzip werden jedoch nur das ContraintLayout und das LinearLayout f\u00fcr die Darstellung jeglicher Layouts ben\u00f6tigt. LinearLayout Das LinearLayout ist ein sehr einfaches aber effektives Layout. Es ordnet Kindelemente entweder vertikal oder horizontal in einer Reihe an. Des weiteren gibt es die zwei Eigenschaften gravity und weight um weitere Flexibili\u00e4t in der Anordnung von Elementen zu schaffen. Deklaratives LinearLayout Beispiel Im folgenden wird ein LinearLayout definiert, welches die Kindelemente vertikal (von oben nach unten) in einer Reihe anordnet. Es ist ein horizontales Padding von 16dp links und rechts definiert. Letzlich werden die Kindelemente durch die gravity Eigenschaft mit Wert center vertikal zentriert. Bei den Kindelementen handelt es sich um 2 Buttons , welche als Text \"1 Spieler\" bzw. \"2 Spieler\" definiert haben. Sowohl f\u00fcr das LinearLayout als auch f\u00fcr die Buttons wird die Breite und H\u00f6he \u00fcber 2 spezielle Konstanten ( match_parent und wrap_content ) angegeben. Hinweis F\u00fcr jedes Element im Layout muss eine Breite und H\u00f6he angegeben werden. Dabei k\u00f6nnen dort absolute Werte spezifiziert werden (zB 16dp). Besser als absolute Werte zu nutzen ist es auf vordefinierte Konstanten match_parent und wrap_content zur\u00fcckzugreifen. match_parent errechnet dabei die Gr\u00f6\u00dfte anhand des Elternelements (Sprich: so gro\u00df wie das Elternelement). wrap_content errechnet die Gr\u00f6\u00dfe dabei anhand des Inhalts des Elements (Sprich: so gro\u00df wie n\u00f6tig, dass der Inhalt des Elements dargestellt werden kann). Weitere Details dazu finden sich in der Dokumentation . <?xml version=\"1.0\" encoding=\"utf-8\"?> <LinearLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:paddingHorizontal= \"16dp\" android:gravity= \"center\" android:orientation= \"vertical\" > <Button android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:text= \"1 Spieler\" /> <Button android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:text= \"2 Spieler\" /> </LinearLayout> In der Ansicht wird das gerenderte Layout angezeigt: ConstraintLayout Durch die Verschachtelung unterschiedlicher LinearLayouts k\u00f6nnte man viele komplexe Layouts erzeugen. Dies ist jedoch nicht performant. Mit dem ConstraintLayout k\u00f6nnen k\u00f6nnen beliebig komplexe Layouts unter Einhaltung einer flachen Hierarchie erzeugt werden. Das ConstraintLayout wird auch vom Designer in Android Studio umfassend unterst\u00fctzt. Das ConstraintLayout ist ein sehr wichtiges und n\u00fctzliches Layout f\u00fcr Android Apps, in der Lehrveranstaltung werden wir dieses jedoch nicht weiter verwenden. Eigenschaften von Views Views besitzen Eigenschaften, welche das Erscheinungsbild oder das Verhalten der View bestimmen oder ver\u00e4ndern. Eine TextView hat zum Beispiel folgende Eigenschaften: Text: Der Text der in der TextView dargestellt werden soll Width: Die Breite der TextView Height: Die H\u00f6he der TextView TextColor: Die Schriftfarbe des Textes Alle Eigenschaften k\u00f6nnen entweder programmatisch \u00fcber Getter- bzw. Setter-Methoden abgefrage und ver\u00e4ndert werden. Innerhalb eines XML-Layouts k\u00f6nnen die Eigenschaften auch deklarativ \u00fcber XML-Attribute gesetzt werden. Beispiel: Anpassung Eigenschaften In der folgenden Ansicht wird eine Benutzeroberfl\u00e4che gezeigt, welche 2 Buttons enh\u00e4lt. Der Text in den Buttons ist linksb\u00fcndig, rot, fett und kursiv. Im Beispiel werden die Eigenschaften des ersten Buttons deklarativ und die Eigenschaften des zweiten Buttons programmatisch angepasst. Im folgenden LinearLayout werden die 2 Buttons erzeugt. Zum zweiten Button werden \u00fcber XML-Attribute die Eigenschaften textAlignment , textColor und textStyle deklariert: <?xml version=\"1.0\" encoding=\"utf-8\"?> <LinearLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:orientation= \"vertical\" > <Button android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:text= \"Button programmatisch\" android:id= \"@+id/button1\" /> <Button android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:text= \"Button deklarativ\" android:textAlignment= \"textStart\" android:textColor= \"#FF0000\" android:textStyle= \"bold|italic\" /> </LinearLayout> In der zugeh\u00f6rigen Activity wird der erste Button \u00fcber die zugewiesene ID button1 mit der Methode findViewById abgefragt. Die 3 Eigenschaften werden nun am Button Objekt \u00fcber Setter zugewiesen. public class MainActivity extends AppCompatActivity { @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); Button button1 = findViewById ( R . id . button1 ); button1 . setTextColor ( Color . RED ); button1 . setTextAlignment ( View . TEXT_ALIGNMENT_TEXT_START ); button1 . setTypeface ( null , Typeface . BOLD_ITALIC ); } } Hinweis In den meisten F\u00e4llen gibt es eine 1-zu-1 \u00dcbereinstimmung der Eigenschaftsbezeichnungen im XML-Layout bzw. im Quellcode. Es gibt jedoch einige Ausnahmen davon, zum Beispiel der TextStyle im obigen Beispiel. Eventhandling Das Eventhandling in Benutzeroberfl\u00e4chen in Android Apps wird mit dem bekannten Observer Design Pattern durchgef\u00fchrt. Das Subject des Design Patterns wird von der Android View repr\u00e4sentiert. Die entsprechenden EventListener nehmen die Rolle des Observers ein. Der Abauf in Android sieht dabei folgenderma\u00dfen aus: Eine konkrete Implementierung des Observers , zum durch die Implementierung eines OnClickListener wird erstellt. Der Observer wird an einem Subject registriert (zum Beispiel an einem Button ). Im Subject wird das entsprechende Event generiert (zum Beispiel eine Benutzerin klickt auf den Button ) und alle registrierten Observer werden benachrichtigt. Die registrierten Observer arbeiten das Event ab. Umsetzung des Eventhandling in Android Innerhalb einer Activity k\u00f6nnen unterschiedliche Ans\u00e4tze verwendet werden um das Eventhandling zu implementieren. Deklarativ (eingeschr\u00e4nkt) Innerhalb des XML-Dokumentes zum Layout kann an einer View das XML-Attribut onClick mit einer Methode der Activity verkn\u00fcpft werden (Die Methode muss daf\u00fcr eine bestimmte Signatur aufweisen). Programmatisch Die Activity selbst implementiert ein entsprechendes Interface und wird somit zum EventListener . Eine eigene EventListener Klasse wird erstellt und implementiert: Dies kann als eigene Klasse (in eigener Datei) durchgef\u00fchrt werden. Dies kann auch als innere Klasse der Activity durchgef\u00fchrt werden. Eine anonyme Klasse wird einmalig erstellt (Bei der Zuweisung des EventListener ). Ein Lambda-Ausdruck wird verwendet. Deklarative Zuordnung Innerhalb der Activity gibt es eine Methode mit beliebigen Name, aber einer vorgegebenen Signatur. public class MainActivity extends AppCompatActivity { // ... public void sayHello ( View view ) { Toast . makeText ( this , \"Hello\" , Toast . LENGTH_SHORT ). show (); } } Im XML-Layout muss die entsprechende Methode an das XML-Attribut onClick als Wert \u00fcbergeben werden. Dies f\u00fchrt dazu, wenn ein Klick auf dem Button ausgef\u00fchrt wird, dass die Methode sayHello ausgef\u00fchrt wird. <Button android:id= \"@+id/button6\" android:layout_width= \"wrap_content\" android:layout_height= \"wrap_content\" android:text= \"Hello\" android:onClick= \"sayHello\" /> Hinweis Die Methode innerhalb der Activity muss folgende Signatur aufweisen: Die Methode muss public sein Die Methode muss void als R\u00fcckgabe haben Die Methode muss eine View als \u00dcbergabeparameter haben (dies ist die View welche geklickt wird) Die deklarative Zuordnung ist eine sehr einfache Methode kann aber nur f\u00fcr Klick-Events verwendet werden. Activity implementiert Interface Die Activity implementiert das entsprechende Interface des EventListeners . Dadurch wird die Activity selbst zu einem Observer . Das OnClickListener Interface spezifiziert die Methode onClick , welche zu implementieren ist. Im zweiten Schritt muss am entsprechenden Subject , hier ein Button , der EventListener zugeordnet werden. Da die Activity selbst den EventListener implementiert, wird dies durch \u00fcbergabe von this durchgef\u00fchrt. public class ExampleActivity extends Activity implements View . OnClickListener { @Override protected void onCreate ( Bundle savedValues ) { // ... Button button = findViewById ( R . id . corky ); button . setOnClickListener ( this ); } // Implementierung des OnClickListener Interface @Override public void onClick ( View v ) { // ... } } Ein Nachteil dieser Methode ist, dass eine Activity nur eine Interface eines speziellen Typs implementieren kann. Es k\u00f6nnen nich zwei unterschiedlichen OnClickListener implementiert werden. Implementierung als eigene Klasse Der entsprechende EventListener wird von einer eigene Klasse implementiert. Diese Klasse kann eine inner Klasse sein (wie im Beispiel unten) oder nat\u00fcrlich auch eine eigene Klasse innerhalb einer eigenen Datei. Die Zuweisung der EventListener funktioniert durch die Erstellung einer eigenen Instanz der Klasse. public class ExampleActivity extends Activity { public class MyClickListener implements View . OnClickListener { @Override public void onClick ( View view ) { // ... } } @Override protected void onCreate ( Bundle savedValues ) { // ... Button button = findViewById ( R . id . button ); button . setOnClickListener ( new MyClickListener ()); } } Der Vorteil dieser Variante ist, dass beliebig viele und unterschiedliche Implementierungen eines Event Typs erzeugt werden k\u00f6nnen. Die EventListener k\u00f6nnen auch in unterschiedlichen Activities wiederverwendet werden. Implementierung als Anonyme Klasse Ein EventListener kann nat\u00fcrlich auch als anonyme Klasse implementiert werden. Dabei wird die Implementierung an der Stelle durchgef\u00fchrt an der auch die Zuweisung stattfinden. public class ExampleActivity extends Activity { @Override protected void onCreate ( Bundle savedValues ) { // ... Button button = findViewById ( R . id . button ); button . setOnClickListener ( new View . OnClickListener () { public void onClick ( View v ) { // ... } }); } } Der Nachteil dieser Methode ist, dass der EventListener nur einmal verwendet werden kann. Die Lesbarkeit von anonymen Klassen ist ebenfalls eingeschr\u00e4nkt. Implementierung durch Lambda Ausdr\u00fccke Lambdas wurden mit Java 8 eingef\u00fchrt und sind auch in Android nutzbar. Lambdas sind Funktionen ohne Klassenkontext (Funktion steht f\u00fcr sich alleine) ohne innerhalb einer Klasse eingebettet zu sein. Lambdas k\u00f6nnen dabei wie Objekte genutzt werden (zB \u00dcbergabe als Parameter an andere Funktionen) und nach belieben ausgef\u00fchrt werden. Ein Lambda Ausdruck hat folgende Struktur: parameter -> expression Hinweis Syntaktische Besonderheiten von Lambdas in Java: Optionale Typ-Deklaration Optionale Klammern bei einem Parameter Optionale Klammern um Body, wenn nur ein Statement vorhanden ist Optionales return-Schl\u00fcsselwort bei ungeklammertem Body Lambdase k\u00f6nnen als Alternative zu anonymen Klassen verwendet werden. Die Lesbarkeit wird dadurch etwas erh\u00f6ht: public class ExampleActivity extends Activity { @Override protected void onCreate ( Bundle savedValues ) { // ... Button button = findViewById ( R . id . button ); button . setOnClickListener (( View view ) -> { /* ... */ }); } } Referenzen Layouts LinearLayout : Wichtige Details zum LinearLayout . ConstraintLayout : Wichtige Details zum ConstraintLayout .","title":"Grafische Benutzeroberfl\u00e4chen"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#grafische-benutzeroberflache","text":"Eine grafische Benutzerschnittstelle in Android besteht aus 3 Bestandteilen: Interaktionselementen die Benutzer der App sehen und damit interagieren k\u00f6nnen. In Android sind dies alle Klassen, welche von android.view.View erben (zB Button , TextView , \u2026). Die Anordnung der Interaktionselemente (Layout) auf der jeweils verf\u00fcgbaren Bildschirmfl\u00e4che. In Android wird dies von Layout Managern \u00fcbernommen. Alle Layout Manager (zB LinearLayout , ConstraintLayout , \u2026) erben von der Klasse android.view.ViewGroup . Dabei erbt ViewGroup auch von View Mechanismen zur Erkennung und der Reaktion auf Interaktionen der Benutzer (Eventhandling). In Android werden dazu Events erzeugt und von EventListenern abgearbeitet (zB OnClickListener ).","title":"Grafische Benutzeroberfl\u00e4che"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#view-klassen-hierarchie","text":"Android liefert eine umfangreiche Bibliothek an GUI-Elementen. Dabei gibt es die Klasse android.view.View , welche als Elternklasse aller Views fungiert. Neben der Klasse View gibt es die Klasse android.view.ViewGroup , welche zur Gruppierung von einzelnen Views verwendet wird. Im folgenden findet sich ein kleiner Auszug aus der Android View-Klassen Hierarchie:","title":"View Klassen-Hierarchie"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#view-instanzen-hierarchie","text":"F\u00fcr die Realisierung der einzelnen Sichten innerhalb einer Android App werden die entsprechenden Views instanziert und \u00fcber ViewGroups in eine Hierarchie verschachtelt. In der Benutzerschnittstelle nimmt eine Instanz der Klasse View einen rechteckigen Bereich ein. Auf diesem Bereich wird die View gezeichnet. Im Instanzen-Baum sind Views immer Blattknoten und ViewGroups bilden Teilb\u00e4ume. In der Darstellung wird eine Benutzerschnittstelle gezeigt und die zugeh\u00f6rige Hierarchie der View-Instanzen. Dabei ist ersichtlich das die ContentView das Wurzelelement ist. Jeder Activity ist eine ContentView zugeordnet, welche den gesamten rechteckigen Bereich angibt, der zur Verf\u00fcgung steht um die Benutzerschnittstelle zu realisieren.","title":"View Instanzen-Hierarchie"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#layouts-in-android","text":"Zur Anordung der Interaktionselemente auf der Benutzerschnittstelle werden Layouts verwendet. Diese k\u00f6nnen in Android entweder deklarativ durch die Definition eines XML-Dokumentes oder programmatisch \u00fcber Quellcode erstellt werden. Ebenfalls eine Kombination aus deklarativen Teilen (eher f\u00fcr statische Teile des Layouts) und programmatischen Teilen (eher f\u00fcr dynamische Teile des Layouts) ist m\u00f6glich. In Android gibt eine gro\u00dfe Anzahl unterschiedlicher Layouts. Im Prinzip sind alle Klassen, welche von ViewGroup erben als Layout nutzbar. Im Prinzip werden jedoch nur das ContraintLayout und das LinearLayout f\u00fcr die Darstellung jeglicher Layouts ben\u00f6tigt.","title":"Layouts in Android"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#linearlayout","text":"Das LinearLayout ist ein sehr einfaches aber effektives Layout. Es ordnet Kindelemente entweder vertikal oder horizontal in einer Reihe an. Des weiteren gibt es die zwei Eigenschaften gravity und weight um weitere Flexibili\u00e4t in der Anordnung von Elementen zu schaffen.","title":"LinearLayout"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#deklaratives-linearlayout-beispiel","text":"Im folgenden wird ein LinearLayout definiert, welches die Kindelemente vertikal (von oben nach unten) in einer Reihe anordnet. Es ist ein horizontales Padding von 16dp links und rechts definiert. Letzlich werden die Kindelemente durch die gravity Eigenschaft mit Wert center vertikal zentriert. Bei den Kindelementen handelt es sich um 2 Buttons , welche als Text \"1 Spieler\" bzw. \"2 Spieler\" definiert haben. Sowohl f\u00fcr das LinearLayout als auch f\u00fcr die Buttons wird die Breite und H\u00f6he \u00fcber 2 spezielle Konstanten ( match_parent und wrap_content ) angegeben. Hinweis F\u00fcr jedes Element im Layout muss eine Breite und H\u00f6he angegeben werden. Dabei k\u00f6nnen dort absolute Werte spezifiziert werden (zB 16dp). Besser als absolute Werte zu nutzen ist es auf vordefinierte Konstanten match_parent und wrap_content zur\u00fcckzugreifen. match_parent errechnet dabei die Gr\u00f6\u00dfte anhand des Elternelements (Sprich: so gro\u00df wie das Elternelement). wrap_content errechnet die Gr\u00f6\u00dfe dabei anhand des Inhalts des Elements (Sprich: so gro\u00df wie n\u00f6tig, dass der Inhalt des Elements dargestellt werden kann). Weitere Details dazu finden sich in der Dokumentation . <?xml version=\"1.0\" encoding=\"utf-8\"?> <LinearLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:paddingHorizontal= \"16dp\" android:gravity= \"center\" android:orientation= \"vertical\" > <Button android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:text= \"1 Spieler\" /> <Button android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:text= \"2 Spieler\" /> </LinearLayout> In der Ansicht wird das gerenderte Layout angezeigt:","title":"Deklaratives LinearLayout Beispiel"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#constraintlayout","text":"Durch die Verschachtelung unterschiedlicher LinearLayouts k\u00f6nnte man viele komplexe Layouts erzeugen. Dies ist jedoch nicht performant. Mit dem ConstraintLayout k\u00f6nnen k\u00f6nnen beliebig komplexe Layouts unter Einhaltung einer flachen Hierarchie erzeugt werden. Das ConstraintLayout wird auch vom Designer in Android Studio umfassend unterst\u00fctzt. Das ConstraintLayout ist ein sehr wichtiges und n\u00fctzliches Layout f\u00fcr Android Apps, in der Lehrveranstaltung werden wir dieses jedoch nicht weiter verwenden.","title":"ConstraintLayout"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#eigenschaften-von-views","text":"Views besitzen Eigenschaften, welche das Erscheinungsbild oder das Verhalten der View bestimmen oder ver\u00e4ndern. Eine TextView hat zum Beispiel folgende Eigenschaften: Text: Der Text der in der TextView dargestellt werden soll Width: Die Breite der TextView Height: Die H\u00f6he der TextView TextColor: Die Schriftfarbe des Textes Alle Eigenschaften k\u00f6nnen entweder programmatisch \u00fcber Getter- bzw. Setter-Methoden abgefrage und ver\u00e4ndert werden. Innerhalb eines XML-Layouts k\u00f6nnen die Eigenschaften auch deklarativ \u00fcber XML-Attribute gesetzt werden.","title":"Eigenschaften von Views"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#beispiel-anpassung-eigenschaften","text":"In der folgenden Ansicht wird eine Benutzeroberfl\u00e4che gezeigt, welche 2 Buttons enh\u00e4lt. Der Text in den Buttons ist linksb\u00fcndig, rot, fett und kursiv. Im Beispiel werden die Eigenschaften des ersten Buttons deklarativ und die Eigenschaften des zweiten Buttons programmatisch angepasst. Im folgenden LinearLayout werden die 2 Buttons erzeugt. Zum zweiten Button werden \u00fcber XML-Attribute die Eigenschaften textAlignment , textColor und textStyle deklariert: <?xml version=\"1.0\" encoding=\"utf-8\"?> <LinearLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:orientation= \"vertical\" > <Button android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:text= \"Button programmatisch\" android:id= \"@+id/button1\" /> <Button android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:text= \"Button deklarativ\" android:textAlignment= \"textStart\" android:textColor= \"#FF0000\" android:textStyle= \"bold|italic\" /> </LinearLayout> In der zugeh\u00f6rigen Activity wird der erste Button \u00fcber die zugewiesene ID button1 mit der Methode findViewById abgefragt. Die 3 Eigenschaften werden nun am Button Objekt \u00fcber Setter zugewiesen. public class MainActivity extends AppCompatActivity { @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); Button button1 = findViewById ( R . id . button1 ); button1 . setTextColor ( Color . RED ); button1 . setTextAlignment ( View . TEXT_ALIGNMENT_TEXT_START ); button1 . setTypeface ( null , Typeface . BOLD_ITALIC ); } } Hinweis In den meisten F\u00e4llen gibt es eine 1-zu-1 \u00dcbereinstimmung der Eigenschaftsbezeichnungen im XML-Layout bzw. im Quellcode. Es gibt jedoch einige Ausnahmen davon, zum Beispiel der TextStyle im obigen Beispiel.","title":"Beispiel: Anpassung Eigenschaften"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#eventhandling","text":"Das Eventhandling in Benutzeroberfl\u00e4chen in Android Apps wird mit dem bekannten Observer Design Pattern durchgef\u00fchrt. Das Subject des Design Patterns wird von der Android View repr\u00e4sentiert. Die entsprechenden EventListener nehmen die Rolle des Observers ein. Der Abauf in Android sieht dabei folgenderma\u00dfen aus: Eine konkrete Implementierung des Observers , zum durch die Implementierung eines OnClickListener wird erstellt. Der Observer wird an einem Subject registriert (zum Beispiel an einem Button ). Im Subject wird das entsprechende Event generiert (zum Beispiel eine Benutzerin klickt auf den Button ) und alle registrierten Observer werden benachrichtigt. Die registrierten Observer arbeiten das Event ab.","title":"Eventhandling"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#umsetzung-des-eventhandling-in-android","text":"Innerhalb einer Activity k\u00f6nnen unterschiedliche Ans\u00e4tze verwendet werden um das Eventhandling zu implementieren. Deklarativ (eingeschr\u00e4nkt) Innerhalb des XML-Dokumentes zum Layout kann an einer View das XML-Attribut onClick mit einer Methode der Activity verkn\u00fcpft werden (Die Methode muss daf\u00fcr eine bestimmte Signatur aufweisen). Programmatisch Die Activity selbst implementiert ein entsprechendes Interface und wird somit zum EventListener . Eine eigene EventListener Klasse wird erstellt und implementiert: Dies kann als eigene Klasse (in eigener Datei) durchgef\u00fchrt werden. Dies kann auch als innere Klasse der Activity durchgef\u00fchrt werden. Eine anonyme Klasse wird einmalig erstellt (Bei der Zuweisung des EventListener ). Ein Lambda-Ausdruck wird verwendet.","title":"Umsetzung des Eventhandling in Android"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#deklarative-zuordnung","text":"Innerhalb der Activity gibt es eine Methode mit beliebigen Name, aber einer vorgegebenen Signatur. public class MainActivity extends AppCompatActivity { // ... public void sayHello ( View view ) { Toast . makeText ( this , \"Hello\" , Toast . LENGTH_SHORT ). show (); } } Im XML-Layout muss die entsprechende Methode an das XML-Attribut onClick als Wert \u00fcbergeben werden. Dies f\u00fchrt dazu, wenn ein Klick auf dem Button ausgef\u00fchrt wird, dass die Methode sayHello ausgef\u00fchrt wird. <Button android:id= \"@+id/button6\" android:layout_width= \"wrap_content\" android:layout_height= \"wrap_content\" android:text= \"Hello\" android:onClick= \"sayHello\" /> Hinweis Die Methode innerhalb der Activity muss folgende Signatur aufweisen: Die Methode muss public sein Die Methode muss void als R\u00fcckgabe haben Die Methode muss eine View als \u00dcbergabeparameter haben (dies ist die View welche geklickt wird) Die deklarative Zuordnung ist eine sehr einfache Methode kann aber nur f\u00fcr Klick-Events verwendet werden.","title":"Deklarative Zuordnung"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#activity-implementiert-interface","text":"Die Activity implementiert das entsprechende Interface des EventListeners . Dadurch wird die Activity selbst zu einem Observer . Das OnClickListener Interface spezifiziert die Methode onClick , welche zu implementieren ist. Im zweiten Schritt muss am entsprechenden Subject , hier ein Button , der EventListener zugeordnet werden. Da die Activity selbst den EventListener implementiert, wird dies durch \u00fcbergabe von this durchgef\u00fchrt. public class ExampleActivity extends Activity implements View . OnClickListener { @Override protected void onCreate ( Bundle savedValues ) { // ... Button button = findViewById ( R . id . corky ); button . setOnClickListener ( this ); } // Implementierung des OnClickListener Interface @Override public void onClick ( View v ) { // ... } } Ein Nachteil dieser Methode ist, dass eine Activity nur eine Interface eines speziellen Typs implementieren kann. Es k\u00f6nnen nich zwei unterschiedlichen OnClickListener implementiert werden.","title":"Activity implementiert Interface"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#implementierung-als-eigene-klasse","text":"Der entsprechende EventListener wird von einer eigene Klasse implementiert. Diese Klasse kann eine inner Klasse sein (wie im Beispiel unten) oder nat\u00fcrlich auch eine eigene Klasse innerhalb einer eigenen Datei. Die Zuweisung der EventListener funktioniert durch die Erstellung einer eigenen Instanz der Klasse. public class ExampleActivity extends Activity { public class MyClickListener implements View . OnClickListener { @Override public void onClick ( View view ) { // ... } } @Override protected void onCreate ( Bundle savedValues ) { // ... Button button = findViewById ( R . id . button ); button . setOnClickListener ( new MyClickListener ()); } } Der Vorteil dieser Variante ist, dass beliebig viele und unterschiedliche Implementierungen eines Event Typs erzeugt werden k\u00f6nnen. Die EventListener k\u00f6nnen auch in unterschiedlichen Activities wiederverwendet werden.","title":"Implementierung als eigene Klasse"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#implementierung-als-anonyme-klasse","text":"Ein EventListener kann nat\u00fcrlich auch als anonyme Klasse implementiert werden. Dabei wird die Implementierung an der Stelle durchgef\u00fchrt an der auch die Zuweisung stattfinden. public class ExampleActivity extends Activity { @Override protected void onCreate ( Bundle savedValues ) { // ... Button button = findViewById ( R . id . button ); button . setOnClickListener ( new View . OnClickListener () { public void onClick ( View v ) { // ... } }); } } Der Nachteil dieser Methode ist, dass der EventListener nur einmal verwendet werden kann. Die Lesbarkeit von anonymen Klassen ist ebenfalls eingeschr\u00e4nkt.","title":"Implementierung als Anonyme Klasse"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#implementierung-durch-lambda-ausdrucke","text":"Lambdas wurden mit Java 8 eingef\u00fchrt und sind auch in Android nutzbar. Lambdas sind Funktionen ohne Klassenkontext (Funktion steht f\u00fcr sich alleine) ohne innerhalb einer Klasse eingebettet zu sein. Lambdas k\u00f6nnen dabei wie Objekte genutzt werden (zB \u00dcbergabe als Parameter an andere Funktionen) und nach belieben ausgef\u00fchrt werden. Ein Lambda Ausdruck hat folgende Struktur: parameter -> expression Hinweis Syntaktische Besonderheiten von Lambdas in Java: Optionale Typ-Deklaration Optionale Klammern bei einem Parameter Optionale Klammern um Body, wenn nur ein Statement vorhanden ist Optionales return-Schl\u00fcsselwort bei ungeklammertem Body Lambdase k\u00f6nnen als Alternative zu anonymen Klassen verwendet werden. Die Lesbarkeit wird dadurch etwas erh\u00f6ht: public class ExampleActivity extends Activity { @Override protected void onCreate ( Bundle savedValues ) { // ... Button button = findViewById ( R . id . button ); button . setOnClickListener (( View view ) -> { /* ... */ }); } }","title":"Implementierung durch Lambda Ausdr\u00fccke"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#referenzen","text":"Layouts LinearLayout : Wichtige Details zum LinearLayout . ConstraintLayout : Wichtige Details zum ConstraintLayout .","title":"Referenzen"},{"location":"android/sixteen-buttons/","text":"Sixteen Buttons Neues Projekt erstellen \u00dcber den Projekt-Wizard wird man durch den Erstellungsprozess geleitet. Neues Projekt Nachdem ersten Start von Android Studio ist die Ansicht, wie unten im Screenshot dargestellt, vorhanden. Dabei kann \u00fcber Klick auf + Start a new Android Studio project ein neues Projekt erstellt werden. Alternativ kann \u00fcber die ge\u00f6ffnete Android Studio Projektansicht \u00fcber das Men\u00fc File > New > New Project... ein neues Projekt erstellt werden. Erste Activity w\u00e4hlen Ein Android Projekt besteht normalerweise zumindest aus einer Activity. Ein gro\u00dfes Android Projekt kann durchaus \u00fcber Hundert Activities umfassen. F\u00fcr ein neues Projekt kann aus ein Templates f\u00fcr die erste Activity gew\u00e4hlt werden. F\u00fcr das Projekt Sixteen Buttons nutzen wird das Template Empty Activity . Projektkonfiguration Im letzten Schritt des Projekt-Wizard werden wichtige Daten zum Projekt festgelegt. All diese Daten k\u00f6nnen grunds\u00e4tzlich sp\u00e4ter noch ver\u00e4ndert werden, dies ist dann aber teilweise mit aufw\u00e4ndigen Refactoring verbunden. Folgende Parameter k\u00f6nnen festgelegt werden: Name: Der Name wird an allen wichtigen Stellen im Android Betriebssystem f\u00fcr die App angezeigt (zB am All-Apps Screen oder am Recents Screen). Package name: Alle Klassen des Projektes werden mit diesem Package Name versehen. Save location: An dieser Stelle wird das Projekt am Dateisystem gespeichert. Language: Native Android Apps k\u00f6nnen grunds\u00e4tzlich in Java oder Kotlin entwickelt werden. Minimum SDK: F\u00fcr Android wird zumindest j\u00e4hrlich eine neue Version (inkl. SDK) ver\u00f6ffentlicht. Die Auswahl h\u00e4ngt davon ab, welche \u00e4lteren Android Versionen von der App noch unterst\u00fctzt werden sollen. W\u00e4hlen Sie die Parameter entsprechend des Screenshots (die Save location ist frei w\u00e4hlbar) und klicken Sie auf Finish . Layout editieren In der Datei res/layout/activity_main.xml findet sich das entsprechende Layout, welches f\u00fcr die Activity geladen wird. Hinweis In der Klasse MainActivity findet man innerhalb der Methode onCreate das Layout, welches der Activity zugeordnet wurde. Mit der Methode setContentView wird \u00fcber die entsprechende Konstante R.layout.activity_main das Layout im Ordner res/layout/activity_main.xml referenziert und dadurch f\u00fcr die Activity festgelegt. Hier k\u00f6nnte jedes beliebige verf\u00fcgbare Layout zugeordnet werden. Layouts werden als XML-Dokumente beschrieben. Ein Layout kann in Android Studio direkt als XML-Dokument \u00fcber die Code-Ansicht oder \u00fcber einen WYSIWYG-Editor in der Design-Ansicht editiert werden. Die Design-Ansicht bietet dabei bereits eine gerenderte Darstellung des XML-Dokumentes. \u00c4nderungen in der Design Ansicht f\u00fchren aber immer zu \u00c4nderungen im XML. Vorerst arbeiten wir nur mit der Code-Ansicht, kopieren Sie dazu den folgenden Code-Auschnitt in den Code-Editor. Der bestehende Inhalt soll dabei gel\u00f6scht werden. <?xml version=\"1.0\" encoding=\"utf-8\"?> <ScrollView xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" xmlns:tools= \"http://schemas.android.com/tools\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" tools:context= \".MainActivity\" > <LinearLayout android:id= \"@+id/button_layout\" android:orientation= \"vertical\" android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" > </LinearLayout> </ScrollView> Im Layout ist das Wurzelelment eine ScrollView . Die ScrollView erzeugt die M\u00f6glichkeit des Scrollens der Kindelemente, welche nicht vollkommen auf dem Bildschirm Platz haben. Innherhalb der ScrollView befindet sich ein LinearLayout . Das LinearLayout erm\u00f6glicht es Kindelemente entweder vertikal oder horizontal in einer Reihe anzuordnen (siehe Attribut android:orientation ). Hinweis Das LinearLayout hat eine android:id als Attribut gesetzt. IDs sind sehr wichtig, da im Quellcode Elemente aus dem Layout \u00fcber die ID referenziert werden k\u00f6nnen. Als Wert f\u00fcr IDs wird eine spezielle Syntax verwendet @+id/beliebiger_name . Mit @+id wird dabei definiert, dass in der Klasse R eine neue ID-Konstante erzeugt werden soll. F\u00fcr den Bezeichner der ID kann ein beliebiger_name festgelegt werden. In der Klasse R wird die ID wie folgt als Konstante erzeugt: R.id.beliebiger_name . Weitere Details dazu finden sich in der Dokumentation . 16 Buttons hinzuf\u00fcgen Das Layout einer Activity kann einerseit deklarativ \u00fcber XML definiert werden. Andererseits k\u00f6nnen aber auch dynamische \u00c4nderungen im Layout zur Laufzeit im Quellcode (programmatisch) durchgef\u00fchrt werden. Im folgenden sollen 16 Buttons innerhalb des LinearLayout hinzugef\u00fcgt werden. Innerhalb der Methode onCreate der Klasse MainActivity soll nun das deklarierte LinearLayout im Quellcode referenzirt werden. Dazu ist die Methode findViewById innerhalb der Activity definiert. Durch \u00fcbergabe einer ID kann das entsprechende Element des Layouts abgefragt werden: LinearLayout linearLayout = findViewById ( R . id . button_layout ); Hinweis Alle Layouts erben von der Klasse ViewGroup . Dies ist eine Klasse die das Verwalten von Kindelementen erm\u00f6glicht. Kindelemente einer ViewGroup k\u00f6nnen entweder Views oder wiederum ViewGroups (f\u00fcr verschachtelte Layouts) sein. Eine ViewGroup definiert dabei wichtige Methoden zur Verwaltung von Kindelementen. Die Methode addView erm\u00f6glicht es Kindelemente hinzuzuf\u00fcgen. Die Methode getChildCount gibt die Anzahl der verwalteten Kindelemente zur\u00fcck und die Methode getChildAt liefert eine Referenz auf ein Kindelement durch die Angabe eines Index (\u00e4hnlich zum Zugriff auf ein Array). Innerhalb einer Schleife sollen dann 16 Buttons \u00fcber die Methode addView an das LinearLayout hinzugef\u00fcgt werden. Jede View (wie zum Beispiel der Button ) bekommt eine Referenz auf die Activity in der sie ausgef\u00fchrt wird, \u00fcber den Konstruktur, \u00fcbergeben. Ein Button besitzt unter anderem die Eigenschaft Text, welche \u00fcber den Setter setText angegeben wird. for ( int i = 0 ; i < 16 ; i ++) { Button button = new Button ( this ); button . setText ( \"Button \" + ( i + 1 )); linearLayout . addView ( buttons [ i ]); } Hinweis Alle Views besitzen Eigenschaften. Diese Eigenschaften k\u00f6nnen entweder deklarativ \u00fcber XML-Attribute im Layout oder programmatisch \u00fcber Setter im Quellcode definiert werden. In den meisten F\u00e4llen gibt es eine 1-zu-1 \u00dcbereinstimmung zwischen Eigentschaften im XML-Layout und \u00fcber Setter der View (leider nicht \u00fcberall). Eigenschaften k\u00f6nnen an der View auch \u00fcber Getter abgefragt werden. Ein Starten der App sollte ein \u00c4hnliches Bild wie der angef\u00fchrte Screenshot liefern. Wichtig ist dabei auch, dass man vertikal Scrollen kann (dies wird durch die ScrollView erm\u00f6glicht). Der gesamte Inhalt der Methode onCreate sollte nun folgenderma\u00dfen aussehen: @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); LinearLayout linearLayout = findViewById ( R . id . button_layout ); for ( int i = 0 ; i < 16 ; i ++) { Button button = new Button ( this ); button . setText ( \"Button \" + ( i + 1 )); linearLayout . addView ( buttons [ i ]); } } Klick Listener hinzuf\u00fcgen Grafische Benutzeroberfl\u00e4chen sollen auf Aktionen von Benutzerinnen reagieren. F\u00fcr eine View in der Oberfl\u00e4che kann f\u00fcr definierte Events (wie zB einen Klick) ein EventListener angeben werden. Immmer wenn das entsprechende Event eintritt wird der zugeordnete EventListener ausgef\u00fchrt. Die unterschiedlichen EventListener sind als Java-Interfaces definiert. Eine einfache M\u00f6glichkeit, um einen entsprechenden EventListener zu implementieren, ist es diesen direkt \u00fcber die Activity zu implementieren. Die MainActivity im Projekt sollte so erweitert werden, dass der OnClickListener , welcher als inneres Interface der Klasse View definiert ist, implementiert wird. Nachdem hinzuf\u00fcgen des implements View.OnClickListener wird von der Klasse MainActivity gefordert, dass das entsprechende Interface implementiert wird. Deshalb muss die Methode onClick mit der definierten Methoden-Signatur hinzugef\u00fcgt werden. Hinweis Android Studio generiert alle Methoden, welche von einem Interface definiert sind. Daf\u00fcr kann das Symbol \"rote Gl\u00fchbirne\" f\u00fcr vorschl\u00e4ge geklickt werden. Dies tritt immer dort auf, wo aktuell ein Fehler von der IDE entdeckt wurde. Falls die \"rote Gl\u00fchbirne\" nicht sichtbar ist, aber ein Fehler vorherrscht, k\u00f6nnen durch die Tastenkombination ALT+Enter die selben Vorschl\u00e4ge generiert werden. Der Cursor muss sich daf\u00fcr in der Zeile mit dem Fehler befinden. public class MainActivity extends AppCompatActivity implements View . OnClickListener { // ... @Override public void onClick ( View v ) { // ... } } Die Methode onClick bekommt dabei eine View als Parameter \u00fcbergeben. Diese View repr\u00e4sentiert genau das Element der Benutzeroberfl\u00e4che, auf welches geklickt wurde. Damit das Event-Handling auch funktioniert, m\u00fcssen die Buttons mit dem implementierten EventListener verkn\u00fcpft werden. F\u00fcr jeden Button, der in der Schleife erzeugt wird, muss dies durchgef\u00fchrt werden: button . setOnClickListener ( this ); Damit irgendetwas passiert nachdem Klick auf den Button, muss auch in der Methode onClick etwas ausgef\u00fchrt werden. Dazu soll ein Toast erzeugt werden, welcher eine kurze Nachricht am Bildschirm einblendet. Da bekannt ist, dass die \u00fcbergebene View ein Button ist, kann auch ein entsprechenden Casting mit (Button) durchgef\u00fchrt werden. @Override public void onClick ( View v ) { Button button = ( Button ) v ; Toast toast = Toast . makeText ( this , \"Klick auf \" + button . getText (), Toast . LENGTH_SHORT ); toast . show (); } Durch Klicken auf Button 6 sollte folgende Darstellung erzeugt werden: Zuf\u00e4lligen Button ausw\u00e4hlen Um das Spiel zu realisieren, sollte ein zuf\u00e4lliger Button ausgew\u00e4hlt werden und bei diesem soll die Schriftfarbe auf Rot gesetzt werden. Dazu sollen im ersten Schritt ein LinearLayout als Eigenschaft der Klasse definiert werden. Mit der Methode findViewById soll entsprechend diese Klasseneigenschaft setzen: public class MainActivity extends AppCompatActivity implements View . OnClickListener { // ... protected LinearLayout linearLayout ; @Override protected void onCreate ( Bundle savedInstanceState ) { // ... linearLayout = findViewById ( R . id . button_layout ); // ... } // ... Zur Auswahl eines zuf\u00e4lligen Buttons muss eine Zufallszahl zwischen 0 und 15 erzeugt werden. Mit der Methode getChildAt des LinearLayout Objektes kann \u00fcber den Index eine View abgefragt werden. Da wir wissen, dass jede View ein Button ist, k\u00f6nnen wir auch das entsprechend casten mit (Button) . Die Farbe des Textes im Button wird dann auf Rot gesetzt. public void selectRandomButton () { int random = ( int ) Math . floor ( Math . random () * linearLayout . getChildCount ()); Button button = ( Button ) linearLayout . getChildAt ( random ); button . setTextColor ( Color . RED ); } Die Methode selectRandomButton sollte dann als letztes in der Methode onCreate aufgerufen werden. Klick pr\u00fcfen F\u00fcr jeden Klick soll nun gepr\u00fcft werden, ob auf einen Button mit rotem Text gedr\u00fcckt wurde. Falls auf einen Button mit rotem Text geklickt wurde, soll der Text wieder auf Schwarz gesetzt werden und ein anderer zuf\u00e4lliger Button soll wieder Rot gef\u00e4rbt werden. Die Schriftfrabe des Buttons kann \u00fcber die Methode getTextColors abgefragt werden. Als R\u00fcckgabewert dieses Getter wird ein Objekt vom ColorStateList zur\u00fcckgegeben. Da ein Button f\u00fcr unterschiedliche Zust\u00e4nde (zB Enabled/Disabled, Gedr\u00fcckt, ...) eine andere Farbe definiert haben kann, wird eben eine ColorSateList verwendet. Dabei kann die Methode getDefaultColor der ColorStateList verwendet werden, um die Schriftfarbe im \"Normalzustand\" des Buttons abzufragen. Im Falle einer \u00dcbereinstimmung mit der Farbe Rot ( Color.RED ) soll eben die Farbe auf Schwarz ( Color.BLACK ) gesetzt ewrden. Des Weiteren soll ein weiterer zuf\u00e4lliger Button Rot eingef\u00e4rbt werden ( selectRandomButton ). @Override public void onClick ( View v ) { Button button = ( Button ) v ; int color = button . getTextColors (). getDefaultColor (); if ( color == Color . RED ) { button . setTextColor ( Color . BLACK ); selectRandomButton (); } } Im folgenden Screenshot wird ein zuf\u00e4llig Rot gef\u00e4rbter Button angezeigt: Gesamter Quellcode activity_main.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <ScrollView xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" xmlns:tools= \"http://schemas.android.com/tools\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" tools:context= \".MainActivity\" > <LinearLayout android:id= \"@+id/button_layout\" android:orientation= \"vertical\" android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" > </LinearLayout> </ScrollView> MainActivity package fhku.sixteenbuttons ; import androidx.appcompat.app.AppCompatActivity ; import android.graphics.Color ; import android.os.Bundle ; import android.view.View ; import android.widget.Button ; import android.widget.LinearLayout ; import android.widget.Toast ; public class MainActivity extends AppCompatActivity implements View . OnClickListener { protected LinearLayout linearLayout ; @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); linearLayout = findViewById ( R . id . button_layout ); for ( int i = 0 ; i < 16 ; i ++) { Button button = new Button ( this ); button . setText ( \"Button \" + ( i + 1 )); button . setOnClickListener ( this ); linearLayout . addView ( button ); } selectRandomButton (); } @Override public void onClick ( View v ) { Button button = ( Button ) v ; int color = button . getTextColors (). getDefaultColor (); if ( color == Color . RED ) { button . setTextColor ( Color . BLACK ); selectRandomButton (); } // Toast toast = Toast.makeText(this, \"Klick auf \" + button.getText(), Toast.LENGTH_SHORT); // toast.show(); } public void selectRandomButton () { int random = ( int ) Math . floor ( Math . random () * linearLayout . getChildCount ()); Button button = ( Button ) linearLayout . getChildAt ( random ); button . setTextColor ( Color . RED ); } }","title":"Sixteen Buttons"},{"location":"android/sixteen-buttons/#sixteen-buttons","text":"","title":"Sixteen Buttons"},{"location":"android/sixteen-buttons/#neues-projekt-erstellen","text":"\u00dcber den Projekt-Wizard wird man durch den Erstellungsprozess geleitet.","title":"Neues Projekt erstellen"},{"location":"android/sixteen-buttons/#neues-projekt","text":"Nachdem ersten Start von Android Studio ist die Ansicht, wie unten im Screenshot dargestellt, vorhanden. Dabei kann \u00fcber Klick auf + Start a new Android Studio project ein neues Projekt erstellt werden. Alternativ kann \u00fcber die ge\u00f6ffnete Android Studio Projektansicht \u00fcber das Men\u00fc File > New > New Project... ein neues Projekt erstellt werden.","title":"Neues Projekt"},{"location":"android/sixteen-buttons/#erste-activity-wahlen","text":"Ein Android Projekt besteht normalerweise zumindest aus einer Activity. Ein gro\u00dfes Android Projekt kann durchaus \u00fcber Hundert Activities umfassen. F\u00fcr ein neues Projekt kann aus ein Templates f\u00fcr die erste Activity gew\u00e4hlt werden. F\u00fcr das Projekt Sixteen Buttons nutzen wird das Template Empty Activity .","title":"Erste Activity w\u00e4hlen"},{"location":"android/sixteen-buttons/#projektkonfiguration","text":"Im letzten Schritt des Projekt-Wizard werden wichtige Daten zum Projekt festgelegt. All diese Daten k\u00f6nnen grunds\u00e4tzlich sp\u00e4ter noch ver\u00e4ndert werden, dies ist dann aber teilweise mit aufw\u00e4ndigen Refactoring verbunden. Folgende Parameter k\u00f6nnen festgelegt werden: Name: Der Name wird an allen wichtigen Stellen im Android Betriebssystem f\u00fcr die App angezeigt (zB am All-Apps Screen oder am Recents Screen). Package name: Alle Klassen des Projektes werden mit diesem Package Name versehen. Save location: An dieser Stelle wird das Projekt am Dateisystem gespeichert. Language: Native Android Apps k\u00f6nnen grunds\u00e4tzlich in Java oder Kotlin entwickelt werden. Minimum SDK: F\u00fcr Android wird zumindest j\u00e4hrlich eine neue Version (inkl. SDK) ver\u00f6ffentlicht. Die Auswahl h\u00e4ngt davon ab, welche \u00e4lteren Android Versionen von der App noch unterst\u00fctzt werden sollen. W\u00e4hlen Sie die Parameter entsprechend des Screenshots (die Save location ist frei w\u00e4hlbar) und klicken Sie auf Finish .","title":"Projektkonfiguration"},{"location":"android/sixteen-buttons/#layout-editieren","text":"In der Datei res/layout/activity_main.xml findet sich das entsprechende Layout, welches f\u00fcr die Activity geladen wird. Hinweis In der Klasse MainActivity findet man innerhalb der Methode onCreate das Layout, welches der Activity zugeordnet wurde. Mit der Methode setContentView wird \u00fcber die entsprechende Konstante R.layout.activity_main das Layout im Ordner res/layout/activity_main.xml referenziert und dadurch f\u00fcr die Activity festgelegt. Hier k\u00f6nnte jedes beliebige verf\u00fcgbare Layout zugeordnet werden. Layouts werden als XML-Dokumente beschrieben. Ein Layout kann in Android Studio direkt als XML-Dokument \u00fcber die Code-Ansicht oder \u00fcber einen WYSIWYG-Editor in der Design-Ansicht editiert werden. Die Design-Ansicht bietet dabei bereits eine gerenderte Darstellung des XML-Dokumentes. \u00c4nderungen in der Design Ansicht f\u00fchren aber immer zu \u00c4nderungen im XML. Vorerst arbeiten wir nur mit der Code-Ansicht, kopieren Sie dazu den folgenden Code-Auschnitt in den Code-Editor. Der bestehende Inhalt soll dabei gel\u00f6scht werden. <?xml version=\"1.0\" encoding=\"utf-8\"?> <ScrollView xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" xmlns:tools= \"http://schemas.android.com/tools\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" tools:context= \".MainActivity\" > <LinearLayout android:id= \"@+id/button_layout\" android:orientation= \"vertical\" android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" > </LinearLayout> </ScrollView> Im Layout ist das Wurzelelment eine ScrollView . Die ScrollView erzeugt die M\u00f6glichkeit des Scrollens der Kindelemente, welche nicht vollkommen auf dem Bildschirm Platz haben. Innherhalb der ScrollView befindet sich ein LinearLayout . Das LinearLayout erm\u00f6glicht es Kindelemente entweder vertikal oder horizontal in einer Reihe anzuordnen (siehe Attribut android:orientation ). Hinweis Das LinearLayout hat eine android:id als Attribut gesetzt. IDs sind sehr wichtig, da im Quellcode Elemente aus dem Layout \u00fcber die ID referenziert werden k\u00f6nnen. Als Wert f\u00fcr IDs wird eine spezielle Syntax verwendet @+id/beliebiger_name . Mit @+id wird dabei definiert, dass in der Klasse R eine neue ID-Konstante erzeugt werden soll. F\u00fcr den Bezeichner der ID kann ein beliebiger_name festgelegt werden. In der Klasse R wird die ID wie folgt als Konstante erzeugt: R.id.beliebiger_name . Weitere Details dazu finden sich in der Dokumentation .","title":"Layout editieren"},{"location":"android/sixteen-buttons/#16-buttons-hinzufugen","text":"Das Layout einer Activity kann einerseit deklarativ \u00fcber XML definiert werden. Andererseits k\u00f6nnen aber auch dynamische \u00c4nderungen im Layout zur Laufzeit im Quellcode (programmatisch) durchgef\u00fchrt werden. Im folgenden sollen 16 Buttons innerhalb des LinearLayout hinzugef\u00fcgt werden. Innerhalb der Methode onCreate der Klasse MainActivity soll nun das deklarierte LinearLayout im Quellcode referenzirt werden. Dazu ist die Methode findViewById innerhalb der Activity definiert. Durch \u00fcbergabe einer ID kann das entsprechende Element des Layouts abgefragt werden: LinearLayout linearLayout = findViewById ( R . id . button_layout ); Hinweis Alle Layouts erben von der Klasse ViewGroup . Dies ist eine Klasse die das Verwalten von Kindelementen erm\u00f6glicht. Kindelemente einer ViewGroup k\u00f6nnen entweder Views oder wiederum ViewGroups (f\u00fcr verschachtelte Layouts) sein. Eine ViewGroup definiert dabei wichtige Methoden zur Verwaltung von Kindelementen. Die Methode addView erm\u00f6glicht es Kindelemente hinzuzuf\u00fcgen. Die Methode getChildCount gibt die Anzahl der verwalteten Kindelemente zur\u00fcck und die Methode getChildAt liefert eine Referenz auf ein Kindelement durch die Angabe eines Index (\u00e4hnlich zum Zugriff auf ein Array). Innerhalb einer Schleife sollen dann 16 Buttons \u00fcber die Methode addView an das LinearLayout hinzugef\u00fcgt werden. Jede View (wie zum Beispiel der Button ) bekommt eine Referenz auf die Activity in der sie ausgef\u00fchrt wird, \u00fcber den Konstruktur, \u00fcbergeben. Ein Button besitzt unter anderem die Eigenschaft Text, welche \u00fcber den Setter setText angegeben wird. for ( int i = 0 ; i < 16 ; i ++) { Button button = new Button ( this ); button . setText ( \"Button \" + ( i + 1 )); linearLayout . addView ( buttons [ i ]); } Hinweis Alle Views besitzen Eigenschaften. Diese Eigenschaften k\u00f6nnen entweder deklarativ \u00fcber XML-Attribute im Layout oder programmatisch \u00fcber Setter im Quellcode definiert werden. In den meisten F\u00e4llen gibt es eine 1-zu-1 \u00dcbereinstimmung zwischen Eigentschaften im XML-Layout und \u00fcber Setter der View (leider nicht \u00fcberall). Eigenschaften k\u00f6nnen an der View auch \u00fcber Getter abgefragt werden. Ein Starten der App sollte ein \u00c4hnliches Bild wie der angef\u00fchrte Screenshot liefern. Wichtig ist dabei auch, dass man vertikal Scrollen kann (dies wird durch die ScrollView erm\u00f6glicht). Der gesamte Inhalt der Methode onCreate sollte nun folgenderma\u00dfen aussehen: @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); LinearLayout linearLayout = findViewById ( R . id . button_layout ); for ( int i = 0 ; i < 16 ; i ++) { Button button = new Button ( this ); button . setText ( \"Button \" + ( i + 1 )); linearLayout . addView ( buttons [ i ]); } }","title":"16 Buttons hinzuf\u00fcgen"},{"location":"android/sixteen-buttons/#klick-listener-hinzufugen","text":"Grafische Benutzeroberfl\u00e4chen sollen auf Aktionen von Benutzerinnen reagieren. F\u00fcr eine View in der Oberfl\u00e4che kann f\u00fcr definierte Events (wie zB einen Klick) ein EventListener angeben werden. Immmer wenn das entsprechende Event eintritt wird der zugeordnete EventListener ausgef\u00fchrt. Die unterschiedlichen EventListener sind als Java-Interfaces definiert. Eine einfache M\u00f6glichkeit, um einen entsprechenden EventListener zu implementieren, ist es diesen direkt \u00fcber die Activity zu implementieren. Die MainActivity im Projekt sollte so erweitert werden, dass der OnClickListener , welcher als inneres Interface der Klasse View definiert ist, implementiert wird. Nachdem hinzuf\u00fcgen des implements View.OnClickListener wird von der Klasse MainActivity gefordert, dass das entsprechende Interface implementiert wird. Deshalb muss die Methode onClick mit der definierten Methoden-Signatur hinzugef\u00fcgt werden. Hinweis Android Studio generiert alle Methoden, welche von einem Interface definiert sind. Daf\u00fcr kann das Symbol \"rote Gl\u00fchbirne\" f\u00fcr vorschl\u00e4ge geklickt werden. Dies tritt immer dort auf, wo aktuell ein Fehler von der IDE entdeckt wurde. Falls die \"rote Gl\u00fchbirne\" nicht sichtbar ist, aber ein Fehler vorherrscht, k\u00f6nnen durch die Tastenkombination ALT+Enter die selben Vorschl\u00e4ge generiert werden. Der Cursor muss sich daf\u00fcr in der Zeile mit dem Fehler befinden. public class MainActivity extends AppCompatActivity implements View . OnClickListener { // ... @Override public void onClick ( View v ) { // ... } } Die Methode onClick bekommt dabei eine View als Parameter \u00fcbergeben. Diese View repr\u00e4sentiert genau das Element der Benutzeroberfl\u00e4che, auf welches geklickt wurde. Damit das Event-Handling auch funktioniert, m\u00fcssen die Buttons mit dem implementierten EventListener verkn\u00fcpft werden. F\u00fcr jeden Button, der in der Schleife erzeugt wird, muss dies durchgef\u00fchrt werden: button . setOnClickListener ( this ); Damit irgendetwas passiert nachdem Klick auf den Button, muss auch in der Methode onClick etwas ausgef\u00fchrt werden. Dazu soll ein Toast erzeugt werden, welcher eine kurze Nachricht am Bildschirm einblendet. Da bekannt ist, dass die \u00fcbergebene View ein Button ist, kann auch ein entsprechenden Casting mit (Button) durchgef\u00fchrt werden. @Override public void onClick ( View v ) { Button button = ( Button ) v ; Toast toast = Toast . makeText ( this , \"Klick auf \" + button . getText (), Toast . LENGTH_SHORT ); toast . show (); } Durch Klicken auf Button 6 sollte folgende Darstellung erzeugt werden:","title":"Klick Listener hinzuf\u00fcgen"},{"location":"android/sixteen-buttons/#zufalligen-button-auswahlen","text":"Um das Spiel zu realisieren, sollte ein zuf\u00e4lliger Button ausgew\u00e4hlt werden und bei diesem soll die Schriftfarbe auf Rot gesetzt werden. Dazu sollen im ersten Schritt ein LinearLayout als Eigenschaft der Klasse definiert werden. Mit der Methode findViewById soll entsprechend diese Klasseneigenschaft setzen: public class MainActivity extends AppCompatActivity implements View . OnClickListener { // ... protected LinearLayout linearLayout ; @Override protected void onCreate ( Bundle savedInstanceState ) { // ... linearLayout = findViewById ( R . id . button_layout ); // ... } // ... Zur Auswahl eines zuf\u00e4lligen Buttons muss eine Zufallszahl zwischen 0 und 15 erzeugt werden. Mit der Methode getChildAt des LinearLayout Objektes kann \u00fcber den Index eine View abgefragt werden. Da wir wissen, dass jede View ein Button ist, k\u00f6nnen wir auch das entsprechend casten mit (Button) . Die Farbe des Textes im Button wird dann auf Rot gesetzt. public void selectRandomButton () { int random = ( int ) Math . floor ( Math . random () * linearLayout . getChildCount ()); Button button = ( Button ) linearLayout . getChildAt ( random ); button . setTextColor ( Color . RED ); } Die Methode selectRandomButton sollte dann als letztes in der Methode onCreate aufgerufen werden.","title":"Zuf\u00e4lligen Button ausw\u00e4hlen"},{"location":"android/sixteen-buttons/#klick-prufen","text":"F\u00fcr jeden Klick soll nun gepr\u00fcft werden, ob auf einen Button mit rotem Text gedr\u00fcckt wurde. Falls auf einen Button mit rotem Text geklickt wurde, soll der Text wieder auf Schwarz gesetzt werden und ein anderer zuf\u00e4lliger Button soll wieder Rot gef\u00e4rbt werden. Die Schriftfrabe des Buttons kann \u00fcber die Methode getTextColors abgefragt werden. Als R\u00fcckgabewert dieses Getter wird ein Objekt vom ColorStateList zur\u00fcckgegeben. Da ein Button f\u00fcr unterschiedliche Zust\u00e4nde (zB Enabled/Disabled, Gedr\u00fcckt, ...) eine andere Farbe definiert haben kann, wird eben eine ColorSateList verwendet. Dabei kann die Methode getDefaultColor der ColorStateList verwendet werden, um die Schriftfarbe im \"Normalzustand\" des Buttons abzufragen. Im Falle einer \u00dcbereinstimmung mit der Farbe Rot ( Color.RED ) soll eben die Farbe auf Schwarz ( Color.BLACK ) gesetzt ewrden. Des Weiteren soll ein weiterer zuf\u00e4lliger Button Rot eingef\u00e4rbt werden ( selectRandomButton ). @Override public void onClick ( View v ) { Button button = ( Button ) v ; int color = button . getTextColors (). getDefaultColor (); if ( color == Color . RED ) { button . setTextColor ( Color . BLACK ); selectRandomButton (); } } Im folgenden Screenshot wird ein zuf\u00e4llig Rot gef\u00e4rbter Button angezeigt:","title":"Klick pr\u00fcfen"},{"location":"android/sixteen-buttons/#gesamter-quellcode","text":"","title":"Gesamter Quellcode"},{"location":"android/sixteen-buttons/#activity_mainxml","text":"<?xml version=\"1.0\" encoding=\"utf-8\"?> <ScrollView xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" xmlns:tools= \"http://schemas.android.com/tools\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" tools:context= \".MainActivity\" > <LinearLayout android:id= \"@+id/button_layout\" android:orientation= \"vertical\" android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" > </LinearLayout> </ScrollView>","title":"activity_main.xml"},{"location":"android/sixteen-buttons/#mainactivity","text":"package fhku.sixteenbuttons ; import androidx.appcompat.app.AppCompatActivity ; import android.graphics.Color ; import android.os.Bundle ; import android.view.View ; import android.widget.Button ; import android.widget.LinearLayout ; import android.widget.Toast ; public class MainActivity extends AppCompatActivity implements View . OnClickListener { protected LinearLayout linearLayout ; @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); linearLayout = findViewById ( R . id . button_layout ); for ( int i = 0 ; i < 16 ; i ++) { Button button = new Button ( this ); button . setText ( \"Button \" + ( i + 1 )); button . setOnClickListener ( this ); linearLayout . addView ( button ); } selectRandomButton (); } @Override public void onClick ( View v ) { Button button = ( Button ) v ; int color = button . getTextColors (). getDefaultColor (); if ( color == Color . RED ) { button . setTextColor ( Color . BLACK ); selectRandomButton (); } // Toast toast = Toast.makeText(this, \"Klick auf \" + button.getText(), Toast.LENGTH_SHORT); // toast.show(); } public void selectRandomButton () { int random = ( int ) Math . floor ( Math . random () * linearLayout . getChildCount ()); Button button = ( Button ) linearLayout . getChildAt ( random ); button . setTextColor ( Color . RED ); } }","title":"MainActivity"},{"location":"android/snake/","text":"Snake Projekt\u00fcbersicht F\u00fcr das Projekt werden 3 Activities ben\u00f6tigt. Jeder Screen der App wird \u00fcber eine Activity realisiert. F\u00fcr jede Activity muss auch ein eigenes Layout als XML erstellt werden. Am Startscreen ( MainActivity ) finden sich 3 Buttons , welche jeweils \u00fcber einen Intent die GameActivity starten. Dabei soll der Intent \u00fcber ein Extra den Parameter speed \u00fcbergeben. Der Parameter bestimmt dabei wie schnell sich die Schlange bewegen soll. Jenachdem welcher der 3 Buttons geklickt wurde, ist dies eben ein anderer Wert. Die GameActivity enth\u00e4lt das entsprechende Spiel. Dabei soll eine eigene View implementiert werden, welche die Schlange enth\u00e4lt. Es gibt unten 4 Buttons welche die Bewegung der Schlange erm\u00f6glichen. Oben findet sich ebenfalls noch ein dynamisches Textfeld, welches f\u00fcr jede Bewegung, welche die Schlange macht um eins hochgez\u00e4hlt wird. Falls das Schlange an den Rand oder an einen Teil ihres K\u00f6rpers gespielt wurde, ist das Spiel beendet. In diesem Fall soll die GameOverActivity ge\u00f6ffnet werden. Im Intent soll ein Extra mit der Anzahl der moves \u00fcbergeben werden. Diese sollen auch in der GameOverActivity angezeigt werden. Es gibt ebenfalls einen Button zum Restart des Spieles. Dieser soll zur MainActivity leiten (\u00fcber einen Intent ). Projekt clonen Es steht eine Ausgangsbasis f\u00fcr das Projekt bereit. Dieses ist \u00fcber Gitlab zu beziehen. Im Projekt finden sich alle Aufgaben als TODOS in Android Studio. Diese m\u00fcssen Schritt f\u00fcr Schritt abgearbeitet werden um das Spiel zu realisieren. Klasse Snake Innerhalb der Klasse Snake befindet sich die gesamte Spiellogik. public class Snake { // Konstanten f\u00fcr die unterschiedlichen Werte, welche in Zellen // stehen k\u00f6nnen. F\u00fcr den BODY der Schlange wird ein dynamischer // Wert errechnet: Der BODY wird in jedem Zug um eins erh\u00f6ht public static final int CELL_EMPTY = 0 ; public static final int CELL_APPLE = - 1 ; public static final int CELL_HEAD = - 2 ; // Die unterschiedlichen \u00c4nderungen, welche bei einem MOVE in // die entsprechende Richtung die Koordinate ge\u00e4ndert werden // Zum Beispiel nach links wird die Koordinate x=-1 und y=0 ge\u00e4ndert public static final int [] MOVE_LEFT = {- 1 , 0 }; public static final int [] MOVE_RIGHT = { 1 , 0 }; public static final int [] MOVE_UP = { 0 , - 1 }; public static final int [] MOVE_DOWN = { 0 , 1 }; // 2-dimensionales Spielfeld public int [][] grid ; // \u00c4nderungskoordinate in jeden Spielzug // diese wird durch die Methoden // moveUp, moveDown, moveLeft, moveRight ver\u00e4ndert public int [] move = { 1 , 0 }; // x/y Koordinate des Schlangenkopf public int [] head ; // x/y Koordinate des Hinterteils der Schlange public int [] tail ; // x/y Koordinate des Apfels public int [] apple ; // Jede Bewegung des Kopfes erh\u00f6ht // diesen Wert um 1 public int headMoves = 1 ; public Snake ( int size ) { grid = new int [ size ][ size ]; } // Diese Methode initialisiert das Spielfeld // Die Schlange hat den Kopf und ein K\u00f6rperteil public void init () { // TODO: Zellen initialisieren // Alle Zellen des Grids leer setzten (CELL_EMPTY) // in der Mitte des Spielfeldes den Kopf setzen und links daneben den ersten Body // Der Body hat im ersten Schritt den Wert 1 // dieser ist in der Variable headMoves zu finden setApple (); } // Diese Methode soll den Apfel zuf\u00e4llig setzen public void setApple () { // TODO: Apfel zuf\u00e4llig setzen // Zuf\u00e4llig eine freie Position (CELL_EMPTY) suchen und Apfel (CELL_APPLE) positionieren // x/y f\u00fcr den Apfel in der Variable apple setzen } // Diese Methode ist verantwortlich f\u00fcr die Durchf\u00fchrung des n\u00e4chsten Spielzuges. // Diese Methode liefert true zur\u00fcck falls der Spielzug g\u00fcltig war und erfolgreich // durchgef\u00fchrt werden konnte. Diese Methode liefert false zur\u00fcck wenn der Zug // ung\u00fcltig w\u00e4re. Ein R\u00fcckgabewert false bedeutet auch, dass das Spiel verloren wurde public boolean next () { // der n\u00e4chste Zug wird errechnet indem die aktuelle Position des head mit // den \u00c4nderungskoordinaten in x und y Richtung addiert wird // moveX und moveY stellen die n\u00e4chsten Koordinaten, wohin die Schlange // wandern w\u00fcrde dar int moveX = head [ 0 ] + move [ 0 ]; int moveY = head [ 1 ] + move [ 1 ]; // TODO: G\u00fcltige Bewegung (innerhalb des Spielfeldes) // Pr\u00fcfen ob die Bewegung au\u00dferhalb des Spielfelds f\u00fchren w\u00fcrde // return false falls dies der Fall w\u00e4re // TODO: G\u00fcltige Bewegung (Teil der Schlange) // Pr\u00fcfen ob n\u00e4chster Zug Teil der Schlange ist // return false falls dies der Fall w\u00e4re // TODO: Ist der n\u00e4chste Zug ein Apfel? // Pr\u00fcfen ob n\u00e4chster Zug ein Apfel ist, dann soll: // (1) nur der Kopf bewegt werden: auf die neue Position // (2) headMoves + 1 und im Spielfeld ein neues K\u00f6rperteil (mit neuem headMoves Wert) anstelle des Kopfs setzen // (3) einen neuen Apfel zuf\u00e4llig auf ein leeres Feld positionieren // (4) return true // TODO: Ist der n\u00e4chste Zug ein leeres Feld? // Pr\u00fcfen ob n\u00e4chster Zug ein leeres Feld ist, dann soll: // (1) der Kopf bewegt werden // (2) im Spielfeld ein neues K\u00f6rperteil anstelle des Kopfs und Kopfs weiterbewegen // (3) Schwanzteil eliminieren und tail auf vorletztes Teil setzen (vorletztes Teil \u00fcber headMoves + 1 erkennen) // (4) return true return false ; } public void moveUp () { move = MOVE_UP ; } public void moveDown () { move = MOVE_DOWN ; } public void moveLeft () { move = MOVE_LEFT ; } public void moveRight () { move = MOVE_RIGHT ; } } Eigene View Klasse Die Klasse SnakeView ist eine quadratische View und zeichnet das Spielfeld. Zum entsprechenden Interval wird die Methode draw aufgerufen mit dem Spielfeld aus der Klasse Snake . Innerhalb der Methode onDraw wird dann das Spielfeld auf der bereitgestellten Canvas neu gezeichnet. public class SnakeView extends View { protected Paint paintBackground ; protected Paint paintSnakeBody ; protected Paint paintSnakeHead ; protected Paint paintApple ; protected int [][] grid ; public SnakeView ( Context context , @Nullable AttributeSet attrs ) { super ( context , attrs ); // TODO: Zeichenstifte erzeugen // die 4 Zeichenstifte (Paint) sollen erzeugt werden: // Background=Gr\u00fcn, Apfel=Rot // Schlangenkopf=Dunkelgrau, Schlangenk\u00f6rper=Hellgrau } public void draw ( int [][] grid ) { this . grid = grid ; // Durch den Aufruf der Methode invalidate, wird das // Neuzeichnen der View zum n\u00e4chsten m\u00f6glichen Zeitpunk gefordert // Wann dies genau passiert wird dann vom Betriebssystem entschieden invalidate (); } @Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { // in dieser Methode wird festgelegt, dass die View immer // eine quadratische Grundfl\u00e4che hat, hier muss nichts ver\u00e4ndert werden int parentWidth = MeasureSpec . getSize ( widthMeasureSpec ); setMeasuredDimension ( parentWidth , parentWidth ); } @Override protected void onDraw ( Canvas canvas ) { // Eine invalidierte View wird nach Vorgabe vom Betriebssystem neu gezeichnet // daf\u00fcr wird die Methode onDraw aufgerufen und eine Canvas \u00fcbergeben // Das Canvas hat die Methode getWidth bzw. getHeight um die verf\u00fcgbare // Gr\u00f6\u00dfe zu errechnen, die Gr\u00f6\u00dfe einer Zelle kann dadurch errechnet werden // TODO: Spielfeld zeichnen // (1) Der Hintergrund soll als Rechteck gezeichnet werden // (2) Der Apfel als Roter Kreis // (3) Der Kopf als Dunkelgrauer Kreis // (4) Alle K\u00f6rperteile als Hellgrauer Kreis } } GameActivity Layout Die Klasse SnakeView kann wie folgt im XML-Layout integriert werden. Es kann an allen R\u00e4ndern eine Margin gesetzt werden. Falls der Hintergrund des Layouts Schwarz ist, entsteht der schwarze Rand um das Spielfeld (Ersichtlich im Screenshot). <fhku.snake.SnakeView android:id= \"@+id/snake_view\" android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:layout_marginStart= \"8dp\" android:layout_marginTop= \"8dp\" android:layout_marginEnd= \"8dp\" android:layout_marginBottom= \"8dp\" /> Die Buttons zur Steuerung des Spiels k\u00f6nnen als ImageButtons erzeugt werden. Die Symbole, welche sich auf den Buttons befinden wurden als Vektorgrafiken bereitgestellt. Die 4 Buttons k\u00f6nnen dabei die selbe Grafik verwenden, m\u00fcssen diese nur rotieren (Siehe Eigenschaft rotation ). Dei 4 Buttons sollen dabei innerhalb eines horizontalen LinearLayouts gesetzt werden. <ImageButton android:id= \"@+id/button_left\" android:layout_width= \"wrap_content\" android:layout_height= \"wrap_content\" android:layout_weight= \"1\" android:background= \"#00FF00\" android:rotation= \"180\" app:srcCompat= \"@drawable/button\" />","title":"Snake"},{"location":"android/snake/#snake","text":"","title":"Snake"},{"location":"android/snake/#projektubersicht","text":"F\u00fcr das Projekt werden 3 Activities ben\u00f6tigt. Jeder Screen der App wird \u00fcber eine Activity realisiert. F\u00fcr jede Activity muss auch ein eigenes Layout als XML erstellt werden. Am Startscreen ( MainActivity ) finden sich 3 Buttons , welche jeweils \u00fcber einen Intent die GameActivity starten. Dabei soll der Intent \u00fcber ein Extra den Parameter speed \u00fcbergeben. Der Parameter bestimmt dabei wie schnell sich die Schlange bewegen soll. Jenachdem welcher der 3 Buttons geklickt wurde, ist dies eben ein anderer Wert. Die GameActivity enth\u00e4lt das entsprechende Spiel. Dabei soll eine eigene View implementiert werden, welche die Schlange enth\u00e4lt. Es gibt unten 4 Buttons welche die Bewegung der Schlange erm\u00f6glichen. Oben findet sich ebenfalls noch ein dynamisches Textfeld, welches f\u00fcr jede Bewegung, welche die Schlange macht um eins hochgez\u00e4hlt wird. Falls das Schlange an den Rand oder an einen Teil ihres K\u00f6rpers gespielt wurde, ist das Spiel beendet. In diesem Fall soll die GameOverActivity ge\u00f6ffnet werden. Im Intent soll ein Extra mit der Anzahl der moves \u00fcbergeben werden. Diese sollen auch in der GameOverActivity angezeigt werden. Es gibt ebenfalls einen Button zum Restart des Spieles. Dieser soll zur MainActivity leiten (\u00fcber einen Intent ).","title":"Projekt\u00fcbersicht"},{"location":"android/snake/#projekt-clonen","text":"Es steht eine Ausgangsbasis f\u00fcr das Projekt bereit. Dieses ist \u00fcber Gitlab zu beziehen. Im Projekt finden sich alle Aufgaben als TODOS in Android Studio. Diese m\u00fcssen Schritt f\u00fcr Schritt abgearbeitet werden um das Spiel zu realisieren.","title":"Projekt clonen"},{"location":"android/snake/#klasse-snake","text":"Innerhalb der Klasse Snake befindet sich die gesamte Spiellogik. public class Snake { // Konstanten f\u00fcr die unterschiedlichen Werte, welche in Zellen // stehen k\u00f6nnen. F\u00fcr den BODY der Schlange wird ein dynamischer // Wert errechnet: Der BODY wird in jedem Zug um eins erh\u00f6ht public static final int CELL_EMPTY = 0 ; public static final int CELL_APPLE = - 1 ; public static final int CELL_HEAD = - 2 ; // Die unterschiedlichen \u00c4nderungen, welche bei einem MOVE in // die entsprechende Richtung die Koordinate ge\u00e4ndert werden // Zum Beispiel nach links wird die Koordinate x=-1 und y=0 ge\u00e4ndert public static final int [] MOVE_LEFT = {- 1 , 0 }; public static final int [] MOVE_RIGHT = { 1 , 0 }; public static final int [] MOVE_UP = { 0 , - 1 }; public static final int [] MOVE_DOWN = { 0 , 1 }; // 2-dimensionales Spielfeld public int [][] grid ; // \u00c4nderungskoordinate in jeden Spielzug // diese wird durch die Methoden // moveUp, moveDown, moveLeft, moveRight ver\u00e4ndert public int [] move = { 1 , 0 }; // x/y Koordinate des Schlangenkopf public int [] head ; // x/y Koordinate des Hinterteils der Schlange public int [] tail ; // x/y Koordinate des Apfels public int [] apple ; // Jede Bewegung des Kopfes erh\u00f6ht // diesen Wert um 1 public int headMoves = 1 ; public Snake ( int size ) { grid = new int [ size ][ size ]; } // Diese Methode initialisiert das Spielfeld // Die Schlange hat den Kopf und ein K\u00f6rperteil public void init () { // TODO: Zellen initialisieren // Alle Zellen des Grids leer setzten (CELL_EMPTY) // in der Mitte des Spielfeldes den Kopf setzen und links daneben den ersten Body // Der Body hat im ersten Schritt den Wert 1 // dieser ist in der Variable headMoves zu finden setApple (); } // Diese Methode soll den Apfel zuf\u00e4llig setzen public void setApple () { // TODO: Apfel zuf\u00e4llig setzen // Zuf\u00e4llig eine freie Position (CELL_EMPTY) suchen und Apfel (CELL_APPLE) positionieren // x/y f\u00fcr den Apfel in der Variable apple setzen } // Diese Methode ist verantwortlich f\u00fcr die Durchf\u00fchrung des n\u00e4chsten Spielzuges. // Diese Methode liefert true zur\u00fcck falls der Spielzug g\u00fcltig war und erfolgreich // durchgef\u00fchrt werden konnte. Diese Methode liefert false zur\u00fcck wenn der Zug // ung\u00fcltig w\u00e4re. Ein R\u00fcckgabewert false bedeutet auch, dass das Spiel verloren wurde public boolean next () { // der n\u00e4chste Zug wird errechnet indem die aktuelle Position des head mit // den \u00c4nderungskoordinaten in x und y Richtung addiert wird // moveX und moveY stellen die n\u00e4chsten Koordinaten, wohin die Schlange // wandern w\u00fcrde dar int moveX = head [ 0 ] + move [ 0 ]; int moveY = head [ 1 ] + move [ 1 ]; // TODO: G\u00fcltige Bewegung (innerhalb des Spielfeldes) // Pr\u00fcfen ob die Bewegung au\u00dferhalb des Spielfelds f\u00fchren w\u00fcrde // return false falls dies der Fall w\u00e4re // TODO: G\u00fcltige Bewegung (Teil der Schlange) // Pr\u00fcfen ob n\u00e4chster Zug Teil der Schlange ist // return false falls dies der Fall w\u00e4re // TODO: Ist der n\u00e4chste Zug ein Apfel? // Pr\u00fcfen ob n\u00e4chster Zug ein Apfel ist, dann soll: // (1) nur der Kopf bewegt werden: auf die neue Position // (2) headMoves + 1 und im Spielfeld ein neues K\u00f6rperteil (mit neuem headMoves Wert) anstelle des Kopfs setzen // (3) einen neuen Apfel zuf\u00e4llig auf ein leeres Feld positionieren // (4) return true // TODO: Ist der n\u00e4chste Zug ein leeres Feld? // Pr\u00fcfen ob n\u00e4chster Zug ein leeres Feld ist, dann soll: // (1) der Kopf bewegt werden // (2) im Spielfeld ein neues K\u00f6rperteil anstelle des Kopfs und Kopfs weiterbewegen // (3) Schwanzteil eliminieren und tail auf vorletztes Teil setzen (vorletztes Teil \u00fcber headMoves + 1 erkennen) // (4) return true return false ; } public void moveUp () { move = MOVE_UP ; } public void moveDown () { move = MOVE_DOWN ; } public void moveLeft () { move = MOVE_LEFT ; } public void moveRight () { move = MOVE_RIGHT ; } }","title":"Klasse Snake"},{"location":"android/snake/#eigene-view-klasse","text":"Die Klasse SnakeView ist eine quadratische View und zeichnet das Spielfeld. Zum entsprechenden Interval wird die Methode draw aufgerufen mit dem Spielfeld aus der Klasse Snake . Innerhalb der Methode onDraw wird dann das Spielfeld auf der bereitgestellten Canvas neu gezeichnet. public class SnakeView extends View { protected Paint paintBackground ; protected Paint paintSnakeBody ; protected Paint paintSnakeHead ; protected Paint paintApple ; protected int [][] grid ; public SnakeView ( Context context , @Nullable AttributeSet attrs ) { super ( context , attrs ); // TODO: Zeichenstifte erzeugen // die 4 Zeichenstifte (Paint) sollen erzeugt werden: // Background=Gr\u00fcn, Apfel=Rot // Schlangenkopf=Dunkelgrau, Schlangenk\u00f6rper=Hellgrau } public void draw ( int [][] grid ) { this . grid = grid ; // Durch den Aufruf der Methode invalidate, wird das // Neuzeichnen der View zum n\u00e4chsten m\u00f6glichen Zeitpunk gefordert // Wann dies genau passiert wird dann vom Betriebssystem entschieden invalidate (); } @Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { // in dieser Methode wird festgelegt, dass die View immer // eine quadratische Grundfl\u00e4che hat, hier muss nichts ver\u00e4ndert werden int parentWidth = MeasureSpec . getSize ( widthMeasureSpec ); setMeasuredDimension ( parentWidth , parentWidth ); } @Override protected void onDraw ( Canvas canvas ) { // Eine invalidierte View wird nach Vorgabe vom Betriebssystem neu gezeichnet // daf\u00fcr wird die Methode onDraw aufgerufen und eine Canvas \u00fcbergeben // Das Canvas hat die Methode getWidth bzw. getHeight um die verf\u00fcgbare // Gr\u00f6\u00dfe zu errechnen, die Gr\u00f6\u00dfe einer Zelle kann dadurch errechnet werden // TODO: Spielfeld zeichnen // (1) Der Hintergrund soll als Rechteck gezeichnet werden // (2) Der Apfel als Roter Kreis // (3) Der Kopf als Dunkelgrauer Kreis // (4) Alle K\u00f6rperteile als Hellgrauer Kreis } }","title":"Eigene View Klasse"},{"location":"android/snake/#gameactivity-layout","text":"Die Klasse SnakeView kann wie folgt im XML-Layout integriert werden. Es kann an allen R\u00e4ndern eine Margin gesetzt werden. Falls der Hintergrund des Layouts Schwarz ist, entsteht der schwarze Rand um das Spielfeld (Ersichtlich im Screenshot). <fhku.snake.SnakeView android:id= \"@+id/snake_view\" android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:layout_marginStart= \"8dp\" android:layout_marginTop= \"8dp\" android:layout_marginEnd= \"8dp\" android:layout_marginBottom= \"8dp\" /> Die Buttons zur Steuerung des Spiels k\u00f6nnen als ImageButtons erzeugt werden. Die Symbole, welche sich auf den Buttons befinden wurden als Vektorgrafiken bereitgestellt. Die 4 Buttons k\u00f6nnen dabei die selbe Grafik verwenden, m\u00fcssen diese nur rotieren (Siehe Eigenschaft rotation ). Dei 4 Buttons sollen dabei innerhalb eines horizontalen LinearLayouts gesetzt werden. <ImageButton android:id= \"@+id/button_left\" android:layout_width= \"wrap_content\" android:layout_height= \"wrap_content\" android:layout_weight= \"1\" android:background= \"#00FF00\" android:rotation= \"180\" app:srcCompat= \"@drawable/button\" />","title":"GameActivity Layout"}]}