{"config":{"lang":["de"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Entwicklung und Betrieb mobiler Informationssysteme Mobile Web Entwicklung Draggable Grid FX-Calculator","title":"Home"},{"location":"#entwicklung-und-betrieb-mobiler-informationssysteme","text":"","title":"Entwicklung und Betrieb mobiler Informationssysteme"},{"location":"#mobile-web-entwicklung","text":"Draggable Grid FX-Calculator","title":"Mobile Web Entwicklung"},{"location":"android/apps-ausf%C3%BChren/","text":"Apps ausf\u00fchren Apps k\u00f6nnen am Emulator oder auf einem Android Smartphone ausgef\u00fchrt werden. Eine detailierte Dokumentation f\u00fcr die beiden Optionen findet man in der Android Dokumentation: Emulator Android Smartphone Emulator H\u00e4ufige Probleme Troubleshooting Intel\u00ae HAXM Android Smartphone Die Ausf\u00fchrung der App ist am Android Smartphone oft schneller und einfacher als am Emulator. Damit ein Smartphone zur Ausf\u00fchrung von Apps in Entwicklung verwendet werden kann, m\u00fcssen die Entwickleroptionen freigeschalten werden: Entwickleroptionen freischalten Dazu muss am Android Smartphone in Einstellungen > Telefoninfo nach der Buildnummer gesucht werden. Diese findet sich zB unter Einstellungen > Telefoninfo > Softwareinformationen . Es muss dann ca. 7-mal auf die Buildnummer geklickt werden, dann werden die Entwickleroptionen freigeschalten. USB-Debugging aktivieren Nachdem die Entwickleroptionen freigeschalten wurden, finden sich diese unter Einstellungen > Entwickleroptionen . Dort muss USB-Debugging aktiviert werden und das Smartphone muss \u00fcber USB-Kabel am Rechner angeschlossen sein.","title":"Apps ausf\u00fchren"},{"location":"android/apps-ausf%C3%BChren/#apps-ausfuhren","text":"Apps k\u00f6nnen am Emulator oder auf einem Android Smartphone ausgef\u00fchrt werden. Eine detailierte Dokumentation f\u00fcr die beiden Optionen findet man in der Android Dokumentation: Emulator Android Smartphone","title":"Apps ausf\u00fchren"},{"location":"android/apps-ausf%C3%BChren/#emulator","text":"","title":"Emulator"},{"location":"android/apps-ausf%C3%BChren/#haufige-probleme","text":"Troubleshooting Intel\u00ae HAXM","title":"H\u00e4ufige Probleme"},{"location":"android/apps-ausf%C3%BChren/#android-smartphone","text":"Die Ausf\u00fchrung der App ist am Android Smartphone oft schneller und einfacher als am Emulator. Damit ein Smartphone zur Ausf\u00fchrung von Apps in Entwicklung verwendet werden kann, m\u00fcssen die Entwickleroptionen freigeschalten werden:","title":"Android Smartphone"},{"location":"android/apps-ausf%C3%BChren/#entwickleroptionen-freischalten","text":"Dazu muss am Android Smartphone in Einstellungen > Telefoninfo nach der Buildnummer gesucht werden. Diese findet sich zB unter Einstellungen > Telefoninfo > Softwareinformationen . Es muss dann ca. 7-mal auf die Buildnummer geklickt werden, dann werden die Entwickleroptionen freigeschalten.","title":"Entwickleroptionen freischalten"},{"location":"android/apps-ausf%C3%BChren/#usb-debugging-aktivieren","text":"Nachdem die Entwickleroptionen freigeschalten wurden, finden sich diese unter Einstellungen > Entwickleroptionen . Dort muss USB-Debugging aktiviert werden und das Smartphone muss \u00fcber USB-Kabel am Rechner angeschlossen sein.","title":"USB-Debugging aktivieren"},{"location":"android/einf%C3%BChrung/","text":"Einf\u00fchrung Android Apps Android Apps werden in Java oder Kotlin programmiert. F\u00fcr spezielle hardwarenahme Teile einer App kann auch C/C++ verwendet werden (siehe Android NDK ). Eine Android App wird in eine APK-Datei ( .apk ) kompiliert, diese Datei kann dann zum Beispiel in einen Android App Market zur Ver\u00f6ffentlichung geladen werden. Android ist ein Linux-basiertes Betriebssystem. Dabei gibt es einige wichtige Sicherheitsaspekte die daraus resultieren: Jede App bekommt zum Installationszeitpunkt eine Linux User-ID zugewiesen. Nur diese User-ID hat Lese- und Schreibrechte innerhalb des App-Ordners. Jede App wird grunds\u00e4tzlich innerhalb eines eigenen Betriebssystem-Prozesses ausgef\u00fchrt. Jeder Prozess hat eine eigene Virtual Machine (Dalvik, ART), welche die App innerhalb einer Sandbox (isoliert von anderen Apps)ausf\u00fchrt. Grundstruktur einer Android App Eine Android App besteht im Wesentlichen aus 3 Bestandteilen: Jede App besitzt ein Manifest als zentrale Konfigurationsdatei in XML. Anwendungskomponenten werden als Quellcode implementiert. Apps ben\u00f6tigen auch Ressourcen, zum Beispiel: Mediendateien (Bilder, Sound, Videos, \u2026) Texte (zB f\u00fcr \u00dcbersetzung in andere Sprachen) Layout Definitionen in XML Android Apps werden in eine APK-Datei (Android Package) kompiliert. Der Quellcode wird dabei im ersten Schritt in Java-Bytecode \u00fcberf\u00fchrt und im weiteren \u00fcber einen speziellen Compiler in Dex Bytecode \u00fcberf\u00fchrt. Alle Ressourcen werden komprimiert und als .arsc Dateien in die APK verpackt. Ebenfalls wird das Manifest ( AndroidManifest.xml ) in die APK mit aufgenommen. Hinweis Das kompilierte APK kann direkt weitergegeben werden oder \u00fcber einen App Market ver\u00f6ffentlicht werden. F\u00fcr die Ver\u00f6ffentlichung muss die APK signiert werden. Kernkomponenten in Android Android Apps sind aus unterschiedlichen Kernkomponenten zusammengesetzt. Diese Kernkomponenten werden in Quellcode realisiert. Es k\u00f6nnen generell 4 Komponenten unterschieden werden: Activity: Eine Activity repr\u00e4sentiert einen \u201eScreen\u201c einer App (Darstellung und Benutzerinteraktionen). Beispiel: Eine Email Anwendung hat eine Activity , welche das Verfassen der Email abwickelt. Service: L\u00e4ngere Arbeitsschritte werden in Services ausgelagert und k\u00f6nnen so im Hintergrund ausgef\u00fchrt werden. Beispiel: Abspielen von Musik (auch wenn die App geschlossen wird). Content Provider: Verwalten globale Daten, welche f\u00fcr alle Apps relevant sind. Beispiel: Kontakte werden in einem Content Provider verwaltet. Broadcast Receiver: Ereignisse, welche Systemweit kommuniziert werden, k\u00f6nnen \u00fcber Broadcast Receiver abgefangen werden. Beispiel: Anwendungen k\u00f6nnen auf den \"Low Battery\" Event reagieren. Android Manifest Jede Android App muss ein Manifest enthalten, welches unterschiedliche Metadaten \u00fcber die App enth\u00e4lt. Das Manifest ist ein XML-Dokument im Wurzelverzeichnis der App mit Namen AndroidManifest.xml . Inhalte des Manifests sind folgende: Alle Komponenten die zur App geh\u00f6ren Definiert die \u00f6ffentlichen Interaktionsm\u00f6glichkeiten f\u00fcr andere Apps Definiert alle Berechtigungen, welche die App ben\u00f6tigt (zB Zugriff auf das Internet) Kann alle Hardware-Features definieren, welche die App ben\u00f6tigt (zB Kamera) Weitere Metadaten wie App Name, App Icon, Versionsnummer, \u2026 <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android= \"http://schemas.android.com/apk/res/android\" package= \"fhku.exampleapp\" > <uses-permission android:name= \"android.permission.INTERNET\" /> <application android:icon= \"@mipmap/ic_launcher\" android:label= \"@string/app_name\" > <activity android:name= \".MainActivity\" > <intent-filter> <action android:name= \"android.intent.action.MAIN\" /> <category android:name= \"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest> Android API Level Ein API Level klassifiziert die verf\u00fcgbaren Funktionalit\u00e4ten des Android Frameworks eindeutig. Erweiterungen der Framework API, welche durch eine neue Android Version eingef\u00fchrt werden, sind additiv (Vorw\u00e4rtskompatibel). Eine alte App (f\u00fcr alte Android Version entwickelt) funktioniert auf einer neuen Android Version. Um eine R\u00fcckw\u00e4rtskompatibilit\u00e4t sicher zu stellen, bietet Android sog. Support Libraries. Mit Support Libraries k\u00f6nnen neue Features auf alten Android Versionen hergestellt werden. Minimal, Maximal und Ziel API Level k\u00f6nnen f\u00fcr die jeweilige App innerhalb des Manifestes festgelegt werden. Support Libraries Die unterschiedlichen Android Versionen sind unterschiedlich stark verbreitet. Android Apps sind vorw\u00e4rtskompatibel. Eine App welche f\u00fcr das SDK 8.0 kompiliert wurde, funktioniert auch auf Android > 8.0 (8.1, 9.0, \u2026). Falls Features innerhalb einer Android App genutzt werden, welche zum Beispiel mit Android Version 6 eingef\u00fchrt wurden, sind diese auf Android Ger\u00e4te mit einer Version < 6 nicht nutzbar. Android Apps werden durch Support Libraries r\u00fcckw\u00e4rtskompatibel. Eine App welche mit Support Libraries entwickelt wird, kann auch auf \u00e4lteren Android Versionen ausgef\u00fchrt werden. Hierbei gibt es jedoch f\u00fcr jedes Feature auch eine untere Grenze! Wichtige UI-Konzepte Android hat einige allgemeine Bedien-Konzepte die folgend kurz zusammengefasst werden. Homescreen Der Homescreen ist von der Benutzerin anpassbar, dort finden sich App Icons bzw. App Shortcuts. Es k\u00f6nnen auch sog. App Widgets eingef\u00fcgt werden. Auch Ordner k\u00f6nnen erstellt werden zur besseren Organisation. All-Apps Screen Am All-Apps Screen finden sich alle Apps, welche am Smartphone installiert sind. System Toolbars Die Statusbar zeigt Notifications und Status Icons . Die Hauptnavigation zeigt den Zur\u00fcckbutton (siehe Activities ), den Homebutton (zum Homescreen) bzw. Recents (zum Recents-Screen) Recents Screen Am Recents-Screen werden alle aktiven Apps bzw. Tasks gezeigt. Die Liste ist sortiert nach der letzen Nutzung. Activities F\u00fcr jede eigenst\u00e4ndige Oberfl\u00e4che einer Android App wird eine eigene Activity ben\u00f6tigt. Eine App besteht meist aus vielen Activities . Als einfache Regeln gelten: Je komplexer eine App, desto mehr Activities werden ben\u00f6tigt. Jede Activity sollte eine Benutzeraktion abdecken (zB Schreiben einer Email). Eine App hat eine Start- oder Hauptactivity, welche beim Start der App (Klick auf Icon am Homescreen ) ausgef\u00fchrt wird. F\u00fcr jede Activity wird eine ContentView definiert, welche den rechteckigen Bereich am Bildschirm definiert auf dem die Oberfl\u00e4che der Activity gerendert wird. Activities k\u00f6nnen so definiert sein, dass sie nur innerhalb der App nutzbar sind. Es gibt jedoch auch Activities , welche zur Nutzung f\u00fcr andere Apps ge\u00f6ffnet sein k\u00f6nnen. Organisation als Stack Alle Activities (Ansichen oder Screens) einer App sind als Stack organisiert. Die oberste Activity im Stack befindet sich im Vordergrund und reagiert auf Benutzerinteraktionen. Beim Start einer neuen Activity wird sie oben auf den Stack gelegt (push). \u00dcber den Zur\u00fcck-Button am Smartphone/Tablet wird die oberste Activity vom Stack genommen (pop). Die Navigation \u00fcber den Zur\u00fcck-Button endet immer am Homescreen . Eine App, welche in Ausf\u00fchrung gebracht wird, wird als Task bezeichnet und findet sich im Recents-Screen . Eine App wird immer innerhalb eines eigenen Prozesses ausgef\u00fchrt. Activities einer App k\u00f6nnen auch innerhalb eines anderen Tasks (innerhalb einer anderen App) genutzt werden. Zum Beispiel stellt Android eine allgemeine Kamera App zur Verf\u00fcgung. Innerhalb einer anderen App, welche eine Kamera-Funktion ben\u00f6tigt, kann die Activity der allgemeinen Kamera App verwendet werden. Dies hat unter anderem den Vorteil, dass keine eigene Kamera Funktion implementiert werden muss. Lebenszyklus einer Activity Activities sind an einen Lebenszyklus gebunden, welcher sich anhand der Sichtbarkeit einer Activity orientiert. Folgende Lebensphasen sind dabei definiert: Aktive (vordergr\u00fcndige) Lebensphase Die Activity ist sichtbar und wartet auf Benutzereingaben. \u00dcberg\u00e4nge in und aus dieser Lebensphase k\u00f6nnen h\u00e4ufig vorkommen. Die Methoden onResume und onPause sollen daher nur sehr leichtgewichtige Verarbeitungen durchf\u00fchren. Sichtbare Lebensphase Transparente (zB unter einem Dialog) bzw. nicht aktive sichtbare Aktivit\u00e4t (zB Splitscreen) Innerhalb der Methoden onStart und onPause bearbeiten Gestoppte Lebensphase Activity bleibt unsichtbar im Stack Ressourcen sollen freigegeben werden innerhalb der Methode onStop . Zum Beispiel um Animationen zu stoppen, Sensoren freigeben oder GPS freigeben. \u00dcber die Methoden onStart bzw. onRestart k\u00f6nnen die Ressourcen wieder aktiviert werden. Intents Intents sind ein sehr wichtiges Konzept in Android. Android Apps sind grunds\u00e4tzlich nach dem Prinzip der losen Kopplung aufgebaut: Jede Komponente hat eine klare Verantwortung und ist unabh\u00e4ngig von anderen Komponenten. Komponenten kommunizieren \u00fcber wohldefinierte Schnittstellen (Intents). Komponenten werden dadurch systemweit wiederverwendbar. Activities (Fotos machen, SMS schreiben, E-Mail schreiben, Beitr\u00e4ge teilen, Telefonanruf durchf\u00fchren, Kontakt ausw\u00e4hlen) k\u00f6nnen in anderen Apps wiederverwendet werden. Komponenten k\u00f6nnen isoliert getestet werden (Unit Test). Intents werden zum Nachrichtenaustausch zwischen Komponenten verwendet. So kann eine Activity mit der Methode startActivity und als Parameter einen Intent eine neue Activity starten. Der Intent wird dabei an das Android Betriebssystem \u00fcbergeben, dieses w\u00e4hlt die passende Activity aus. Arten von Intents Es sind explizite Intents und implizite Intents in Android zu unterscheiden. Ein expliziter Intent wird verwendet um eine Komponente der eigene App zu identifizieren und zu starten. Ein impliziter Intent wird verwendet um eine Komponente einer anderen App zu identifizieren und zu starten. Ein expliziter Intent gibt dabei den FQN (Fully-Qualified Classname) der Komponente an, um diese eindeutig zu identifizieren. Im folgenden Beispiel wird innerhalb eine Activity eine andere GameActivity gestartet: Intent intent = new Intent ( this , GameActivity . class ); startActivity ( intent ); F\u00fcr implizite Intents kann kein FQN angegeben werden. Deshalb wird \u00fcber Attribute spezifiziert, welche Funktionen und Eigenschaften eine Komponente erf\u00fcllen muss. Es werden dazu unterschiedliche Attribute verwendet: Action: Eine abstrakte Beschreibung der Operation die ausgef\u00fchrt werden soll. Zum Beispiel die ACTION_DIAL um einen Anruf zu t\u00e4tigen. Data: Eine Referenz auf die Daten auf denen die Aktion ausgef\u00fchrt werden soll. Zum Beispiel kann \u00fcber eine URI ( tel:123 ) ein Kontakt angegeben werden. Der implizite Intent wird potenziell von unterschiedlichen Komponenten erf\u00fcllt. Die Auswahl f\u00fcr die entsprechende Komponente wird letztlich der Benutzerin \u00fcberlassen. Nachrichtenaustausch \u00dcber Intents k\u00f6nnen auch Schl\u00fcssel/Wert Paare von einer Komponente an eine andere \u00fcbertragen werden. Dazu werden sog. Extras verwendet. Es soll von einer Activity eine andere Activity gestartet werden. Dabei soll ein Parameter speed \u00fcbergeben wreden. Dieser Parameter steuert zum Beispiel die Geschwindigkeit innerhalb eines Spieles. Intent intent = new Intent ( this , GameActivity . class ); intent . putExtra ( \"speed\" , 350 ); startActivity ( intent ); Innerhalb des Ziels kann der Intent mit der Methode getIntent abgefragt werden. Dabei k\u00f6nnen die Extras genutzt werden. Es kann gepr\u00fcft werden, ob ein entsprechendes Extra mit dem Schl\u00fcssel existiert (Methode hasExtra ). Des Weiteren kann das Extra \u00fcber eine typisierte Methode getIntExtra abgefragt werden. Ebenfalls kann ein Default-Wert angegeben werden (hier 500 ). Intent intent = getIntent (); if ( intent . hasExtra ( \"speed\" )) { int speed = intent . getIntExtra ( \"speed\" , 500 ); } Logging Um den Zustand einer App zu \u00fcberwachen (Monitoring) oder auch zum Debugging kann unter anderem Logging verwendet werden. Eine Anwendung kann eigenst\u00e4ndige Logfiles erzeugen und Ereignisse loggen. Logeintr\u00e4ge k\u00f6nnen eine Wichtigkeit bzw. Hierarchie aufweisen (RFC 5424): VERBOSE: Lautes Logging DEBUG: Wichtige Debugging Informationen INFO: Wichtige Ereignisse der Anwendung WARN: Ein unvorhergesehenes Ereignis ERROR: Fehler in der Anwendung Die Klasse Log mit den entsprechenden statischen Logging-Funktionen kann genutzt werden um Logs zu erzeugen. Zum besseren Auffinden im gesamten Log-Stream des Android Ger\u00e4ts k\u00f6nnen sog. TAGs eingesetzt werden. \u00dcber folgende Aufrufe k\u00f6nnen die entsprechenden Logs erzeugt werden: Log . v ( \"MEINE APP\" , \"Verbose Log-Nachricht\" ); Log . d ( \"MEINE APP\" , \"Debug Log-Nachricht\" ); Log . i ( \"MEINE APP\" , \"Info Log-Nachricht\" ); Log . w ( \"MEINE APP\" , \"Warn Log-Nachricht\" ); Log . e ( \"MEINE APP\" , \"Error Log-Nachricht\" ); Log-Eintr\u00e4ge in Logcat In Android Studio k\u00f6nnen mit dem Programm Logcat die entsprechenden Log-Eintr\u00e4ge gefunden werden: Beispiel: Activity-\u00dcberg\u00e4nge loggen Weiterf\u00fchrende Details und Referenzen Application Fundamentals : Grundlagen zu Android Apps. Android Manifest Intro Activities Activity Lifecycle Tasks und Stack Intents","title":"Einf\u00fchrung"},{"location":"android/einf%C3%BChrung/#einfuhrung","text":"","title":"Einf\u00fchrung"},{"location":"android/einf%C3%BChrung/#android-apps","text":"Android Apps werden in Java oder Kotlin programmiert. F\u00fcr spezielle hardwarenahme Teile einer App kann auch C/C++ verwendet werden (siehe Android NDK ). Eine Android App wird in eine APK-Datei ( .apk ) kompiliert, diese Datei kann dann zum Beispiel in einen Android App Market zur Ver\u00f6ffentlichung geladen werden. Android ist ein Linux-basiertes Betriebssystem. Dabei gibt es einige wichtige Sicherheitsaspekte die daraus resultieren: Jede App bekommt zum Installationszeitpunkt eine Linux User-ID zugewiesen. Nur diese User-ID hat Lese- und Schreibrechte innerhalb des App-Ordners. Jede App wird grunds\u00e4tzlich innerhalb eines eigenen Betriebssystem-Prozesses ausgef\u00fchrt. Jeder Prozess hat eine eigene Virtual Machine (Dalvik, ART), welche die App innerhalb einer Sandbox (isoliert von anderen Apps)ausf\u00fchrt.","title":"Android Apps"},{"location":"android/einf%C3%BChrung/#grundstruktur-einer-android-app","text":"Eine Android App besteht im Wesentlichen aus 3 Bestandteilen: Jede App besitzt ein Manifest als zentrale Konfigurationsdatei in XML. Anwendungskomponenten werden als Quellcode implementiert. Apps ben\u00f6tigen auch Ressourcen, zum Beispiel: Mediendateien (Bilder, Sound, Videos, \u2026) Texte (zB f\u00fcr \u00dcbersetzung in andere Sprachen) Layout Definitionen in XML Android Apps werden in eine APK-Datei (Android Package) kompiliert. Der Quellcode wird dabei im ersten Schritt in Java-Bytecode \u00fcberf\u00fchrt und im weiteren \u00fcber einen speziellen Compiler in Dex Bytecode \u00fcberf\u00fchrt. Alle Ressourcen werden komprimiert und als .arsc Dateien in die APK verpackt. Ebenfalls wird das Manifest ( AndroidManifest.xml ) in die APK mit aufgenommen. Hinweis Das kompilierte APK kann direkt weitergegeben werden oder \u00fcber einen App Market ver\u00f6ffentlicht werden. F\u00fcr die Ver\u00f6ffentlichung muss die APK signiert werden.","title":"Grundstruktur einer Android App"},{"location":"android/einf%C3%BChrung/#kernkomponenten-in-android","text":"Android Apps sind aus unterschiedlichen Kernkomponenten zusammengesetzt. Diese Kernkomponenten werden in Quellcode realisiert. Es k\u00f6nnen generell 4 Komponenten unterschieden werden: Activity: Eine Activity repr\u00e4sentiert einen \u201eScreen\u201c einer App (Darstellung und Benutzerinteraktionen). Beispiel: Eine Email Anwendung hat eine Activity , welche das Verfassen der Email abwickelt. Service: L\u00e4ngere Arbeitsschritte werden in Services ausgelagert und k\u00f6nnen so im Hintergrund ausgef\u00fchrt werden. Beispiel: Abspielen von Musik (auch wenn die App geschlossen wird). Content Provider: Verwalten globale Daten, welche f\u00fcr alle Apps relevant sind. Beispiel: Kontakte werden in einem Content Provider verwaltet. Broadcast Receiver: Ereignisse, welche Systemweit kommuniziert werden, k\u00f6nnen \u00fcber Broadcast Receiver abgefangen werden. Beispiel: Anwendungen k\u00f6nnen auf den \"Low Battery\" Event reagieren.","title":"Kernkomponenten in Android"},{"location":"android/einf%C3%BChrung/#android-manifest","text":"Jede Android App muss ein Manifest enthalten, welches unterschiedliche Metadaten \u00fcber die App enth\u00e4lt. Das Manifest ist ein XML-Dokument im Wurzelverzeichnis der App mit Namen AndroidManifest.xml . Inhalte des Manifests sind folgende: Alle Komponenten die zur App geh\u00f6ren Definiert die \u00f6ffentlichen Interaktionsm\u00f6glichkeiten f\u00fcr andere Apps Definiert alle Berechtigungen, welche die App ben\u00f6tigt (zB Zugriff auf das Internet) Kann alle Hardware-Features definieren, welche die App ben\u00f6tigt (zB Kamera) Weitere Metadaten wie App Name, App Icon, Versionsnummer, \u2026 <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android= \"http://schemas.android.com/apk/res/android\" package= \"fhku.exampleapp\" > <uses-permission android:name= \"android.permission.INTERNET\" /> <application android:icon= \"@mipmap/ic_launcher\" android:label= \"@string/app_name\" > <activity android:name= \".MainActivity\" > <intent-filter> <action android:name= \"android.intent.action.MAIN\" /> <category android:name= \"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest>","title":"Android Manifest"},{"location":"android/einf%C3%BChrung/#android-api-level","text":"Ein API Level klassifiziert die verf\u00fcgbaren Funktionalit\u00e4ten des Android Frameworks eindeutig. Erweiterungen der Framework API, welche durch eine neue Android Version eingef\u00fchrt werden, sind additiv (Vorw\u00e4rtskompatibel). Eine alte App (f\u00fcr alte Android Version entwickelt) funktioniert auf einer neuen Android Version. Um eine R\u00fcckw\u00e4rtskompatibilit\u00e4t sicher zu stellen, bietet Android sog. Support Libraries. Mit Support Libraries k\u00f6nnen neue Features auf alten Android Versionen hergestellt werden. Minimal, Maximal und Ziel API Level k\u00f6nnen f\u00fcr die jeweilige App innerhalb des Manifestes festgelegt werden.","title":"Android API Level"},{"location":"android/einf%C3%BChrung/#support-libraries","text":"Die unterschiedlichen Android Versionen sind unterschiedlich stark verbreitet. Android Apps sind vorw\u00e4rtskompatibel. Eine App welche f\u00fcr das SDK 8.0 kompiliert wurde, funktioniert auch auf Android > 8.0 (8.1, 9.0, \u2026). Falls Features innerhalb einer Android App genutzt werden, welche zum Beispiel mit Android Version 6 eingef\u00fchrt wurden, sind diese auf Android Ger\u00e4te mit einer Version < 6 nicht nutzbar. Android Apps werden durch Support Libraries r\u00fcckw\u00e4rtskompatibel. Eine App welche mit Support Libraries entwickelt wird, kann auch auf \u00e4lteren Android Versionen ausgef\u00fchrt werden. Hierbei gibt es jedoch f\u00fcr jedes Feature auch eine untere Grenze!","title":"Support Libraries"},{"location":"android/einf%C3%BChrung/#wichtige-ui-konzepte","text":"Android hat einige allgemeine Bedien-Konzepte die folgend kurz zusammengefasst werden.","title":"Wichtige UI-Konzepte"},{"location":"android/einf%C3%BChrung/#homescreen","text":"Der Homescreen ist von der Benutzerin anpassbar, dort finden sich App Icons bzw. App Shortcuts. Es k\u00f6nnen auch sog. App Widgets eingef\u00fcgt werden. Auch Ordner k\u00f6nnen erstellt werden zur besseren Organisation.","title":"Homescreen"},{"location":"android/einf%C3%BChrung/#all-apps-screen","text":"Am All-Apps Screen finden sich alle Apps, welche am Smartphone installiert sind.","title":"All-Apps Screen"},{"location":"android/einf%C3%BChrung/#system-toolbars","text":"Die Statusbar zeigt Notifications und Status Icons . Die Hauptnavigation zeigt den Zur\u00fcckbutton (siehe Activities ), den Homebutton (zum Homescreen) bzw. Recents (zum Recents-Screen)","title":"System Toolbars"},{"location":"android/einf%C3%BChrung/#recents-screen","text":"Am Recents-Screen werden alle aktiven Apps bzw. Tasks gezeigt. Die Liste ist sortiert nach der letzen Nutzung.","title":"Recents Screen"},{"location":"android/einf%C3%BChrung/#activities","text":"F\u00fcr jede eigenst\u00e4ndige Oberfl\u00e4che einer Android App wird eine eigene Activity ben\u00f6tigt. Eine App besteht meist aus vielen Activities . Als einfache Regeln gelten: Je komplexer eine App, desto mehr Activities werden ben\u00f6tigt. Jede Activity sollte eine Benutzeraktion abdecken (zB Schreiben einer Email). Eine App hat eine Start- oder Hauptactivity, welche beim Start der App (Klick auf Icon am Homescreen ) ausgef\u00fchrt wird. F\u00fcr jede Activity wird eine ContentView definiert, welche den rechteckigen Bereich am Bildschirm definiert auf dem die Oberfl\u00e4che der Activity gerendert wird. Activities k\u00f6nnen so definiert sein, dass sie nur innerhalb der App nutzbar sind. Es gibt jedoch auch Activities , welche zur Nutzung f\u00fcr andere Apps ge\u00f6ffnet sein k\u00f6nnen.","title":"Activities"},{"location":"android/einf%C3%BChrung/#organisation-als-stack","text":"Alle Activities (Ansichen oder Screens) einer App sind als Stack organisiert. Die oberste Activity im Stack befindet sich im Vordergrund und reagiert auf Benutzerinteraktionen. Beim Start einer neuen Activity wird sie oben auf den Stack gelegt (push). \u00dcber den Zur\u00fcck-Button am Smartphone/Tablet wird die oberste Activity vom Stack genommen (pop). Die Navigation \u00fcber den Zur\u00fcck-Button endet immer am Homescreen . Eine App, welche in Ausf\u00fchrung gebracht wird, wird als Task bezeichnet und findet sich im Recents-Screen . Eine App wird immer innerhalb eines eigenen Prozesses ausgef\u00fchrt. Activities einer App k\u00f6nnen auch innerhalb eines anderen Tasks (innerhalb einer anderen App) genutzt werden. Zum Beispiel stellt Android eine allgemeine Kamera App zur Verf\u00fcgung. Innerhalb einer anderen App, welche eine Kamera-Funktion ben\u00f6tigt, kann die Activity der allgemeinen Kamera App verwendet werden. Dies hat unter anderem den Vorteil, dass keine eigene Kamera Funktion implementiert werden muss.","title":"Organisation als Stack"},{"location":"android/einf%C3%BChrung/#lebenszyklus-einer-activity","text":"Activities sind an einen Lebenszyklus gebunden, welcher sich anhand der Sichtbarkeit einer Activity orientiert. Folgende Lebensphasen sind dabei definiert: Aktive (vordergr\u00fcndige) Lebensphase Die Activity ist sichtbar und wartet auf Benutzereingaben. \u00dcberg\u00e4nge in und aus dieser Lebensphase k\u00f6nnen h\u00e4ufig vorkommen. Die Methoden onResume und onPause sollen daher nur sehr leichtgewichtige Verarbeitungen durchf\u00fchren. Sichtbare Lebensphase Transparente (zB unter einem Dialog) bzw. nicht aktive sichtbare Aktivit\u00e4t (zB Splitscreen) Innerhalb der Methoden onStart und onPause bearbeiten Gestoppte Lebensphase Activity bleibt unsichtbar im Stack Ressourcen sollen freigegeben werden innerhalb der Methode onStop . Zum Beispiel um Animationen zu stoppen, Sensoren freigeben oder GPS freigeben. \u00dcber die Methoden onStart bzw. onRestart k\u00f6nnen die Ressourcen wieder aktiviert werden.","title":"Lebenszyklus einer Activity"},{"location":"android/einf%C3%BChrung/#intents","text":"Intents sind ein sehr wichtiges Konzept in Android. Android Apps sind grunds\u00e4tzlich nach dem Prinzip der losen Kopplung aufgebaut: Jede Komponente hat eine klare Verantwortung und ist unabh\u00e4ngig von anderen Komponenten. Komponenten kommunizieren \u00fcber wohldefinierte Schnittstellen (Intents). Komponenten werden dadurch systemweit wiederverwendbar. Activities (Fotos machen, SMS schreiben, E-Mail schreiben, Beitr\u00e4ge teilen, Telefonanruf durchf\u00fchren, Kontakt ausw\u00e4hlen) k\u00f6nnen in anderen Apps wiederverwendet werden. Komponenten k\u00f6nnen isoliert getestet werden (Unit Test). Intents werden zum Nachrichtenaustausch zwischen Komponenten verwendet. So kann eine Activity mit der Methode startActivity und als Parameter einen Intent eine neue Activity starten. Der Intent wird dabei an das Android Betriebssystem \u00fcbergeben, dieses w\u00e4hlt die passende Activity aus.","title":"Intents"},{"location":"android/einf%C3%BChrung/#arten-von-intents","text":"Es sind explizite Intents und implizite Intents in Android zu unterscheiden. Ein expliziter Intent wird verwendet um eine Komponente der eigene App zu identifizieren und zu starten. Ein impliziter Intent wird verwendet um eine Komponente einer anderen App zu identifizieren und zu starten. Ein expliziter Intent gibt dabei den FQN (Fully-Qualified Classname) der Komponente an, um diese eindeutig zu identifizieren. Im folgenden Beispiel wird innerhalb eine Activity eine andere GameActivity gestartet: Intent intent = new Intent ( this , GameActivity . class ); startActivity ( intent ); F\u00fcr implizite Intents kann kein FQN angegeben werden. Deshalb wird \u00fcber Attribute spezifiziert, welche Funktionen und Eigenschaften eine Komponente erf\u00fcllen muss. Es werden dazu unterschiedliche Attribute verwendet: Action: Eine abstrakte Beschreibung der Operation die ausgef\u00fchrt werden soll. Zum Beispiel die ACTION_DIAL um einen Anruf zu t\u00e4tigen. Data: Eine Referenz auf die Daten auf denen die Aktion ausgef\u00fchrt werden soll. Zum Beispiel kann \u00fcber eine URI ( tel:123 ) ein Kontakt angegeben werden. Der implizite Intent wird potenziell von unterschiedlichen Komponenten erf\u00fcllt. Die Auswahl f\u00fcr die entsprechende Komponente wird letztlich der Benutzerin \u00fcberlassen.","title":"Arten von Intents"},{"location":"android/einf%C3%BChrung/#nachrichtenaustausch","text":"\u00dcber Intents k\u00f6nnen auch Schl\u00fcssel/Wert Paare von einer Komponente an eine andere \u00fcbertragen werden. Dazu werden sog. Extras verwendet. Es soll von einer Activity eine andere Activity gestartet werden. Dabei soll ein Parameter speed \u00fcbergeben wreden. Dieser Parameter steuert zum Beispiel die Geschwindigkeit innerhalb eines Spieles. Intent intent = new Intent ( this , GameActivity . class ); intent . putExtra ( \"speed\" , 350 ); startActivity ( intent ); Innerhalb des Ziels kann der Intent mit der Methode getIntent abgefragt werden. Dabei k\u00f6nnen die Extras genutzt werden. Es kann gepr\u00fcft werden, ob ein entsprechendes Extra mit dem Schl\u00fcssel existiert (Methode hasExtra ). Des Weiteren kann das Extra \u00fcber eine typisierte Methode getIntExtra abgefragt werden. Ebenfalls kann ein Default-Wert angegeben werden (hier 500 ). Intent intent = getIntent (); if ( intent . hasExtra ( \"speed\" )) { int speed = intent . getIntExtra ( \"speed\" , 500 ); }","title":"Nachrichtenaustausch"},{"location":"android/einf%C3%BChrung/#logging","text":"Um den Zustand einer App zu \u00fcberwachen (Monitoring) oder auch zum Debugging kann unter anderem Logging verwendet werden. Eine Anwendung kann eigenst\u00e4ndige Logfiles erzeugen und Ereignisse loggen. Logeintr\u00e4ge k\u00f6nnen eine Wichtigkeit bzw. Hierarchie aufweisen (RFC 5424): VERBOSE: Lautes Logging DEBUG: Wichtige Debugging Informationen INFO: Wichtige Ereignisse der Anwendung WARN: Ein unvorhergesehenes Ereignis ERROR: Fehler in der Anwendung Die Klasse Log mit den entsprechenden statischen Logging-Funktionen kann genutzt werden um Logs zu erzeugen. Zum besseren Auffinden im gesamten Log-Stream des Android Ger\u00e4ts k\u00f6nnen sog. TAGs eingesetzt werden. \u00dcber folgende Aufrufe k\u00f6nnen die entsprechenden Logs erzeugt werden: Log . v ( \"MEINE APP\" , \"Verbose Log-Nachricht\" ); Log . d ( \"MEINE APP\" , \"Debug Log-Nachricht\" ); Log . i ( \"MEINE APP\" , \"Info Log-Nachricht\" ); Log . w ( \"MEINE APP\" , \"Warn Log-Nachricht\" ); Log . e ( \"MEINE APP\" , \"Error Log-Nachricht\" );","title":"Logging"},{"location":"android/einf%C3%BChrung/#log-eintrage-in-logcat","text":"In Android Studio k\u00f6nnen mit dem Programm Logcat die entsprechenden Log-Eintr\u00e4ge gefunden werden:","title":"Log-Eintr\u00e4ge in Logcat"},{"location":"android/einf%C3%BChrung/#beispiel-activity-ubergange-loggen","text":"","title":"Beispiel: Activity-\u00dcberg\u00e4nge loggen"},{"location":"android/einf%C3%BChrung/#weiterfuhrende-details-und-referenzen","text":"Application Fundamentals : Grundlagen zu Android Apps. Android Manifest Intro Activities Activity Lifecycle Tasks und Stack Intents","title":"Weiterf\u00fchrende Details und Referenzen"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/","text":"Grafische Benutzeroberfl\u00e4che Eine grafische Benutzerschnittstelle in Android besteht aus 3 Bestandteilen: Interaktionselementen die Benutzer der App sehen und damit interagieren k\u00f6nnen. In Android sind dies alle Klassen, welche von android.view.View erben (zB Button , TextView , \u2026). Die Anordnung der Interaktionselemente (Layout) auf der jeweils verf\u00fcgbaren Bildschirmfl\u00e4che. In Android wird dies von Layout Managern \u00fcbernommen. Alle Layout Manager (zB LinearLayout , ConstraintLayout , \u2026) erben von der Klasse android.view.ViewGroup . Dabei erbt ViewGroup auch von View Mechanismen zur Erkennung und der Reaktion auf Interaktionen der Benutzer (Eventhandling). In Android werden dazu Events erzeugt und von EventListenern abgearbeitet (zB OnClickListener ). View Klassen-Hierarchie Android liefert eine umfangreiche Bibliothek an GUI-Elementen. Dabei gibt es die Klasse android.view.View , welche als Elternklasse aller Views fungiert. Neben der Klasse View gibt es die Klasse android.view.ViewGroup , welche zur Gruppierung von einzelnen Views verwendet wird. Im folgenden findet sich ein kleiner Auszug aus der Android View-Klassen Hierarchie: View Instanzen-Hierarchie F\u00fcr die Realisierung der einzelnen Sichten innerhalb einer Android App werden die entsprechenden Views instanziert und \u00fcber ViewGroups in eine Hierarchie verschachtelt. In der Benutzerschnittstelle nimmt eine Instanz der Klasse View einen rechteckigen Bereich ein. Auf diesem Bereich wird die View gezeichnet. Im Instanzen-Baum sind Views immer Blattknoten und ViewGroups bilden Teilb\u00e4ume. In der Darstellung wird eine Benutzerschnittstelle gezeigt und die zugeh\u00f6rige Hierarchie der View-Instanzen. Dabei ist ersichtlich das die ContentView das Wurzelelement ist. Jeder Activity ist eine ContentView zugeordnet, welche den gesamten rechteckigen Bereich angibt, der zur Verf\u00fcgung steht um die Benutzerschnittstelle zu realisieren. Layouts in Android Zur Anordung der Interaktionselemente auf der Benutzerschnittstelle werden Layouts verwendet. Diese k\u00f6nnen in Android entweder deklarativ durch die Definition eines XML-Dokumentes oder programmatisch \u00fcber Quellcode erstellt werden. Ebenfalls eine Kombination aus deklarativen Teilen (eher f\u00fcr statische Teile des Layouts) und programmatischen Teilen (eher f\u00fcr dynamische Teile des Layouts) ist m\u00f6glich. In Android gibt eine gro\u00dfe Anzahl unterschiedlicher Layouts. Im Prinzip sind alle Klassen, welche von ViewGroup erben als Layout nutzbar. Im Prinzip werden jedoch nur das ContraintLayout und das LinearLayout f\u00fcr die Darstellung jeglicher Layouts ben\u00f6tigt. LinearLayout Das LinearLayout ist ein sehr einfaches aber effektives Layout. Es ordnet Kindelemente entweder vertikal oder horizontal in einer Reihe an. Des weiteren gibt es die zwei Eigenschaften gravity und weight um weitere Flexibili\u00e4t in der Anordnung von Elementen zu schaffen. Deklaratives LinearLayout Beispiel Im folgenden wird ein LinearLayout definiert, welches die Kindelemente vertikal (von oben nach unten) in einer Reihe anordnet. Es ist ein horizontales Padding von 16dp links und rechts definiert. Letzlich werden die Kindelemente durch die gravity Eigenschaft mit Wert center vertikal zentriert. Bei den Kindelementen handelt es sich um 2 Buttons , welche als Text \"1 Spieler\" bzw. \"2 Spieler\" definiert haben. Sowohl f\u00fcr das LinearLayout als auch f\u00fcr die Buttons wird die Breite und H\u00f6he \u00fcber 2 spezielle Konstanten ( match_parent und wrap_content ) angegeben. Hinweis F\u00fcr jedes Element im Layout muss eine Breite und H\u00f6he angegeben werden. Dabei k\u00f6nnen dort absolute Werte spezifiziert werden (zB 16dp). Besser als absolute Werte zu nutzen ist es auf vordefinierte Konstanten match_parent und wrap_content zur\u00fcckzugreifen. match_parent errechnet dabei die Gr\u00f6\u00dfte anhand des Elternelements (Sprich: so gro\u00df wie das Elternelement). wrap_content errechnet die Gr\u00f6\u00dfe dabei anhand des Inhalts des Elements (Sprich: so gro\u00df wie n\u00f6tig, dass der Inhalt des Elements dargestellt werden kann). Weitere Details dazu finden sich in der Dokumentation . <?xml version=\"1.0\" encoding=\"utf-8\"?> <LinearLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:paddingHorizontal= \"16dp\" android:gravity= \"center\" android:orientation= \"vertical\" > <Button android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:text= \"1 Spieler\" /> <Button android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:text= \"2 Spieler\" /> </LinearLayout> In der Ansicht wird das gerenderte Layout angezeigt: ConstraintLayout Durch die Verschachtelung unterschiedlicher LinearLayouts k\u00f6nnte man viele komplexe Layouts erzeugen. Dies ist jedoch nicht performant. Mit dem ConstraintLayout k\u00f6nnen k\u00f6nnen beliebig komplexe Layouts unter Einhaltung einer flachen Hierarchie erzeugt werden. Das ConstraintLayout wird auch vom Designer in Android Studio umfassend unterst\u00fctzt. Das ConstraintLayout ist ein sehr wichtiges und n\u00fctzliches Layout f\u00fcr Android Apps, in der Lehrveranstaltung werden wir dieses jedoch nicht weiter verwenden. Eigenschaften von Views Views besitzen Eigenschaften, welche das Erscheinungsbild oder das Verhalten der View bestimmen oder ver\u00e4ndern. Eine TextView hat zum Beispiel folgende Eigenschaften: Text: Der Text der in der TextView dargestellt werden soll Width: Die Breite der TextView Height: Die H\u00f6he der TextView TextColor: Die Schriftfarbe des Textes Alle Eigenschaften k\u00f6nnen entweder programmatisch \u00fcber Getter- bzw. Setter-Methoden abgefrage und ver\u00e4ndert werden. Innerhalb eines XML-Layouts k\u00f6nnen die Eigenschaften auch deklarativ \u00fcber XML-Attribute gesetzt werden. Beispiel: Anpassung Eigenschaften In der folgenden Ansicht wird eine Benutzeroberfl\u00e4che gezeigt, welche 2 Buttons enh\u00e4lt. Der Text in den Buttons ist linksb\u00fcndig, rot, fett und kursiv. Im Beispiel werden die Eigenschaften des ersten Buttons deklarativ und die Eigenschaften des zweiten Buttons programmatisch angepasst. Im folgenden LinearLayout werden die 2 Buttons erzeugt. Zum zweiten Button werden \u00fcber XML-Attribute die Eigenschaften textAlignment , textColor und textStyle deklariert: <?xml version=\"1.0\" encoding=\"utf-8\"?> <LinearLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:orientation= \"vertical\" > <Button android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:text= \"Button programmatisch\" android:id= \"@+id/button1\" /> <Button android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:text= \"Button deklarativ\" android:textAlignment= \"textStart\" android:textColor= \"#FF0000\" android:textStyle= \"bold|italic\" /> </LinearLayout> In der zugeh\u00f6rigen Activity wird der erste Button \u00fcber die zugewiesene ID button1 mit der Methode findViewById abgefragt. Die 3 Eigenschaften werden nun am Button Objekt \u00fcber Setter zugewiesen. public class MainActivity extends AppCompatActivity { @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); Button button1 = findViewById ( R . id . button1 ); button1 . setTextColor ( Color . RED ); button1 . setTextAlignment ( View . TEXT_ALIGNMENT_TEXT_START ); button1 . setTypeface ( null , Typeface . BOLD_ITALIC ); } } Hinweis In den meisten F\u00e4llen gibt es eine 1-zu-1 \u00dcbereinstimmung der Eigenschaftsbezeichnungen im XML-Layout bzw. im Quellcode. Es gibt jedoch einige Ausnahmen davon, zum Beispiel der TextStyle im obigen Beispiel. Eventhandling Das Eventhandling in Benutzeroberfl\u00e4chen in Android Apps wird mit dem bekannten Observer Design Pattern durchgef\u00fchrt. Das Subject des Design Patterns wird von der Android View repr\u00e4sentiert. Die entsprechenden EventListener nehmen die Rolle des Observers ein. Der Abauf in Android sieht dabei folgenderma\u00dfen aus: Eine konkrete Implementierung des Observers , zum durch die Implementierung eines OnClickListener wird erstellt. Der Observer wird an einem Subject registriert (zum Beispiel an einem Button ). Im Subject wird das entsprechende Event generiert (zum Beispiel eine Benutzerin klickt auf den Button ) und alle registrierten Observer werden benachrichtigt. Die registrierten Observer arbeiten das Event ab. Umsetzung des Eventhandling in Android Innerhalb einer Activity k\u00f6nnen unterschiedliche Ans\u00e4tze verwendet werden um das Eventhandling zu implementieren. Deklarativ (eingeschr\u00e4nkt) Innerhalb des XML-Dokumentes zum Layout kann an einer View das XML-Attribut onClick mit einer Methode der Activity verkn\u00fcpft werden (Die Methode muss daf\u00fcr eine bestimmte Signatur aufweisen). Programmatisch Die Activity selbst implementiert ein entsprechendes Interface und wird somit zum EventListener . Eine eigene EventListener Klasse wird erstellt und implementiert: Dies kann als eigene Klasse (in eigener Datei) durchgef\u00fchrt werden. Dies kann auch als innere Klasse der Activity durchgef\u00fchrt werden. Eine anonyme Klasse wird einmalig erstellt (Bei der Zuweisung des EventListener ). Ein Lambda-Ausdruck wird verwendet. Deklarative Zuordnung Innerhalb der Activity gibt es eine Methode mit beliebigen Name, aber einer vorgegebenen Signatur. public class MainActivity extends AppCompatActivity { // ... public void sayHello ( View view ) { Toast . makeText ( this , \"Hello\" , Toast . LENGTH_SHORT ). show (); } } Im XML-Layout muss die entsprechende Methode an das XML-Attribut onClick als Wert \u00fcbergeben werden. Dies f\u00fchrt dazu, wenn ein Klick auf dem Button ausgef\u00fchrt wird, dass die Methode sayHello ausgef\u00fchrt wird. <Button android:id= \"@+id/button6\" android:layout_width= \"wrap_content\" android:layout_height= \"wrap_content\" android:text= \"Hello\" android:onClick= \"sayHello\" /> Hinweis Die Methode innerhalb der Activity muss folgende Signatur aufweisen: Die Methode muss public sein Die Methode muss void als R\u00fcckgabe haben Die Methode muss eine View als \u00dcbergabeparameter haben (dies ist die View welche geklickt wird) Die deklarative Zuordnung ist eine sehr einfache Methode kann aber nur f\u00fcr Klick-Events verwendet werden. Activity implementiert Interface Die Activity implementiert das entsprechende Interface des EventListeners . Dadurch wird die Activity selbst zu einem Observer . Das OnClickListener Interface spezifiziert die Methode onClick , welche zu implementieren ist. Im zweiten Schritt muss am entsprechenden Subject , hier ein Button , der EventListener zugeordnet werden. Da die Activity selbst den EventListener implementiert, wird dies durch \u00fcbergabe von this durchgef\u00fchrt. public class ExampleActivity extends Activity implements View . OnClickListener { @Override protected void onCreate ( Bundle savedValues ) { // ... Button button = findViewById ( R . id . corky ); button . setOnClickListener ( this ); } // Implementierung des OnClickListener Interface @Override public void onClick ( View v ) { // ... } } Ein Nachteil dieser Methode ist, dass eine Activity nur eine Interface eines speziellen Typs implementieren kann. Es k\u00f6nnen nich zwei unterschiedlichen OnClickListener implementiert werden. Implementierung als eigene Klasse Der entsprechende EventListener wird von einer eigene Klasse implementiert. Diese Klasse kann eine inner Klasse sein (wie im Beispiel unten) oder nat\u00fcrlich auch eine eigene Klasse innerhalb einer eigenen Datei. Die Zuweisung der EventListener funktioniert durch die Erstellung einer eigenen Instanz der Klasse. public class ExampleActivity extends Activity { public class MyClickListener implements View . OnClickListener { @Override public void onClick ( View view ) { // ... } } @Override protected void onCreate ( Bundle savedValues ) { // ... Button button = findViewById ( R . id . button ); button . setOnClickListener ( new MyClickListener ()); } } Der Vorteil dieser Variante ist, dass beliebig viele und unterschiedliche Implementierungen eines Event Typs erzeugt werden k\u00f6nnen. Die EventListener k\u00f6nnen auch in unterschiedlichen Activities wiederverwendet werden. Implementierung als Anonyme Klasse Ein EventListener kann nat\u00fcrlich auch als anonyme Klasse implementiert werden. Dabei wird die Implementierung an der Stelle durchgef\u00fchrt an der auch die Zuweisung stattfinden. public class ExampleActivity extends Activity { @Override protected void onCreate ( Bundle savedValues ) { // ... Button button = findViewById ( R . id . button ); button . setOnClickListener ( new View . OnClickListener () { public void onClick ( View v ) { // ... } }); } } Der Nachteil dieser Methode ist, dass der EventListener nur einmal verwendet werden kann. Die Lesbarkeit von anonymen Klassen ist ebenfalls eingeschr\u00e4nkt. Implementierung durch Lambda Ausdr\u00fccke Lambdas wurden mit Java 8 eingef\u00fchrt und sind auch in Android nutzbar. Lambdas sind Funktionen ohne Klassenkontext (Funktion steht f\u00fcr sich alleine) ohne innerhalb einer Klasse eingebettet zu sein. Lambdas k\u00f6nnen dabei wie Objekte genutzt werden (zB \u00dcbergabe als Parameter an andere Funktionen) und nach belieben ausgef\u00fchrt werden. Ein Lambda Ausdruck hat folgende Struktur: parameter -> expression Hinweis Syntaktische Besonderheiten von Lambdas in Java: Optionale Typ-Deklaration Optionale Klammern bei einem Parameter Optionale Klammern um Body, wenn nur ein Statement vorhanden ist Optionales return-Schl\u00fcsselwort bei ungeklammertem Body Lambdase k\u00f6nnen als Alternative zu anonymen Klassen verwendet werden. Die Lesbarkeit wird dadurch etwas erh\u00f6ht: public class ExampleActivity extends Activity { @Override protected void onCreate ( Bundle savedValues ) { // ... Button button = findViewById ( R . id . button ); button . setOnClickListener (( View view ) -> { /* ... */ }); } } Referenzen Layouts LinearLayout : Wichtige Details zum LinearLayout . ConstraintLayout : Wichtige Details zum ConstraintLayout .","title":"Grafische Benutzeroberfl\u00e4che"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#grafische-benutzeroberflache","text":"Eine grafische Benutzerschnittstelle in Android besteht aus 3 Bestandteilen: Interaktionselementen die Benutzer der App sehen und damit interagieren k\u00f6nnen. In Android sind dies alle Klassen, welche von android.view.View erben (zB Button , TextView , \u2026). Die Anordnung der Interaktionselemente (Layout) auf der jeweils verf\u00fcgbaren Bildschirmfl\u00e4che. In Android wird dies von Layout Managern \u00fcbernommen. Alle Layout Manager (zB LinearLayout , ConstraintLayout , \u2026) erben von der Klasse android.view.ViewGroup . Dabei erbt ViewGroup auch von View Mechanismen zur Erkennung und der Reaktion auf Interaktionen der Benutzer (Eventhandling). In Android werden dazu Events erzeugt und von EventListenern abgearbeitet (zB OnClickListener ).","title":"Grafische Benutzeroberfl\u00e4che"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#view-klassen-hierarchie","text":"Android liefert eine umfangreiche Bibliothek an GUI-Elementen. Dabei gibt es die Klasse android.view.View , welche als Elternklasse aller Views fungiert. Neben der Klasse View gibt es die Klasse android.view.ViewGroup , welche zur Gruppierung von einzelnen Views verwendet wird. Im folgenden findet sich ein kleiner Auszug aus der Android View-Klassen Hierarchie:","title":"View Klassen-Hierarchie"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#view-instanzen-hierarchie","text":"F\u00fcr die Realisierung der einzelnen Sichten innerhalb einer Android App werden die entsprechenden Views instanziert und \u00fcber ViewGroups in eine Hierarchie verschachtelt. In der Benutzerschnittstelle nimmt eine Instanz der Klasse View einen rechteckigen Bereich ein. Auf diesem Bereich wird die View gezeichnet. Im Instanzen-Baum sind Views immer Blattknoten und ViewGroups bilden Teilb\u00e4ume. In der Darstellung wird eine Benutzerschnittstelle gezeigt und die zugeh\u00f6rige Hierarchie der View-Instanzen. Dabei ist ersichtlich das die ContentView das Wurzelelement ist. Jeder Activity ist eine ContentView zugeordnet, welche den gesamten rechteckigen Bereich angibt, der zur Verf\u00fcgung steht um die Benutzerschnittstelle zu realisieren.","title":"View Instanzen-Hierarchie"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#layouts-in-android","text":"Zur Anordung der Interaktionselemente auf der Benutzerschnittstelle werden Layouts verwendet. Diese k\u00f6nnen in Android entweder deklarativ durch die Definition eines XML-Dokumentes oder programmatisch \u00fcber Quellcode erstellt werden. Ebenfalls eine Kombination aus deklarativen Teilen (eher f\u00fcr statische Teile des Layouts) und programmatischen Teilen (eher f\u00fcr dynamische Teile des Layouts) ist m\u00f6glich. In Android gibt eine gro\u00dfe Anzahl unterschiedlicher Layouts. Im Prinzip sind alle Klassen, welche von ViewGroup erben als Layout nutzbar. Im Prinzip werden jedoch nur das ContraintLayout und das LinearLayout f\u00fcr die Darstellung jeglicher Layouts ben\u00f6tigt.","title":"Layouts in Android"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#linearlayout","text":"Das LinearLayout ist ein sehr einfaches aber effektives Layout. Es ordnet Kindelemente entweder vertikal oder horizontal in einer Reihe an. Des weiteren gibt es die zwei Eigenschaften gravity und weight um weitere Flexibili\u00e4t in der Anordnung von Elementen zu schaffen.","title":"LinearLayout"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#deklaratives-linearlayout-beispiel","text":"Im folgenden wird ein LinearLayout definiert, welches die Kindelemente vertikal (von oben nach unten) in einer Reihe anordnet. Es ist ein horizontales Padding von 16dp links und rechts definiert. Letzlich werden die Kindelemente durch die gravity Eigenschaft mit Wert center vertikal zentriert. Bei den Kindelementen handelt es sich um 2 Buttons , welche als Text \"1 Spieler\" bzw. \"2 Spieler\" definiert haben. Sowohl f\u00fcr das LinearLayout als auch f\u00fcr die Buttons wird die Breite und H\u00f6he \u00fcber 2 spezielle Konstanten ( match_parent und wrap_content ) angegeben. Hinweis F\u00fcr jedes Element im Layout muss eine Breite und H\u00f6he angegeben werden. Dabei k\u00f6nnen dort absolute Werte spezifiziert werden (zB 16dp). Besser als absolute Werte zu nutzen ist es auf vordefinierte Konstanten match_parent und wrap_content zur\u00fcckzugreifen. match_parent errechnet dabei die Gr\u00f6\u00dfte anhand des Elternelements (Sprich: so gro\u00df wie das Elternelement). wrap_content errechnet die Gr\u00f6\u00dfe dabei anhand des Inhalts des Elements (Sprich: so gro\u00df wie n\u00f6tig, dass der Inhalt des Elements dargestellt werden kann). Weitere Details dazu finden sich in der Dokumentation . <?xml version=\"1.0\" encoding=\"utf-8\"?> <LinearLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:paddingHorizontal= \"16dp\" android:gravity= \"center\" android:orientation= \"vertical\" > <Button android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:text= \"1 Spieler\" /> <Button android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:text= \"2 Spieler\" /> </LinearLayout> In der Ansicht wird das gerenderte Layout angezeigt:","title":"Deklaratives LinearLayout Beispiel"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#constraintlayout","text":"Durch die Verschachtelung unterschiedlicher LinearLayouts k\u00f6nnte man viele komplexe Layouts erzeugen. Dies ist jedoch nicht performant. Mit dem ConstraintLayout k\u00f6nnen k\u00f6nnen beliebig komplexe Layouts unter Einhaltung einer flachen Hierarchie erzeugt werden. Das ConstraintLayout wird auch vom Designer in Android Studio umfassend unterst\u00fctzt. Das ConstraintLayout ist ein sehr wichtiges und n\u00fctzliches Layout f\u00fcr Android Apps, in der Lehrveranstaltung werden wir dieses jedoch nicht weiter verwenden.","title":"ConstraintLayout"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#eigenschaften-von-views","text":"Views besitzen Eigenschaften, welche das Erscheinungsbild oder das Verhalten der View bestimmen oder ver\u00e4ndern. Eine TextView hat zum Beispiel folgende Eigenschaften: Text: Der Text der in der TextView dargestellt werden soll Width: Die Breite der TextView Height: Die H\u00f6he der TextView TextColor: Die Schriftfarbe des Textes Alle Eigenschaften k\u00f6nnen entweder programmatisch \u00fcber Getter- bzw. Setter-Methoden abgefrage und ver\u00e4ndert werden. Innerhalb eines XML-Layouts k\u00f6nnen die Eigenschaften auch deklarativ \u00fcber XML-Attribute gesetzt werden.","title":"Eigenschaften von Views"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#beispiel-anpassung-eigenschaften","text":"In der folgenden Ansicht wird eine Benutzeroberfl\u00e4che gezeigt, welche 2 Buttons enh\u00e4lt. Der Text in den Buttons ist linksb\u00fcndig, rot, fett und kursiv. Im Beispiel werden die Eigenschaften des ersten Buttons deklarativ und die Eigenschaften des zweiten Buttons programmatisch angepasst. Im folgenden LinearLayout werden die 2 Buttons erzeugt. Zum zweiten Button werden \u00fcber XML-Attribute die Eigenschaften textAlignment , textColor und textStyle deklariert: <?xml version=\"1.0\" encoding=\"utf-8\"?> <LinearLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:orientation= \"vertical\" > <Button android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:text= \"Button programmatisch\" android:id= \"@+id/button1\" /> <Button android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:text= \"Button deklarativ\" android:textAlignment= \"textStart\" android:textColor= \"#FF0000\" android:textStyle= \"bold|italic\" /> </LinearLayout> In der zugeh\u00f6rigen Activity wird der erste Button \u00fcber die zugewiesene ID button1 mit der Methode findViewById abgefragt. Die 3 Eigenschaften werden nun am Button Objekt \u00fcber Setter zugewiesen. public class MainActivity extends AppCompatActivity { @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); Button button1 = findViewById ( R . id . button1 ); button1 . setTextColor ( Color . RED ); button1 . setTextAlignment ( View . TEXT_ALIGNMENT_TEXT_START ); button1 . setTypeface ( null , Typeface . BOLD_ITALIC ); } } Hinweis In den meisten F\u00e4llen gibt es eine 1-zu-1 \u00dcbereinstimmung der Eigenschaftsbezeichnungen im XML-Layout bzw. im Quellcode. Es gibt jedoch einige Ausnahmen davon, zum Beispiel der TextStyle im obigen Beispiel.","title":"Beispiel: Anpassung Eigenschaften"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#eventhandling","text":"Das Eventhandling in Benutzeroberfl\u00e4chen in Android Apps wird mit dem bekannten Observer Design Pattern durchgef\u00fchrt. Das Subject des Design Patterns wird von der Android View repr\u00e4sentiert. Die entsprechenden EventListener nehmen die Rolle des Observers ein. Der Abauf in Android sieht dabei folgenderma\u00dfen aus: Eine konkrete Implementierung des Observers , zum durch die Implementierung eines OnClickListener wird erstellt. Der Observer wird an einem Subject registriert (zum Beispiel an einem Button ). Im Subject wird das entsprechende Event generiert (zum Beispiel eine Benutzerin klickt auf den Button ) und alle registrierten Observer werden benachrichtigt. Die registrierten Observer arbeiten das Event ab.","title":"Eventhandling"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#umsetzung-des-eventhandling-in-android","text":"Innerhalb einer Activity k\u00f6nnen unterschiedliche Ans\u00e4tze verwendet werden um das Eventhandling zu implementieren. Deklarativ (eingeschr\u00e4nkt) Innerhalb des XML-Dokumentes zum Layout kann an einer View das XML-Attribut onClick mit einer Methode der Activity verkn\u00fcpft werden (Die Methode muss daf\u00fcr eine bestimmte Signatur aufweisen). Programmatisch Die Activity selbst implementiert ein entsprechendes Interface und wird somit zum EventListener . Eine eigene EventListener Klasse wird erstellt und implementiert: Dies kann als eigene Klasse (in eigener Datei) durchgef\u00fchrt werden. Dies kann auch als innere Klasse der Activity durchgef\u00fchrt werden. Eine anonyme Klasse wird einmalig erstellt (Bei der Zuweisung des EventListener ). Ein Lambda-Ausdruck wird verwendet.","title":"Umsetzung des Eventhandling in Android"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#deklarative-zuordnung","text":"Innerhalb der Activity gibt es eine Methode mit beliebigen Name, aber einer vorgegebenen Signatur. public class MainActivity extends AppCompatActivity { // ... public void sayHello ( View view ) { Toast . makeText ( this , \"Hello\" , Toast . LENGTH_SHORT ). show (); } } Im XML-Layout muss die entsprechende Methode an das XML-Attribut onClick als Wert \u00fcbergeben werden. Dies f\u00fchrt dazu, wenn ein Klick auf dem Button ausgef\u00fchrt wird, dass die Methode sayHello ausgef\u00fchrt wird. <Button android:id= \"@+id/button6\" android:layout_width= \"wrap_content\" android:layout_height= \"wrap_content\" android:text= \"Hello\" android:onClick= \"sayHello\" /> Hinweis Die Methode innerhalb der Activity muss folgende Signatur aufweisen: Die Methode muss public sein Die Methode muss void als R\u00fcckgabe haben Die Methode muss eine View als \u00dcbergabeparameter haben (dies ist die View welche geklickt wird) Die deklarative Zuordnung ist eine sehr einfache Methode kann aber nur f\u00fcr Klick-Events verwendet werden.","title":"Deklarative Zuordnung"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#activity-implementiert-interface","text":"Die Activity implementiert das entsprechende Interface des EventListeners . Dadurch wird die Activity selbst zu einem Observer . Das OnClickListener Interface spezifiziert die Methode onClick , welche zu implementieren ist. Im zweiten Schritt muss am entsprechenden Subject , hier ein Button , der EventListener zugeordnet werden. Da die Activity selbst den EventListener implementiert, wird dies durch \u00fcbergabe von this durchgef\u00fchrt. public class ExampleActivity extends Activity implements View . OnClickListener { @Override protected void onCreate ( Bundle savedValues ) { // ... Button button = findViewById ( R . id . corky ); button . setOnClickListener ( this ); } // Implementierung des OnClickListener Interface @Override public void onClick ( View v ) { // ... } } Ein Nachteil dieser Methode ist, dass eine Activity nur eine Interface eines speziellen Typs implementieren kann. Es k\u00f6nnen nich zwei unterschiedlichen OnClickListener implementiert werden.","title":"Activity implementiert Interface"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#implementierung-als-eigene-klasse","text":"Der entsprechende EventListener wird von einer eigene Klasse implementiert. Diese Klasse kann eine inner Klasse sein (wie im Beispiel unten) oder nat\u00fcrlich auch eine eigene Klasse innerhalb einer eigenen Datei. Die Zuweisung der EventListener funktioniert durch die Erstellung einer eigenen Instanz der Klasse. public class ExampleActivity extends Activity { public class MyClickListener implements View . OnClickListener { @Override public void onClick ( View view ) { // ... } } @Override protected void onCreate ( Bundle savedValues ) { // ... Button button = findViewById ( R . id . button ); button . setOnClickListener ( new MyClickListener ()); } } Der Vorteil dieser Variante ist, dass beliebig viele und unterschiedliche Implementierungen eines Event Typs erzeugt werden k\u00f6nnen. Die EventListener k\u00f6nnen auch in unterschiedlichen Activities wiederverwendet werden.","title":"Implementierung als eigene Klasse"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#implementierung-als-anonyme-klasse","text":"Ein EventListener kann nat\u00fcrlich auch als anonyme Klasse implementiert werden. Dabei wird die Implementierung an der Stelle durchgef\u00fchrt an der auch die Zuweisung stattfinden. public class ExampleActivity extends Activity { @Override protected void onCreate ( Bundle savedValues ) { // ... Button button = findViewById ( R . id . button ); button . setOnClickListener ( new View . OnClickListener () { public void onClick ( View v ) { // ... } }); } } Der Nachteil dieser Methode ist, dass der EventListener nur einmal verwendet werden kann. Die Lesbarkeit von anonymen Klassen ist ebenfalls eingeschr\u00e4nkt.","title":"Implementierung als Anonyme Klasse"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#implementierung-durch-lambda-ausdrucke","text":"Lambdas wurden mit Java 8 eingef\u00fchrt und sind auch in Android nutzbar. Lambdas sind Funktionen ohne Klassenkontext (Funktion steht f\u00fcr sich alleine) ohne innerhalb einer Klasse eingebettet zu sein. Lambdas k\u00f6nnen dabei wie Objekte genutzt werden (zB \u00dcbergabe als Parameter an andere Funktionen) und nach belieben ausgef\u00fchrt werden. Ein Lambda Ausdruck hat folgende Struktur: parameter -> expression Hinweis Syntaktische Besonderheiten von Lambdas in Java: Optionale Typ-Deklaration Optionale Klammern bei einem Parameter Optionale Klammern um Body, wenn nur ein Statement vorhanden ist Optionales return-Schl\u00fcsselwort bei ungeklammertem Body Lambdase k\u00f6nnen als Alternative zu anonymen Klassen verwendet werden. Die Lesbarkeit wird dadurch etwas erh\u00f6ht: public class ExampleActivity extends Activity { @Override protected void onCreate ( Bundle savedValues ) { // ... Button button = findViewById ( R . id . button ); button . setOnClickListener (( View view ) -> { /* ... */ }); } }","title":"Implementierung durch Lambda Ausdr\u00fccke"},{"location":"android/grafische-benutzeroberfl%C3%A4chen/#referenzen","text":"Layouts LinearLayout : Wichtige Details zum LinearLayout . ConstraintLayout : Wichtige Details zum ConstraintLayout .","title":"Referenzen"},{"location":"android/sixteen-buttons/","text":"Sixteen Buttons Neues Projekt erstellen \u00dcber den Projekt-Wizard wird man durch den Erstellungsprozess geleitet. Neues Projekt Nachdem ersten Start von Android Studio ist die Ansicht, wie unten im Screenshot dargestellt, vorhanden. Dabei kann \u00fcber Klick auf + Start a new Android Studio project ein neues Projekt erstellt werden. Alternativ kann \u00fcber die ge\u00f6ffnete Android Studio Projektansicht \u00fcber das Men\u00fc File > New > New Project... ein neues Projekt erstellt werden. Erste Activity w\u00e4hlen Ein Android Projekt besteht normalerweise zumindest aus einer Activity. Ein gro\u00dfes Android Projekt kann durchaus \u00fcber Hundert Activities umfassen. F\u00fcr ein neues Projekt kann aus ein Templates f\u00fcr die erste Activity gew\u00e4hlt werden. F\u00fcr das Projekt Sixteen Buttons nutzen wird das Template Empty Activity . Projektkonfiguration Im letzten Schritt des Projekt-Wizard werden wichtige Daten zum Projekt festgelegt. All diese Daten k\u00f6nnen grunds\u00e4tzlich sp\u00e4ter noch ver\u00e4ndert werden, dies ist dann aber teilweise mit aufw\u00e4ndigen Refactoring verbunden. Folgende Parameter k\u00f6nnen festgelegt werden: Name: Der Name wird an allen wichtigen Stellen im Android Betriebssystem f\u00fcr die App angezeigt (zB am All-Apps Screen oder am Recents Screen). Package name: Alle Klassen des Projektes werden mit diesem Package Name versehen. Save location: An dieser Stelle wird das Projekt am Dateisystem gespeichert. Language: Native Android Apps k\u00f6nnen grunds\u00e4tzlich in Java oder Kotlin entwickelt werden. Minimum SDK: F\u00fcr Android wird zumindest j\u00e4hrlich eine neue Version (inkl. SDK) ver\u00f6ffentlicht. Die Auswahl h\u00e4ngt davon ab, welche \u00e4lteren Android Versionen von der App noch unterst\u00fctzt werden sollen. W\u00e4hlen Sie die Parameter entsprechend des Screenshots (die Save location ist frei w\u00e4hlbar) und klicken Sie auf Finish . Layout editieren In der Datei res/layout/activity_main.xml findet sich das entsprechende Layout, welches f\u00fcr die Activity geladen wird. Hinweis In der Klasse MainActivity findet man innerhalb der Methode onCreate das Layout, welches der Activity zugeordnet wurde. Mit der Methode setContentView wird \u00fcber die entsprechende Konstante R.layout.activity_main das Layout im Ordner res/layout/activity_main.xml referenziert und dadurch f\u00fcr die Activity festgelegt. Hier k\u00f6nnte jedes beliebige verf\u00fcgbare Layout zugeordnet werden. Layouts werden als XML-Dokumente beschrieben. Ein Layout kann in Android Studio direkt als XML-Dokument \u00fcber die Code-Ansicht oder \u00fcber einen WYSIWYG-Editor in der Design-Ansicht editiert werden. Die Design-Ansicht bietet dabei bereits eine gerenderte Darstellung des XML-Dokumentes. \u00c4nderungen in der Design Ansicht f\u00fchren aber immer zu \u00c4nderungen im XML. Vorerst arbeiten wir nur mit der Code-Ansicht, kopieren Sie dazu den folgenden Code-Auschnitt in den Code-Editor. Der bestehende Inhalt soll dabei gel\u00f6scht werden. <?xml version=\"1.0\" encoding=\"utf-8\"?> <ScrollView xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" xmlns:tools= \"http://schemas.android.com/tools\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" tools:context= \".MainActivity\" > <LinearLayout android:id= \"@+id/button_layout\" android:orientation= \"vertical\" android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" > </LinearLayout> </ScrollView> Im Layout ist das Wurzelelment eine ScrollView . Die ScrollView erzeugt die M\u00f6glichkeit des Scrollens der Kindelemente, welche nicht vollkommen auf dem Bildschirm Platz haben. Innherhalb der ScrollView befindet sich ein LinearLayout . Das LinearLayout erm\u00f6glicht es Kindelemente entweder vertikal oder horizontal in einer Reihe anzuordnen (siehe Attribut android:orientation ). Hinweis Das LinearLayout hat eine android:id als Attribut gesetzt. IDs sind sehr wichtig, da im Quellcode Elemente aus dem Layout \u00fcber die ID referenziert werden k\u00f6nnen. Als Wert f\u00fcr IDs wird eine spezielle Syntax verwendet @+id/beliebiger_name . Mit @+id wird dabei definiert, dass in der Klasse R eine neue ID-Konstante erzeugt werden soll. F\u00fcr den Bezeichner der ID kann ein beliebiger_name festgelegt werden. In der Klasse R wird die ID wie folgt als Konstante erzeugt: R.id.beliebiger_name . Weitere Details dazu finden sich in der Dokumentation . 16 Buttons hinzuf\u00fcgen Das Layout einer Activity kann einerseit deklarativ \u00fcber XML definiert werden. Andererseits k\u00f6nnen aber auch dynamische \u00c4nderungen im Layout zur Laufzeit im Quellcode (programmatisch) durchgef\u00fchrt werden. Im folgenden sollen 16 Buttons innerhalb des LinearLayout hinzugef\u00fcgt werden. Innerhalb der Methode onCreate der Klasse MainActivity soll nun das deklarierte LinearLayout im Quellcode referenzirt werden. Dazu ist die Methode findViewById innerhalb der Activity definiert. Durch \u00fcbergabe einer ID kann das entsprechende Element des Layouts abgefragt werden: LinearLayout linearLayout = findViewById ( R . id . button_layout ); Hinweis Alle Layouts erben von der Klasse ViewGroup . Dies ist eine Klasse die das Verwalten von Kindelementen erm\u00f6glicht. Kindelemente einer ViewGroup k\u00f6nnen entweder Views oder wiederum ViewGroups (f\u00fcr verschachtelte Layouts) sein. Eine ViewGroup definiert dabei wichtige Methoden zur Verwaltung von Kindelementen. Die Methode addView erm\u00f6glicht es Kindelemente hinzuzuf\u00fcgen. Die Methode getChildCount gibt die Anzahl der verwalteten Kindelemente zur\u00fcck und die Methode getChildAt liefert eine Referenz auf ein Kindelement durch die Angabe eines Index (\u00e4hnlich zum Zugriff auf ein Array). Innerhalb einer Schleife sollen dann 16 Buttons \u00fcber die Methode addView an das LinearLayout hinzugef\u00fcgt werden. Jede View (wie zum Beispiel der Button ) bekommt eine Referenz auf die Activity in der sie ausgef\u00fchrt wird, \u00fcber den Konstruktur, \u00fcbergeben. Ein Button besitzt unter anderem die Eigenschaft Text, welche \u00fcber den Setter setText angegeben wird. for ( int i = 0 ; i < 16 ; i ++ ) { Button button = new Button ( this ); button . setText ( \"Button \" + ( i + 1 )); linearLayout . addView ( buttons [ i ] ); } Hinweis Alle Views besitzen Eigenschaften. Diese Eigenschaften k\u00f6nnen entweder deklarativ \u00fcber XML-Attribute im Layout oder programmatisch \u00fcber Setter im Quellcode definiert werden. In den meisten F\u00e4llen gibt es eine 1-zu-1 \u00dcbereinstimmung zwischen Eigentschaften im XML-Layout und \u00fcber Setter der View (leider nicht \u00fcberall). Eigenschaften k\u00f6nnen an der View auch \u00fcber Getter abgefragt werden. Ein Starten der App sollte ein \u00c4hnliches Bild wie der angef\u00fchrte Screenshot liefern. Wichtig ist dabei auch, dass man vertikal Scrollen kann (dies wird durch die ScrollView erm\u00f6glicht). Der gesamte Inhalt der Methode onCreate sollte nun folgenderma\u00dfen aussehen: @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); LinearLayout linearLayout = findViewById ( R . id . button_layout ); for ( int i = 0 ; i < 16 ; i ++ ) { Button button = new Button ( this ); button . setText ( \"Button \" + ( i + 1 )); linearLayout . addView ( buttons [ i ] ); } } Klick Listener hinzuf\u00fcgen Grafische Benutzeroberfl\u00e4chen sollen auf Aktionen von Benutzerinnen reagieren. F\u00fcr eine View in der Oberfl\u00e4che kann f\u00fcr definierte Events (wie zB einen Klick) ein EventListener angeben werden. Immmer wenn das entsprechende Event eintritt wird der zugeordnete EventListener ausgef\u00fchrt. Die unterschiedlichen EventListener sind als Java-Interfaces definiert. Eine einfache M\u00f6glichkeit, um einen entsprechenden EventListener zu implementieren, ist es diesen direkt \u00fcber die Activity zu implementieren. Die MainActivity im Projekt sollte so erweitert werden, dass der OnClickListener , welcher als inneres Interface der Klasse View definiert ist, implementiert wird. Nachdem hinzuf\u00fcgen des implements View.OnClickListener wird von der Klasse MainActivity gefordert, dass das entsprechende Interface implementiert wird. Deshalb muss die Methode onClick mit der definierten Methoden-Signatur hinzugef\u00fcgt werden. Hinweis Android Studio generiert alle Methoden, welche von einem Interface definiert sind. Daf\u00fcr kann das Symbol \"rote Gl\u00fchbirne\" f\u00fcr vorschl\u00e4ge geklickt werden. Dies tritt immer dort auf, wo aktuell ein Fehler von der IDE entdeckt wurde. Falls die \"rote Gl\u00fchbirne\" nicht sichtbar ist, aber ein Fehler vorherrscht, k\u00f6nnen durch die Tastenkombination ALT+Enter die selben Vorschl\u00e4ge generiert werden. Der Cursor muss sich daf\u00fcr in der Zeile mit dem Fehler befinden. public class MainActivity extends AppCompatActivity implements View . OnClickListener { // ... @Override public void onClick ( View v ) { // ... } } Die Methode onClick bekommt dabei eine View als Parameter \u00fcbergeben. Diese View repr\u00e4sentiert genau das Element der Benutzeroberfl\u00e4che, auf welches geklickt wurde. Damit das Event-Handling auch funktioniert, m\u00fcssen die Buttons mit dem implementierten EventListener verkn\u00fcpft werden. F\u00fcr jeden Button, der in der Schleife erzeugt wird, muss dies durchgef\u00fchrt werden: button . setOnClickListener ( this ); Damit irgendetwas passiert nachdem Klick auf den Button, muss auch in der Methode onClick etwas ausgef\u00fchrt werden. Dazu soll ein Toast erzeugt werden, welcher eine kurze Nachricht am Bildschirm einblendet. Da bekannt ist, dass die \u00fcbergebene View ein Button ist, kann auch ein entsprechenden Casting mit (Button) durchgef\u00fchrt werden. @Override public void onClick ( View v ) { Button button = ( Button ) v ; Toast toast = Toast . makeText ( this , \"Klick auf \" + button . getText (), Toast . LENGTH_SHORT ); toast . show (); } Durch Klicken auf Button 6 sollte folgende Darstellung erzeugt werden: Zuf\u00e4lligen Button ausw\u00e4hlen Um das Spiel zu realisieren, sollte ein zuf\u00e4lliger Button ausgew\u00e4hlt werden und bei diesem soll die Schriftfarbe auf Rot gesetzt werden. Dazu sollen im ersten Schritt ein LinearLayout als Eigenschaft der Klasse definiert werden. Mit der Methode findViewById soll entsprechend diese Klasseneigenschaft setzen: public class MainActivity extends AppCompatActivity implements View . OnClickListener { // ... protected LinearLayout linearLayout ; @Override protected void onCreate ( Bundle savedInstanceState ) { // ... linearLayout = findViewById ( R . id . button_layout ); // ... } // ... Zur Auswahl eines zuf\u00e4lligen Buttons muss eine Zufallszahl zwischen 0 und 15 erzeugt werden. Mit der Methode getChildAt des LinearLayout Objektes kann \u00fcber den Index eine View abgefragt werden. Da wir wissen, dass jede View ein Button ist, k\u00f6nnen wir auch das entsprechend casten mit (Button) . Die Farbe des Textes im Button wird dann auf Rot gesetzt. public void selectRandomButton () { int random = ( int ) Math . floor ( Math . random () * linearLayout . getChildCount ()); Button button = ( Button ) linearLayout . getChildAt ( random ); button . setTextColor ( Color . RED ); } Die Methode selectRandomButton sollte dann als letztes in der Methode onCreate aufgerufen werden. Klick pr\u00fcfen F\u00fcr jeden Klick soll nun gepr\u00fcft werden, ob auf einen Button mit rotem Text gedr\u00fcckt wurde. Falls auf einen Button mit rotem Text geklickt wurde, soll der Text wieder auf Schwarz gesetzt werden und ein anderer zuf\u00e4lliger Button soll wieder Rot gef\u00e4rbt werden. Die Schriftfrabe des Buttons kann \u00fcber die Methode getTextColors abgefragt werden. Als R\u00fcckgabewert dieses Getter wird ein Objekt vom ColorStateList zur\u00fcckgegeben. Da ein Button f\u00fcr unterschiedliche Zust\u00e4nde (zB Enabled/Disabled, Gedr\u00fcckt, ...) eine andere Farbe definiert haben kann, wird eben eine ColorSateList verwendet. Dabei kann die Methode getDefaultColor der ColorStateList verwendet werden, um die Schriftfarbe im \"Normalzustand\" des Buttons abzufragen. Im Falle einer \u00dcbereinstimmung mit der Farbe Rot ( Color.RED ) soll eben die Farbe auf Schwarz ( Color.BLACK ) gesetzt ewrden. Des Weiteren soll ein weiterer zuf\u00e4lliger Button Rot eingef\u00e4rbt werden ( selectRandomButton ). @Override public void onClick ( View v ) { Button button = ( Button ) v ; int color = button . getTextColors (). getDefaultColor (); if ( color == Color . RED ) { button . setTextColor ( Color . BLACK ); selectRandomButton (); } } Im folgenden Screenshot wird ein zuf\u00e4llig Rot gef\u00e4rbter Button angezeigt: Gesamter Quellcode activity_main.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <ScrollView xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" xmlns:tools= \"http://schemas.android.com/tools\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" tools:context= \".MainActivity\" > <LinearLayout android:id= \"@+id/button_layout\" android:orientation= \"vertical\" android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" > </LinearLayout> </ScrollView> MainActivity package fhku.sixteenbuttons ; import androidx.appcompat.app.AppCompatActivity ; import android.graphics.Color ; import android.os.Bundle ; import android.view.View ; import android.widget.Button ; import android.widget.LinearLayout ; import android.widget.Toast ; public class MainActivity extends AppCompatActivity implements View . OnClickListener { protected LinearLayout linearLayout ; @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); linearLayout = findViewById ( R . id . button_layout ); for ( int i = 0 ; i < 16 ; i ++ ) { Button button = new Button ( this ); button . setText ( \"Button \" + ( i + 1 )); button . setOnClickListener ( this ); linearLayout . addView ( button ); } selectRandomButton (); } @Override public void onClick ( View v ) { Button button = ( Button ) v ; int color = button . getTextColors (). getDefaultColor (); if ( color == Color . RED ) { button . setTextColor ( Color . BLACK ); selectRandomButton (); } // Toast toast = Toast.makeText(this, \"Klick auf \" + button.getText(), Toast.LENGTH_SHORT); // toast.show(); } public void selectRandomButton () { int random = ( int ) Math . floor ( Math . random () * linearLayout . getChildCount ()); Button button = ( Button ) linearLayout . getChildAt ( random ); button . setTextColor ( Color . RED ); } }","title":"Sixteen Buttons"},{"location":"android/sixteen-buttons/#sixteen-buttons","text":"","title":"Sixteen Buttons"},{"location":"android/sixteen-buttons/#neues-projekt-erstellen","text":"\u00dcber den Projekt-Wizard wird man durch den Erstellungsprozess geleitet.","title":"Neues Projekt erstellen"},{"location":"android/sixteen-buttons/#neues-projekt","text":"Nachdem ersten Start von Android Studio ist die Ansicht, wie unten im Screenshot dargestellt, vorhanden. Dabei kann \u00fcber Klick auf + Start a new Android Studio project ein neues Projekt erstellt werden. Alternativ kann \u00fcber die ge\u00f6ffnete Android Studio Projektansicht \u00fcber das Men\u00fc File > New > New Project... ein neues Projekt erstellt werden.","title":"Neues Projekt"},{"location":"android/sixteen-buttons/#erste-activity-wahlen","text":"Ein Android Projekt besteht normalerweise zumindest aus einer Activity. Ein gro\u00dfes Android Projekt kann durchaus \u00fcber Hundert Activities umfassen. F\u00fcr ein neues Projekt kann aus ein Templates f\u00fcr die erste Activity gew\u00e4hlt werden. F\u00fcr das Projekt Sixteen Buttons nutzen wird das Template Empty Activity .","title":"Erste Activity w\u00e4hlen"},{"location":"android/sixteen-buttons/#projektkonfiguration","text":"Im letzten Schritt des Projekt-Wizard werden wichtige Daten zum Projekt festgelegt. All diese Daten k\u00f6nnen grunds\u00e4tzlich sp\u00e4ter noch ver\u00e4ndert werden, dies ist dann aber teilweise mit aufw\u00e4ndigen Refactoring verbunden. Folgende Parameter k\u00f6nnen festgelegt werden: Name: Der Name wird an allen wichtigen Stellen im Android Betriebssystem f\u00fcr die App angezeigt (zB am All-Apps Screen oder am Recents Screen). Package name: Alle Klassen des Projektes werden mit diesem Package Name versehen. Save location: An dieser Stelle wird das Projekt am Dateisystem gespeichert. Language: Native Android Apps k\u00f6nnen grunds\u00e4tzlich in Java oder Kotlin entwickelt werden. Minimum SDK: F\u00fcr Android wird zumindest j\u00e4hrlich eine neue Version (inkl. SDK) ver\u00f6ffentlicht. Die Auswahl h\u00e4ngt davon ab, welche \u00e4lteren Android Versionen von der App noch unterst\u00fctzt werden sollen. W\u00e4hlen Sie die Parameter entsprechend des Screenshots (die Save location ist frei w\u00e4hlbar) und klicken Sie auf Finish .","title":"Projektkonfiguration"},{"location":"android/sixteen-buttons/#layout-editieren","text":"In der Datei res/layout/activity_main.xml findet sich das entsprechende Layout, welches f\u00fcr die Activity geladen wird. Hinweis In der Klasse MainActivity findet man innerhalb der Methode onCreate das Layout, welches der Activity zugeordnet wurde. Mit der Methode setContentView wird \u00fcber die entsprechende Konstante R.layout.activity_main das Layout im Ordner res/layout/activity_main.xml referenziert und dadurch f\u00fcr die Activity festgelegt. Hier k\u00f6nnte jedes beliebige verf\u00fcgbare Layout zugeordnet werden. Layouts werden als XML-Dokumente beschrieben. Ein Layout kann in Android Studio direkt als XML-Dokument \u00fcber die Code-Ansicht oder \u00fcber einen WYSIWYG-Editor in der Design-Ansicht editiert werden. Die Design-Ansicht bietet dabei bereits eine gerenderte Darstellung des XML-Dokumentes. \u00c4nderungen in der Design Ansicht f\u00fchren aber immer zu \u00c4nderungen im XML. Vorerst arbeiten wir nur mit der Code-Ansicht, kopieren Sie dazu den folgenden Code-Auschnitt in den Code-Editor. Der bestehende Inhalt soll dabei gel\u00f6scht werden. <?xml version=\"1.0\" encoding=\"utf-8\"?> <ScrollView xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" xmlns:tools= \"http://schemas.android.com/tools\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" tools:context= \".MainActivity\" > <LinearLayout android:id= \"@+id/button_layout\" android:orientation= \"vertical\" android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" > </LinearLayout> </ScrollView> Im Layout ist das Wurzelelment eine ScrollView . Die ScrollView erzeugt die M\u00f6glichkeit des Scrollens der Kindelemente, welche nicht vollkommen auf dem Bildschirm Platz haben. Innherhalb der ScrollView befindet sich ein LinearLayout . Das LinearLayout erm\u00f6glicht es Kindelemente entweder vertikal oder horizontal in einer Reihe anzuordnen (siehe Attribut android:orientation ). Hinweis Das LinearLayout hat eine android:id als Attribut gesetzt. IDs sind sehr wichtig, da im Quellcode Elemente aus dem Layout \u00fcber die ID referenziert werden k\u00f6nnen. Als Wert f\u00fcr IDs wird eine spezielle Syntax verwendet @+id/beliebiger_name . Mit @+id wird dabei definiert, dass in der Klasse R eine neue ID-Konstante erzeugt werden soll. F\u00fcr den Bezeichner der ID kann ein beliebiger_name festgelegt werden. In der Klasse R wird die ID wie folgt als Konstante erzeugt: R.id.beliebiger_name . Weitere Details dazu finden sich in der Dokumentation .","title":"Layout editieren"},{"location":"android/sixteen-buttons/#16-buttons-hinzufugen","text":"Das Layout einer Activity kann einerseit deklarativ \u00fcber XML definiert werden. Andererseits k\u00f6nnen aber auch dynamische \u00c4nderungen im Layout zur Laufzeit im Quellcode (programmatisch) durchgef\u00fchrt werden. Im folgenden sollen 16 Buttons innerhalb des LinearLayout hinzugef\u00fcgt werden. Innerhalb der Methode onCreate der Klasse MainActivity soll nun das deklarierte LinearLayout im Quellcode referenzirt werden. Dazu ist die Methode findViewById innerhalb der Activity definiert. Durch \u00fcbergabe einer ID kann das entsprechende Element des Layouts abgefragt werden: LinearLayout linearLayout = findViewById ( R . id . button_layout ); Hinweis Alle Layouts erben von der Klasse ViewGroup . Dies ist eine Klasse die das Verwalten von Kindelementen erm\u00f6glicht. Kindelemente einer ViewGroup k\u00f6nnen entweder Views oder wiederum ViewGroups (f\u00fcr verschachtelte Layouts) sein. Eine ViewGroup definiert dabei wichtige Methoden zur Verwaltung von Kindelementen. Die Methode addView erm\u00f6glicht es Kindelemente hinzuzuf\u00fcgen. Die Methode getChildCount gibt die Anzahl der verwalteten Kindelemente zur\u00fcck und die Methode getChildAt liefert eine Referenz auf ein Kindelement durch die Angabe eines Index (\u00e4hnlich zum Zugriff auf ein Array). Innerhalb einer Schleife sollen dann 16 Buttons \u00fcber die Methode addView an das LinearLayout hinzugef\u00fcgt werden. Jede View (wie zum Beispiel der Button ) bekommt eine Referenz auf die Activity in der sie ausgef\u00fchrt wird, \u00fcber den Konstruktur, \u00fcbergeben. Ein Button besitzt unter anderem die Eigenschaft Text, welche \u00fcber den Setter setText angegeben wird. for ( int i = 0 ; i < 16 ; i ++ ) { Button button = new Button ( this ); button . setText ( \"Button \" + ( i + 1 )); linearLayout . addView ( buttons [ i ] ); } Hinweis Alle Views besitzen Eigenschaften. Diese Eigenschaften k\u00f6nnen entweder deklarativ \u00fcber XML-Attribute im Layout oder programmatisch \u00fcber Setter im Quellcode definiert werden. In den meisten F\u00e4llen gibt es eine 1-zu-1 \u00dcbereinstimmung zwischen Eigentschaften im XML-Layout und \u00fcber Setter der View (leider nicht \u00fcberall). Eigenschaften k\u00f6nnen an der View auch \u00fcber Getter abgefragt werden. Ein Starten der App sollte ein \u00c4hnliches Bild wie der angef\u00fchrte Screenshot liefern. Wichtig ist dabei auch, dass man vertikal Scrollen kann (dies wird durch die ScrollView erm\u00f6glicht). Der gesamte Inhalt der Methode onCreate sollte nun folgenderma\u00dfen aussehen: @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); LinearLayout linearLayout = findViewById ( R . id . button_layout ); for ( int i = 0 ; i < 16 ; i ++ ) { Button button = new Button ( this ); button . setText ( \"Button \" + ( i + 1 )); linearLayout . addView ( buttons [ i ] ); } }","title":"16 Buttons hinzuf\u00fcgen"},{"location":"android/sixteen-buttons/#klick-listener-hinzufugen","text":"Grafische Benutzeroberfl\u00e4chen sollen auf Aktionen von Benutzerinnen reagieren. F\u00fcr eine View in der Oberfl\u00e4che kann f\u00fcr definierte Events (wie zB einen Klick) ein EventListener angeben werden. Immmer wenn das entsprechende Event eintritt wird der zugeordnete EventListener ausgef\u00fchrt. Die unterschiedlichen EventListener sind als Java-Interfaces definiert. Eine einfache M\u00f6glichkeit, um einen entsprechenden EventListener zu implementieren, ist es diesen direkt \u00fcber die Activity zu implementieren. Die MainActivity im Projekt sollte so erweitert werden, dass der OnClickListener , welcher als inneres Interface der Klasse View definiert ist, implementiert wird. Nachdem hinzuf\u00fcgen des implements View.OnClickListener wird von der Klasse MainActivity gefordert, dass das entsprechende Interface implementiert wird. Deshalb muss die Methode onClick mit der definierten Methoden-Signatur hinzugef\u00fcgt werden. Hinweis Android Studio generiert alle Methoden, welche von einem Interface definiert sind. Daf\u00fcr kann das Symbol \"rote Gl\u00fchbirne\" f\u00fcr vorschl\u00e4ge geklickt werden. Dies tritt immer dort auf, wo aktuell ein Fehler von der IDE entdeckt wurde. Falls die \"rote Gl\u00fchbirne\" nicht sichtbar ist, aber ein Fehler vorherrscht, k\u00f6nnen durch die Tastenkombination ALT+Enter die selben Vorschl\u00e4ge generiert werden. Der Cursor muss sich daf\u00fcr in der Zeile mit dem Fehler befinden. public class MainActivity extends AppCompatActivity implements View . OnClickListener { // ... @Override public void onClick ( View v ) { // ... } } Die Methode onClick bekommt dabei eine View als Parameter \u00fcbergeben. Diese View repr\u00e4sentiert genau das Element der Benutzeroberfl\u00e4che, auf welches geklickt wurde. Damit das Event-Handling auch funktioniert, m\u00fcssen die Buttons mit dem implementierten EventListener verkn\u00fcpft werden. F\u00fcr jeden Button, der in der Schleife erzeugt wird, muss dies durchgef\u00fchrt werden: button . setOnClickListener ( this ); Damit irgendetwas passiert nachdem Klick auf den Button, muss auch in der Methode onClick etwas ausgef\u00fchrt werden. Dazu soll ein Toast erzeugt werden, welcher eine kurze Nachricht am Bildschirm einblendet. Da bekannt ist, dass die \u00fcbergebene View ein Button ist, kann auch ein entsprechenden Casting mit (Button) durchgef\u00fchrt werden. @Override public void onClick ( View v ) { Button button = ( Button ) v ; Toast toast = Toast . makeText ( this , \"Klick auf \" + button . getText (), Toast . LENGTH_SHORT ); toast . show (); } Durch Klicken auf Button 6 sollte folgende Darstellung erzeugt werden:","title":"Klick Listener hinzuf\u00fcgen"},{"location":"android/sixteen-buttons/#zufalligen-button-auswahlen","text":"Um das Spiel zu realisieren, sollte ein zuf\u00e4lliger Button ausgew\u00e4hlt werden und bei diesem soll die Schriftfarbe auf Rot gesetzt werden. Dazu sollen im ersten Schritt ein LinearLayout als Eigenschaft der Klasse definiert werden. Mit der Methode findViewById soll entsprechend diese Klasseneigenschaft setzen: public class MainActivity extends AppCompatActivity implements View . OnClickListener { // ... protected LinearLayout linearLayout ; @Override protected void onCreate ( Bundle savedInstanceState ) { // ... linearLayout = findViewById ( R . id . button_layout ); // ... } // ... Zur Auswahl eines zuf\u00e4lligen Buttons muss eine Zufallszahl zwischen 0 und 15 erzeugt werden. Mit der Methode getChildAt des LinearLayout Objektes kann \u00fcber den Index eine View abgefragt werden. Da wir wissen, dass jede View ein Button ist, k\u00f6nnen wir auch das entsprechend casten mit (Button) . Die Farbe des Textes im Button wird dann auf Rot gesetzt. public void selectRandomButton () { int random = ( int ) Math . floor ( Math . random () * linearLayout . getChildCount ()); Button button = ( Button ) linearLayout . getChildAt ( random ); button . setTextColor ( Color . RED ); } Die Methode selectRandomButton sollte dann als letztes in der Methode onCreate aufgerufen werden.","title":"Zuf\u00e4lligen Button ausw\u00e4hlen"},{"location":"android/sixteen-buttons/#klick-prufen","text":"F\u00fcr jeden Klick soll nun gepr\u00fcft werden, ob auf einen Button mit rotem Text gedr\u00fcckt wurde. Falls auf einen Button mit rotem Text geklickt wurde, soll der Text wieder auf Schwarz gesetzt werden und ein anderer zuf\u00e4lliger Button soll wieder Rot gef\u00e4rbt werden. Die Schriftfrabe des Buttons kann \u00fcber die Methode getTextColors abgefragt werden. Als R\u00fcckgabewert dieses Getter wird ein Objekt vom ColorStateList zur\u00fcckgegeben. Da ein Button f\u00fcr unterschiedliche Zust\u00e4nde (zB Enabled/Disabled, Gedr\u00fcckt, ...) eine andere Farbe definiert haben kann, wird eben eine ColorSateList verwendet. Dabei kann die Methode getDefaultColor der ColorStateList verwendet werden, um die Schriftfarbe im \"Normalzustand\" des Buttons abzufragen. Im Falle einer \u00dcbereinstimmung mit der Farbe Rot ( Color.RED ) soll eben die Farbe auf Schwarz ( Color.BLACK ) gesetzt ewrden. Des Weiteren soll ein weiterer zuf\u00e4lliger Button Rot eingef\u00e4rbt werden ( selectRandomButton ). @Override public void onClick ( View v ) { Button button = ( Button ) v ; int color = button . getTextColors (). getDefaultColor (); if ( color == Color . RED ) { button . setTextColor ( Color . BLACK ); selectRandomButton (); } } Im folgenden Screenshot wird ein zuf\u00e4llig Rot gef\u00e4rbter Button angezeigt:","title":"Klick pr\u00fcfen"},{"location":"android/sixteen-buttons/#gesamter-quellcode","text":"","title":"Gesamter Quellcode"},{"location":"android/sixteen-buttons/#activity_mainxml","text":"<?xml version=\"1.0\" encoding=\"utf-8\"?> <ScrollView xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" xmlns:tools= \"http://schemas.android.com/tools\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" tools:context= \".MainActivity\" > <LinearLayout android:id= \"@+id/button_layout\" android:orientation= \"vertical\" android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" > </LinearLayout> </ScrollView>","title":"activity_main.xml"},{"location":"android/sixteen-buttons/#mainactivity","text":"package fhku.sixteenbuttons ; import androidx.appcompat.app.AppCompatActivity ; import android.graphics.Color ; import android.os.Bundle ; import android.view.View ; import android.widget.Button ; import android.widget.LinearLayout ; import android.widget.Toast ; public class MainActivity extends AppCompatActivity implements View . OnClickListener { protected LinearLayout linearLayout ; @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); linearLayout = findViewById ( R . id . button_layout ); for ( int i = 0 ; i < 16 ; i ++ ) { Button button = new Button ( this ); button . setText ( \"Button \" + ( i + 1 )); button . setOnClickListener ( this ); linearLayout . addView ( button ); } selectRandomButton (); } @Override public void onClick ( View v ) { Button button = ( Button ) v ; int color = button . getTextColors (). getDefaultColor (); if ( color == Color . RED ) { button . setTextColor ( Color . BLACK ); selectRandomButton (); } // Toast toast = Toast.makeText(this, \"Klick auf \" + button.getText(), Toast.LENGTH_SHORT); // toast.show(); } public void selectRandomButton () { int random = ( int ) Math . floor ( Math . random () * linearLayout . getChildCount ()); Button button = ( Button ) linearLayout . getChildAt ( random ); button . setTextColor ( Color . RED ); } }","title":"MainActivity"},{"location":"android/snake/","text":"Snake Projekt\u00fcbersicht F\u00fcr das Projekt werden 3 Activities ben\u00f6tigt. Jeder Screen der App wird \u00fcber eine Activity realisiert. F\u00fcr jede Activity muss auch ein eigenes Layout als XML erstellt werden. Am Startscreen ( MainActivity ) finden sich 3 Buttons , welche jeweils \u00fcber einen Intent die GameActivity starten. Dabei soll der Intent \u00fcber ein Extra den Parameter speed \u00fcbergeben. Der Parameter bestimmt dabei wie schnell sich die Schlange bewegen soll. Jenachdem welcher der 3 Buttons geklickt wurde, ist dies eben ein anderer Wert. Die GameActivity enth\u00e4lt das entsprechende Spiel. Dabei soll eine eigene View implementiert werden, welche die Schlange enth\u00e4lt. Es gibt unten 4 Buttons welche die Bewegung der Schlange erm\u00f6glichen. Oben findet sich ebenfalls noch ein dynamisches Textfeld, welches f\u00fcr jede Bewegung, welche die Schlange macht um eins hochgez\u00e4hlt wird. Falls das Schlange an den Rand oder an einen Teil ihres K\u00f6rpers gespielt wurde, ist das Spiel beendet. In diesem Fall soll die GameOverActivity ge\u00f6ffnet werden. Im Intent soll ein Extra mit der Anzahl der moves \u00fcbergeben werden. Diese sollen auch in der GameOverActivity angezeigt werden. Es gibt ebenfalls einen Button zum Restart des Spieles. Dieser soll zur MainActivity leiten (\u00fcber einen Intent ). Projekt clonen Es steht eine Ausgangsbasis f\u00fcr das Projekt bereit. Dieses ist \u00fcber Gitlab zu beziehen. Im Projekt finden sich alle Aufgaben als TODOS in Android Studio. Diese m\u00fcssen Schritt f\u00fcr Schritt abgearbeitet werden um das Spiel zu realisieren. Klasse Snake Innerhalb der Klasse Snake befindet sich die gesamte Spiellogik. Das Spielbrett ist als 2-dimensionales Array abgebildet. Im unten angef\u00fchrten Beispiel wird beispielhaft ein Snake-Spiel innerhalb eines 6x6-Grid gezeigt. Dabei ist ein Apfel als -1 , der Schlangenkopf als -2 und die leeren Felder als 0 angezeigt. Der Schlangenk\u00f6rper besteht aus Zahlen gr\u00f6\u00dfer 0 und erh\u00f6ht sich in jedem Zug. #game { display:grid; grid-template-columns:1fr 1fr 1fr 1fr; } #game h2 { font-size:12px; } #game .grid { display:grid; grid-template-columns: 20px 20px 20px 20px 20px 20px; grid-template-rows: 20px 20px 20px 20px 20px 20px; } #game .grid > div { border:1px solid black; display:flex; justify-content:center; align-items:center; } Start 0 0 0 0 0 0 0 0 0 0 0 0 0 1 -2 0 0 0 0 0 0 0 -1 0 0 0 0 0 0 0 0 0 0 0 0 0 Bewegung nach Rechts 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 -2 0 0 0 0 0 0 -1 0 0 0 0 0 0 0 0 0 0 0 0 0 Bewegung nach Rechts 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 -2 0 0 0 0 0 -1 0 0 0 0 0 0 0 0 0 0 0 0 0 Bewegung nach Unten 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 4 0 0 0 0 0 -2 0 0 -1 0 0 0 0 0 0 0 0 0 0 Bewegung nach Unten 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 5 0 0 -1 0 0 -2 0 0 0 0 0 0 0 Bewegung nach Links 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 0 -1 0 -2 6 0 0 0 0 0 0 0 Bewegung nach Links 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 -1 -2 7 6 0 0 0 0 0 0 0 Bewegung nach Links 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 -1 0 0 0 0 0 0 0 0 0 -2 8 7 6 0 0 0 0 0 0 0 public class Snake { // Konstanten f\u00fcr die unterschiedlichen Werte, welche in Zellen // stehen k\u00f6nnen. F\u00fcr den BODY der Schlange wird ein dynamischer // Wert errechnet: Der BODY wird in jedem Zug um eins erh\u00f6ht public static final int CELL_EMPTY = 0 ; public static final int CELL_APPLE = - 1 ; public static final int CELL_HEAD = - 2 ; // Die unterschiedlichen \u00c4nderungen, welche bei einem MOVE in // die entsprechende Richtung die Koordinate ge\u00e4ndert werden // Zum Beispiel nach links wird die Koordinate x=-1 und y=0 ge\u00e4ndert public static final int [] MOVE_LEFT = { - 1 , 0 }; public static final int [] MOVE_RIGHT = { 1 , 0 }; public static final int [] MOVE_UP = { 0 , - 1 }; public static final int [] MOVE_DOWN = { 0 , 1 }; // 2-dimensionales Spielfeld public int [][] grid ; // \u00c4nderungskoordinate in jeden Spielzug // diese wird durch die Methoden // moveUp, moveDown, moveLeft, moveRight ver\u00e4ndert public int [] move = { 1 , 0 }; // x/y Koordinate des Schlangenkopf public int [] head ; // x/y Koordinate des Hinterteils der Schlange public int [] tail ; // x/y Koordinate des Apfels public int [] apple ; // Jede Bewegung des Kopfes erh\u00f6ht // diesen Wert um 1 public int headMoves = 1 ; public Snake ( int size ) { grid = new int [ size ][ size ] ; } // Diese Methode initialisiert das Spielfeld // Die Schlange hat den Kopf und ein K\u00f6rperteil public void init () { // TODO: Zellen initialisieren // Alle Zellen des Grids leer setzten (CELL_EMPTY) // in der Mitte des Spielfeldes den Kopf setzen und links daneben den ersten Body // Der Body hat im ersten Schritt den Wert 1 // dieser ist in der Variable headMoves zu finden setApple (); } // Diese Methode soll den Apfel zuf\u00e4llig setzen public void setApple () { // TODO: Apfel zuf\u00e4llig setzen // Zuf\u00e4llig eine freie Position (CELL_EMPTY) suchen und Apfel (CELL_APPLE) positionieren // x/y f\u00fcr den Apfel in der Variable apple setzen } // Diese Methode ist verantwortlich f\u00fcr die Durchf\u00fchrung des n\u00e4chsten Spielzuges. // Diese Methode liefert true zur\u00fcck falls der Spielzug g\u00fcltig war und erfolgreich // durchgef\u00fchrt werden konnte. Diese Methode liefert false zur\u00fcck wenn der Zug // ung\u00fcltig w\u00e4re. Ein R\u00fcckgabewert false bedeutet auch, dass das Spiel verloren wurde public boolean next () { // der n\u00e4chste Zug wird errechnet indem die aktuelle Position des head mit // den \u00c4nderungskoordinaten in x und y Richtung addiert wird // moveX und moveY stellen die n\u00e4chsten Koordinaten, wohin die Schlange // wandern w\u00fcrde dar int moveX = head [ 0 ] + move [ 0 ] ; int moveY = head [ 1 ] + move [ 1 ] ; // TODO: G\u00fcltige Bewegung (innerhalb des Spielfeldes) // Pr\u00fcfen ob die Bewegung au\u00dferhalb des Spielfelds f\u00fchren w\u00fcrde // return false falls dies der Fall w\u00e4re // TODO: G\u00fcltige Bewegung (Teil der Schlange) // Pr\u00fcfen ob n\u00e4chster Zug Teil der Schlange ist // return false falls dies der Fall w\u00e4re // TODO: Ist der n\u00e4chste Zug ein Apfel? // Pr\u00fcfen ob n\u00e4chster Zug ein Apfel ist, dann soll: // (1) nur der Kopf bewegt werden: auf die neue Position // (2) headMoves + 1 und im Spielfeld ein neues K\u00f6rperteil (mit neuem headMoves Wert) anstelle des Kopfs setzen // (3) einen neuen Apfel zuf\u00e4llig auf ein leeres Feld positionieren // (4) return true // TODO: Ist der n\u00e4chste Zug ein leeres Feld? // Pr\u00fcfen ob n\u00e4chster Zug ein leeres Feld ist, dann soll: // (1) der Kopf bewegt werden // (2) im Spielfeld ein neues K\u00f6rperteil anstelle des Kopfs und Kopfs weiterbewegen // (3) Schwanzteil eliminieren und tail auf vorletztes Teil setzen (vorletztes Teil \u00fcber headMoves + 1 erkennen) // (4) return true return false ; } public void moveUp () { move = MOVE_UP ; } public void moveDown () { move = MOVE_DOWN ; } public void moveLeft () { move = MOVE_LEFT ; } public void moveRight () { move = MOVE_RIGHT ; } } Eigene View Klasse Die Klasse SnakeView ist eine quadratische View und zeichnet das Spielfeld. Zum entsprechenden Interval wird die Methode draw aufgerufen mit dem Spielfeld aus der Klasse Snake . Innerhalb der Methode onDraw wird dann das Spielfeld auf der bereitgestellten Canvas neu gezeichnet. public class SnakeView extends View { protected Paint paintBackground ; protected Paint paintSnakeBody ; protected Paint paintSnakeHead ; protected Paint paintApple ; protected int [][] grid ; public SnakeView ( Context context , @Nullable AttributeSet attrs ) { super ( context , attrs ); // TODO: Zeichenstifte erzeugen // die 4 Zeichenstifte (Paint) sollen erzeugt werden: // Background=Gr\u00fcn, Apfel=Rot // Schlangenkopf=Dunkelgrau, Schlangenk\u00f6rper=Hellgrau } public void draw ( int [][] grid ) { this . grid = grid ; // Durch den Aufruf der Methode invalidate, wird das // Neuzeichnen der View zum n\u00e4chsten m\u00f6glichen Zeitpunk gefordert // Wann dies genau passiert wird dann vom Betriebssystem entschieden invalidate (); } @Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { // in dieser Methode wird festgelegt, dass die View immer // eine quadratische Grundfl\u00e4che hat, hier muss nichts ver\u00e4ndert werden int parentWidth = MeasureSpec . getSize ( widthMeasureSpec ); setMeasuredDimension ( parentWidth , parentWidth ); } @Override protected void onDraw ( Canvas canvas ) { // Eine invalidierte View wird nach Vorgabe vom Betriebssystem neu gezeichnet // daf\u00fcr wird die Methode onDraw aufgerufen und eine Canvas \u00fcbergeben // Das Canvas hat die Methode getWidth bzw. getHeight um die verf\u00fcgbare // Gr\u00f6\u00dfe zu errechnen, die Gr\u00f6\u00dfe einer Zelle kann dadurch errechnet werden // TODO: Spielfeld zeichnen // (1) Der Hintergrund soll als Rechteck gezeichnet werden // (2) Der Apfel als Roter Kreis // (3) Der Kopf als Dunkelgrauer Kreis // (4) Alle K\u00f6rperteile als Hellgrauer Kreis } } GameActivity Layout Die Klasse SnakeView kann wie folgt im XML-Layout integriert werden. Es kann an allen R\u00e4ndern eine Margin gesetzt werden. Falls der Hintergrund des Layouts Schwarz ist, entsteht der schwarze Rand um das Spielfeld (Ersichtlich im Screenshot). <fhku.snake.SnakeView android:id= \"@+id/snake_view\" android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:layout_marginStart= \"8dp\" android:layout_marginTop= \"8dp\" android:layout_marginEnd= \"8dp\" android:layout_marginBottom= \"8dp\" /> Die Buttons zur Steuerung des Spiels k\u00f6nnen als ImageButtons erzeugt werden. Die Symbole, welche sich auf den Buttons befinden wurden als Vektorgrafiken bereitgestellt. Die 4 Buttons k\u00f6nnen dabei die selbe Grafik verwenden, m\u00fcssen diese nur rotieren (Siehe Eigenschaft rotation ). Dei 4 Buttons sollen dabei innerhalb eines horizontalen LinearLayouts gesetzt werden. <ImageButton android:id= \"@+id/button_left\" android:layout_width= \"wrap_content\" android:layout_height= \"wrap_content\" android:layout_weight= \"1\" android:background= \"#00FF00\" android:rotation= \"180\" app:srcCompat= \"@drawable/button\" />","title":"Snake"},{"location":"android/snake/#snake","text":"","title":"Snake"},{"location":"android/snake/#projektubersicht","text":"F\u00fcr das Projekt werden 3 Activities ben\u00f6tigt. Jeder Screen der App wird \u00fcber eine Activity realisiert. F\u00fcr jede Activity muss auch ein eigenes Layout als XML erstellt werden. Am Startscreen ( MainActivity ) finden sich 3 Buttons , welche jeweils \u00fcber einen Intent die GameActivity starten. Dabei soll der Intent \u00fcber ein Extra den Parameter speed \u00fcbergeben. Der Parameter bestimmt dabei wie schnell sich die Schlange bewegen soll. Jenachdem welcher der 3 Buttons geklickt wurde, ist dies eben ein anderer Wert. Die GameActivity enth\u00e4lt das entsprechende Spiel. Dabei soll eine eigene View implementiert werden, welche die Schlange enth\u00e4lt. Es gibt unten 4 Buttons welche die Bewegung der Schlange erm\u00f6glichen. Oben findet sich ebenfalls noch ein dynamisches Textfeld, welches f\u00fcr jede Bewegung, welche die Schlange macht um eins hochgez\u00e4hlt wird. Falls das Schlange an den Rand oder an einen Teil ihres K\u00f6rpers gespielt wurde, ist das Spiel beendet. In diesem Fall soll die GameOverActivity ge\u00f6ffnet werden. Im Intent soll ein Extra mit der Anzahl der moves \u00fcbergeben werden. Diese sollen auch in der GameOverActivity angezeigt werden. Es gibt ebenfalls einen Button zum Restart des Spieles. Dieser soll zur MainActivity leiten (\u00fcber einen Intent ).","title":"Projekt\u00fcbersicht"},{"location":"android/snake/#projekt-clonen","text":"Es steht eine Ausgangsbasis f\u00fcr das Projekt bereit. Dieses ist \u00fcber Gitlab zu beziehen. Im Projekt finden sich alle Aufgaben als TODOS in Android Studio. Diese m\u00fcssen Schritt f\u00fcr Schritt abgearbeitet werden um das Spiel zu realisieren.","title":"Projekt clonen"},{"location":"android/snake/#klasse-snake","text":"Innerhalb der Klasse Snake befindet sich die gesamte Spiellogik. Das Spielbrett ist als 2-dimensionales Array abgebildet. Im unten angef\u00fchrten Beispiel wird beispielhaft ein Snake-Spiel innerhalb eines 6x6-Grid gezeigt. Dabei ist ein Apfel als -1 , der Schlangenkopf als -2 und die leeren Felder als 0 angezeigt. Der Schlangenk\u00f6rper besteht aus Zahlen gr\u00f6\u00dfer 0 und erh\u00f6ht sich in jedem Zug. #game { display:grid; grid-template-columns:1fr 1fr 1fr 1fr; } #game h2 { font-size:12px; } #game .grid { display:grid; grid-template-columns: 20px 20px 20px 20px 20px 20px; grid-template-rows: 20px 20px 20px 20px 20px 20px; } #game .grid > div { border:1px solid black; display:flex; justify-content:center; align-items:center; }","title":"Klasse Snake"},{"location":"android/snake/#eigene-view-klasse","text":"Die Klasse SnakeView ist eine quadratische View und zeichnet das Spielfeld. Zum entsprechenden Interval wird die Methode draw aufgerufen mit dem Spielfeld aus der Klasse Snake . Innerhalb der Methode onDraw wird dann das Spielfeld auf der bereitgestellten Canvas neu gezeichnet. public class SnakeView extends View { protected Paint paintBackground ; protected Paint paintSnakeBody ; protected Paint paintSnakeHead ; protected Paint paintApple ; protected int [][] grid ; public SnakeView ( Context context , @Nullable AttributeSet attrs ) { super ( context , attrs ); // TODO: Zeichenstifte erzeugen // die 4 Zeichenstifte (Paint) sollen erzeugt werden: // Background=Gr\u00fcn, Apfel=Rot // Schlangenkopf=Dunkelgrau, Schlangenk\u00f6rper=Hellgrau } public void draw ( int [][] grid ) { this . grid = grid ; // Durch den Aufruf der Methode invalidate, wird das // Neuzeichnen der View zum n\u00e4chsten m\u00f6glichen Zeitpunk gefordert // Wann dies genau passiert wird dann vom Betriebssystem entschieden invalidate (); } @Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { // in dieser Methode wird festgelegt, dass die View immer // eine quadratische Grundfl\u00e4che hat, hier muss nichts ver\u00e4ndert werden int parentWidth = MeasureSpec . getSize ( widthMeasureSpec ); setMeasuredDimension ( parentWidth , parentWidth ); } @Override protected void onDraw ( Canvas canvas ) { // Eine invalidierte View wird nach Vorgabe vom Betriebssystem neu gezeichnet // daf\u00fcr wird die Methode onDraw aufgerufen und eine Canvas \u00fcbergeben // Das Canvas hat die Methode getWidth bzw. getHeight um die verf\u00fcgbare // Gr\u00f6\u00dfe zu errechnen, die Gr\u00f6\u00dfe einer Zelle kann dadurch errechnet werden // TODO: Spielfeld zeichnen // (1) Der Hintergrund soll als Rechteck gezeichnet werden // (2) Der Apfel als Roter Kreis // (3) Der Kopf als Dunkelgrauer Kreis // (4) Alle K\u00f6rperteile als Hellgrauer Kreis } }","title":"Eigene View Klasse"},{"location":"android/snake/#gameactivity-layout","text":"Die Klasse SnakeView kann wie folgt im XML-Layout integriert werden. Es kann an allen R\u00e4ndern eine Margin gesetzt werden. Falls der Hintergrund des Layouts Schwarz ist, entsteht der schwarze Rand um das Spielfeld (Ersichtlich im Screenshot). <fhku.snake.SnakeView android:id= \"@+id/snake_view\" android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:layout_marginStart= \"8dp\" android:layout_marginTop= \"8dp\" android:layout_marginEnd= \"8dp\" android:layout_marginBottom= \"8dp\" /> Die Buttons zur Steuerung des Spiels k\u00f6nnen als ImageButtons erzeugt werden. Die Symbole, welche sich auf den Buttons befinden wurden als Vektorgrafiken bereitgestellt. Die 4 Buttons k\u00f6nnen dabei die selbe Grafik verwenden, m\u00fcssen diese nur rotieren (Siehe Eigenschaft rotation ). Dei 4 Buttons sollen dabei innerhalb eines horizontalen LinearLayouts gesetzt werden. <ImageButton android:id= \"@+id/button_left\" android:layout_width= \"wrap_content\" android:layout_height= \"wrap_content\" android:layout_weight= \"1\" android:background= \"#00FF00\" android:rotation= \"180\" app:srcCompat= \"@drawable/button\" />","title":"GameActivity Layout"},{"location":"mobile-web/draggable-grid/","text":"Draggable Grid In diesem Projekt soll ein Responsive Grid erstellt werden, welcher sich an die gegebenen Bildschirmgr\u00f6\u00dfen anpasst. Die Anordnung der Elemente des Grid sollen \u00fcber Drag und Drop ver\u00e4ndert werden k\u00f6nnen. Das Projekt soll sowohl f\u00fcr Desktops als auch f\u00fcr Smartphones nutzbar sein. Projekt Setup Erstellen Sie einen leeren Projektordner auf Ihrem Rechner die Bennenung ist grunds\u00e4tzlich egal, jedoch draggable-grid w\u00fcrde sich anbieten. Innerhalb des Ordners erstellen Sie eine Datei package.json . Als Inhalt der Datei f\u00fcgen Sie 2 geschweifte Klammern ein: {} Installieren Sie einen Web-Server zur lokalen Entwicklung mit npm i http-server --save-dev . Nach der Installation k\u00f6nnen Sie ein script in der Datei package.json hinzuf\u00fcgen um den Web-Server zu starten. Das finale package.json sollte folgenden Inhalt aufweisen: { \"scripts\" : { \"start\" : \"http-server docs -p 8080\" }, \"devDependencies\" : { \"http-server\" : \"^0.12.3\" } } Es soll noch ein Ordner docs erstellt werden, welcher alle Projektdateien enh\u00e4lt. Durch die Ausf\u00fchrung von npm start kann nun die lokale Entwicklung begonnen werden. Hinweis F\u00fcr ein Deployment auf Github Pages sollten alle Dateien, welche zur App geh\u00f6ren im Ordner docs liegen. Dieser Ordner wird dann \u00fcber einen Web-Server \u00f6ffentlich bereitgestellt. HTML/CSS Die Benutzerschnittstelle ist sehr einfach gehalten. Im folgenden findet sich das HTML-Dokument und das zugeh\u00f6rige CSS-Stylesheet um das Responsive Grid zu erstellen. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Draggable Grid </ title > < link rel = \"stylesheet\" href = \"style.css\" > </ head > < body > < h1 > Draggable Grid </ h1 > < ul > < li data-index = \"1\" > One </ li > < li data-index = \"2\" > Two </ li > < li data-index = \"3\" > Three </ li > < li data-index = \"4\" > Four </ li > < li data-index = \"5\" > Five </ li > < li data-index = \"6\" > Six </ li > </ ul > </ body > </ html > body { font-family : sans-serif ; margin : 0 ; } h1 { font-size : 18 px ; text-align : center ; } ul { padding : 20 px ; display : grid ; grid-template-columns : repeat ( auto -fit , minmax ( 280 px , 1 fr )); column-gap : 15 px ; row-gap : 15 px ; justify-content : center ; } @ media ( min-width : 992px ) { ul { grid-template-columns : repeat ( 3 , minmax ( 200 px , 400 px )); } } li { list-style : none ; padding : 10 px ; border-radius : 5 px ; border : 1 px solid DarkTurquoise ; background : LightCyan ; cursor : grab ; } Diese beiden Quellcodeabschnitte sind jeweils in die Datei docs/index.html bzw. docs/style.css zu kopieren. Draggable Um HTML-Elemente als draggable zu definieren, reicht es grunds\u00e4tzlich aus, dass Attribut draggable und den Wert true zu setzen. Dies soll f\u00fcr die li Elemente durchgef\u00fchrt werden: < li draggable = \"true\" data-index = \"1\" > One </ li > < li draggable = \"true\" data-index = \"2\" > Two </ li > < li draggable = \"true\" data-index = \"3\" > Three </ li > <!-- ... --> Drag Events HTML-Elemente die als draggable definiert sind, erzeugen wichtige Events, welche \u00fcber JavaScript abfragbar sind. In der folgenden Tabelle sind die wichtigsten Events aufgef\u00fchrt. Als Target wird das HTML-Element bezeichnet, welches sich im JavaScript Event in der Eigenschaft target befindet. Event Target Beschreibung drag Gezogenes HTML-Element Dieses Event wird alle paar Millisekunden getriggert, wenn das HTML-Element von der Benutzerin gezogen wird. Wichtige Eigenschaften wie die x/y Koordinaten des Mauszeigers befinden sich in diesem Event dragstart Gezogenes HTML-Element Die Benutzerin beginnt die Drag and Drop Operation dragend Gezogenes HTML-Element Die Benutzerin beendet die Drag and Drop Operation (zum Beispiel loslassen des Mouse-Button am Desktop) dragenter Drop-Target HTML-Element Die Benutzerin zieht ein draggable HTML-Element \u00fcber ein Drop-Target dragleave Drop-Target HTML-Element Die Benutzerin zieht ein draggable HTML-Element aus dem Bereich eines Drop-Target dragover Drop-Target HTML-Element Falls die Benutzerin ein draggable HTML-Element \u00fcber ein Drop-Target zieht, wird alle paar Millisekunden das dragover Event mit genauen x/y Koordinaten der Mauszeiger erzeugt drop Drop-Target HTML-Element Dieses Event wird erzeugt, wenn die Drag and Drop Operation auf einem Drop-Target beendet wird Hinweis Ein HTML-Element wird grunds\u00e4tzlich zum Drop-Target , wenn es das Attribut draggable besitzt. Drag Start und Drag End Zur Demonstration des dragstart bzw. dragend Events soll eine CSS-Klasse auf dem HTML-Element gesetzt werden, welches sich in einer Drag and Drop Operation befindet. Dazu soll im ersten Schritt die CSS-Klasse dragged im CSS-Stylestheet hinzugef\u00fcgt werden: /* ... */ . dragged { opacity : 30 % ; } Zus\u00e4tzlich soll eine index.js Datei erzeugt werden, welche das notwendige JavaScript enth\u00e4lt. Die JavaScript Datei soll \u00fcber ein script Tag im HTML-Head eingebunden werden: <!-- ... --> < head > <!-- ... --> < script defer src = \"index.js\" ></ script > </ head > <!-- ... --> Als Inhalt der JavaScript Datei soll folgendes hinzugef\u00fcgt werden: const draggableItemsContainer = document . querySelector ( 'ul' ); draggableItemsContainer . addEventListener ( 'dragstart' , ( e ) => { e . target . classList . add ( 'dragged' ); }); draggableItemsContainer . addEventListener ( 'dragend' , ( e ) => { e . target . classList . remove ( 'dragged' ); }); Im Skript wird das Elternelement der draggable HTML-Elemente selektiert. Es wird der EventListener dragstart oder dragend gesetzt, welcher die CSS-Klasse dragged am Event Target setzt oder entfernt. Drag Enter und Drag Leave Am Drop-Target soll ebenfalls eine CSS-Style\u00e4nderung durchgef\u00fchrt werden, wenn eine Drag and Drop Operation \u00fcber dem HTML-Element durchgef\u00fchrt wird. Es soll die CSS-Klasse dragover erstellt werden. Diese CSS-Klasse soll \u00fcber die Events dragenter bzw. dragleave am Drop-Target \"getoggled\" werden. /* ... */ . dragover { border : 1 px dotted OrangeRed ; background : Coral ; } Die \u00c4nderung der CSS-Klasse soll dabei nur durchgef\u00fchrt werden, wenn das Event Target ein index Attribut im Dataset definiert hat. Dies wurde f\u00fcr alle draggable HTML-Elemente bereits definiert. Ansonsten w\u00fcrden alle m\u00f6glichen HTML-Elemente, \u00fcber welche das HTML-Element gezogen wird mit der CSS-Klasse ausgestattet. // ... draggableItemsContainer . addEventListener ( 'dragenter' , ( e ) => { if ( e . target . dataset . index ) { e . target . classList . add ( 'dragover' ); } }); draggableItemsContainer . addEventListener ( 'dragleave' , ( e ) => { if ( e . target . dataset . index ) { e . target . classList . remove ( 'dragover' ); } }); Drag Over und Drop Damit das entsprechende Drop Event ausgef\u00fchrt wird und die HTML-Elemente entsprechend getauscht werden, m\u00fcssen EventListener f\u00fcr dragover und drop hinzugef\u00fcgt werde. Damit das drop Event korrekt ausgef\u00fchrt wird, muss f\u00fcr das dragover Event die Function preventDefault ausgef\u00fchrt werden. Nur in diesem Fall erlaub der Web-Browser drop Events. Um im drop Event, welches auf dem Drop-Target ausgef\u00fchrt wird, das gezogene HTML-Element anzufragen, soll im dragstart der data-index vom gezogenen HTML-Element innerhalb des DataTransfer Objektes mitgeben werden. Hinweis Das DataTransfer Objekt k\u00f6nnte zB auch eine Datei enthalten, welche am Desktop vom Datei-Explorer in den Web-Browser gezogen wird (per Drag and Drop). Im datastart Event soll am entsprechenden DataTransfer Objekt \u00fcber die Methode setData der data-index des gezogenen HTML-Elements hinzugef\u00fcgt werden. Die setData Methode verlangt als ersten Parameter den Mime-Type des 2. Parameters. In diesem Fall handelt es sich um Plaintext. Falls es sich um ein Bild handeln w\u00fcrde, k\u00f6nnte zB image/jpg als Mime-Type angegeben werden. Im drop Event kann dann der Wert, welcher im DataTransfer Objekt gesetzt wurde wieder abgefrag werden. Somit k\u00f6nnen beide Indizes (vom gezogenen HTML-Element und vom Drop-Target ) abgefragt werden. Mit den beiden Indizes Werten kann im folgenden die \u00c4nderung im DOM vorgenommen werden, sodass eben die beiden HTML-Elemente ausgetauscht werden. draggableItemsContainer . addEventListener ( 'dragstart' , ( e ) => { e . dataTransfer . setData ( 'text/plain' , e . target . dataset . index ); // data-index e . target . classList . add ( 'dragged' ); }); // ... draggableItemsContainer . addEventListener ( 'dragover' , ( e ) => { e . preventDefault (); }); draggableItemsContainer . addEventListener ( 'drop' , ( e ) => { e . preventDefault (); const index1 = e . dataTransfer . getData ( 'text/plain' ); const index2 = e . target . dataset . index ; // TODO: HTML-Elemente tauschen }); Aufgabe 1a Das HTML-Element, welches gerade gezogen wird, soll beim dragenter Event die CSS-Klasse dragover nicht gesetzt bekommen. Aufgabe 1b Im drop Event wurde ein TODO hinterlegt, welches die beiden \u00fcber die entsprechenden data-index Attribute identifizierbaren HTML-Elemente tauschen soll. Erstellen Sie dazu eine globale Funktion swapItems , welche die beiden Indizes index1 und index2 \u00fcbergeben bekommt. Die Funktion soll dann die beiden HTML-Elemente im DOM austauschen. Dabei sollte nicht nur der Textinhalt getauscht werden, sondern tats\u00e4chlich die HTML-Elemente. Hinweis: F\u00fcr die DOM-API gibt es eine Vielzahl hilfreicher Funktionen, welche generell f\u00fcr \u00c4nderungen im DOM verwendet werden k\u00f6nnen. Im konkreten Fall, gibt es Funktionen wie zB insertAdjacentElement , appendChild oder removeChild , welche hier n\u00fctzlich sein k\u00f6nnen. Ebenfalls gibt es zum jeweiligen DOM-Knoten (aka HTML-Element) wichtige und n\u00fctzliche Attribute, im konkreten Fall zum Beispiel previousElementSibling oder nextElementSibling . Ausf\u00fchrung am Smartphone Wenn die Web-Applikation auf Github gestellt wird und dort \u00fcber Github Pages deployed wird, wird ersichtlich, dass das Drag and Drop nicht am Smartphone funktioniert. Leider funktioniert die aktuelle Implementierung nur f\u00fcr Desktop Browser, dass h\u00e4tte man vielleicht am Beginn des Tutorials bereits erw\u00e4hnen sollen . Touch Events Der Web-Browser ist multitouchf\u00e4hig. Das bedeutet, dass jeder Finger am Display einzeln abgebildet werden kann. Jeder Finger ist als Touch Objekt repr\u00e4sentiert. Am Touch Objekt wird \u00fcber die Eigenschaften clientX bzw. clientY die Koordinaten des Fingers am Display angegeben. Ensprechend des Verhaltens der Finger am Display sind unterschiedliche Events definiert: Event Beschreibung touchstart Ein Finger ist auf das Display gelegt worden, am entsprechenden HTML-Element wird das touchstart Event ausgel\u00f6st touchend Ein Finger ist vom Display entfernt worden, am entsprechenden HTML-Element wird das touchend Event ausgel\u00f6st touchmove Ein Finger am Display wird bewegt touchcancel Der Touch-Vorgang wurde unsachgem\u00e4\u00df beendet, zum Beispiel wurde der Finger \u00fcber das Display hinausgezogen HTML-Element bewegen (Touch-basiert) \u00c4hnlich zum klassischen Drag and Drop werden f\u00fcr das Touch Handling die EventListener ebenfalls am Elternelement ul gesetzt. Im ersten Schritt ist es wichtig zu verstehen, wie ein HTML-Element bewegt werden kann. Eine effiziente Form kann \u00fcber die CSS-Eigenschaft transform mit dem Wert translate(x,y) durchgef\u00fchrt werden. Dies kann eben unter anderem \u00fcber JavaScript durchgef\u00fchrt werden. Folgender Javascript Quellcode w\u00fcrde ein bestehendes HTML-Element 15px nach rechts und 15px nach oben verschieben. W\u00e4hlen Sie dazu ein beliebiges HTML-Element einer Website \u00fcber die Web-Entwickler Werkzeuge aus und f\u00fcgen Sie in der Konsole folgendes JavaScript ein: $0 . style . transform = \"translate(15px, -15px)\" ; Wichtig zu verstehen ist, dass der Platz an dem das HTML-Element vor dem Transformationsschritt gezeichnet wurde frei bleibt. Die umliegenden HTML-Element f\u00fcllen den leeren Platz nicht auf. Das transformierte HTML-Element \u00fcberdeckt die umliegenden HTML-Elemente. Aus diesem Grund ist generell nur die Composite Phase des Rendering Vorgangs im Web-Browser notwendig. Die Bewegung \u00fcber JavaScript w\u00fcrde so enstehen, dass bei jedem touchmove Event die x/y Koordinaten f\u00fcr die Transformation am zu bewegenden HTML-Element ( translate(x, y) ) angepasst wird. Die x bzw. y Werte f\u00fcr die translate Funktion sollen dabei immer als Differenz zum initialen Wert der x/y Koordinaten des Touch Events gesetzt werden. Dies soll hoffentlich \u00fcber die unten angef\u00fchrte Grafik verst\u00e4ndlich gemacht werden: Der gesamte Drag and Drop Quellcode aus den vorangegangenen Abschnitten soll innerhalb einer Funktion initDragAndDrop hinterlegt werden. Die von Ihnen entwickelte globale Funktion swapItems soll nicht innerhalb der initDragAndDrop gesetzt werden, diese wird auch im Touch Handling wiederverwendet. Vorerst soll nur die initTouch Funktion ausgef\u00fchrt werden. function initDragAndDrop () { const draggableItemsContainer = document . querySelector ( 'ul' ); // ... // Drag and Drop Quellcode aus dem vorangegangenen Abschnitten // hier einf\u00fcgen } function initTouch () { const draggableItemsContainer = document . querySelector ( 'ul' ); let initialX = 0 ; let initialY = 0 ; draggableItemsContainer . addEventListener ( 'touchstart' , ( e ) => { initialX = e . touches [ 0 ]. clientX ; initialY = e . touches [ 0 ]. clientY ; }); draggableItemsContainer . addEventListener ( 'touchmove' , ( e ) => { const x = e . touches [ 0 ]. clientX - initialX ; const y = e . touches [ 0 ]. clientY - initialY ; e . target . style . transform = \"translate(\" + x + \"px, \" + y + \"px)\" ; }); draggableItemsContainer . addEventListener ( 'touchend' , ( e ) => { e . target . style . transform = \"\" ; }); } initTouch (); Mit dem touchstart Event sollen die initialen x/y Koordinaten des Fingers gespeichert werden. Zu jedem touchmove Event soll die Transformation des HTML-Elements \u00fcber die Differenz der initialen Position des Fingers zur aktuellen Position des Fingers berechnet werden. Im touchend Event soll die Transformation wieder auf ihren Ursprungszustand zur\u00fcckgesetzt werden. HTML-Element tauschen (Touch-basiert) Um das Tauschen der HTML-Elemente durchzuf\u00fchren, muss im touchend Event das HTML-Element detektiert werden, welches unterhalb des Fingers liegt (aka Drop-Target im Fall von Drag and Drop). Dazu gibt es die hilfreiche DOM-API Funktion document.elementsFromPoint(x, y) . Mit dieser Funktion kann \u00fcber die Angabe einer beliebigen x/y Koordinate das entsprechende HTML-Element, welches sich an dieser Position befindet abgefragt werden. Dazu wird eine Variable lastX bzw. lastY eingef\u00fchrt. Diese wird innerhalb jedes touchmove Events gesetzt. Damit k\u00f6nnen wir im touchend die letzte Position des Fingers (als er noch am Display war) bestimmen. Mit der Funktion elementsFromPoint und den letzten bekannten x/y Koordinaten kann letzlich das HTML-Element, welches in als Drop-Target fungiert bestimmt werden. Der gesamte Quellcode der initTouch Funktion findet sich nun unten: function initTouch () { const draggableItemsContainer = document . querySelector ( 'ul' ); let initialX = 0 ; let initialY = 0 ; let lastX = 0 ; let lastY = 0 ; draggableItemsContainer . addEventListener ( 'touchstart' , ( e ) => { initialX = e . touches [ 0 ]. clientX ; initialY = e . touches [ 0 ]. clientY ; }); draggableItemsContainer . addEventListener ( 'touchmove' , ( e ) => { const x = e . touches [ 0 ]. clientX - initialX ; const y = e . touches [ 0 ]. clientY - initialY ; lastX = e . touches [ 0 ]. clientX ; lastY = e . touches [ 0 ]. clientY ; e . target . style . transform = \"translate(\" + x + \"px, \" + y + \"px)\" ; }); draggableItemsContainer . addEventListener ( 'touchend' , ( e ) => { const elementList = document . elementsFromPoint ( lastX , lastY ) if ( elementList . length > 1 && elementList [ 1 ]. hasAttribute ( 'draggable' )) { // die swapItems Funktion wurde bereits in Aufgabe 1b von Ihnen erstellt swapItems ( e . target . dataset . index , elementList [ 1 ]. dataset . index ); } e . target . style . transform = \"translate(0px, 0px)\" ; }); } initTouch (); Um die Funktionalit\u00e4t des Touch-Handlings \u00e4hnlich zum Drag and Drop herzustellen, m\u00fcssen noch einige Kleinigkeiten gel\u00f6st werden. Dazu sollen die Aufgaben 2a, 2b und 2c abgearbeitet werden. Aufgabe 2a Mit dem touchstart soll die CSS-Klasse dragged am gezogenen HTML-Element gesetzt werden. Mit dem touchend Event soll diese Klasse wieder entfernt werden. Dies soll einen \u00e4hnlichen Effekt zeigen wie im Drag and Drop Beispiel. Aufgabe 2b Die CSS-Klasse dragover soll ebenfalls bei den HTML-Elementen gesetzt werden, \u00fcber welche das gezogenen HTML-Element f\u00e4hrt. Dabei muss im touchmove Event das HTML-Element bestimmt werden, \u00fcber das gerade gezogen wird. Dazu kann wiederum die bekannte Funktion elementsFromPoint verwendet werden. Es gibt kein dragenter bzw. dragleave Event, welches im Touch-Handling verf\u00fcgbar ist. Sie m\u00fcssen sich eine entsprechende Logik \u00fcberlegen, wie innerhalb des touchmove Events die CSS-Klasse dragover gesetzt bzw. entfernt wird, sodass der entsprechende Effekt gew\u00e4hrleistet ist. Aufgabe 2c Am Smartphone bzw. Tablet soll im JavaScript die Funktion initTouch ausgef\u00fchrt werden, sodass das Drag and Drop funktioniert. Am Desktop bzw. Laptop soll die Funktion initDragAndDrop ausgef\u00fchrt werden. Die entsprechenden Funktionen m\u00fcssen also konditional geladen werden, jenachdem welche Funktionen der Web-Browser unterst\u00fctzt (Touch-Handling oder Drag and Drop). Recherchieren Sie einen geeigneten Weg um dies zu bewerkstelligen.","title":"Draggable Grid"},{"location":"mobile-web/draggable-grid/#draggable-grid","text":"In diesem Projekt soll ein Responsive Grid erstellt werden, welcher sich an die gegebenen Bildschirmgr\u00f6\u00dfen anpasst. Die Anordnung der Elemente des Grid sollen \u00fcber Drag und Drop ver\u00e4ndert werden k\u00f6nnen. Das Projekt soll sowohl f\u00fcr Desktops als auch f\u00fcr Smartphones nutzbar sein.","title":"Draggable Grid"},{"location":"mobile-web/draggable-grid/#projekt-setup","text":"Erstellen Sie einen leeren Projektordner auf Ihrem Rechner die Bennenung ist grunds\u00e4tzlich egal, jedoch draggable-grid w\u00fcrde sich anbieten. Innerhalb des Ordners erstellen Sie eine Datei package.json . Als Inhalt der Datei f\u00fcgen Sie 2 geschweifte Klammern ein: {} Installieren Sie einen Web-Server zur lokalen Entwicklung mit npm i http-server --save-dev . Nach der Installation k\u00f6nnen Sie ein script in der Datei package.json hinzuf\u00fcgen um den Web-Server zu starten. Das finale package.json sollte folgenden Inhalt aufweisen: { \"scripts\" : { \"start\" : \"http-server docs -p 8080\" }, \"devDependencies\" : { \"http-server\" : \"^0.12.3\" } } Es soll noch ein Ordner docs erstellt werden, welcher alle Projektdateien enh\u00e4lt. Durch die Ausf\u00fchrung von npm start kann nun die lokale Entwicklung begonnen werden. Hinweis F\u00fcr ein Deployment auf Github Pages sollten alle Dateien, welche zur App geh\u00f6ren im Ordner docs liegen. Dieser Ordner wird dann \u00fcber einen Web-Server \u00f6ffentlich bereitgestellt.","title":"Projekt Setup"},{"location":"mobile-web/draggable-grid/#htmlcss","text":"Die Benutzerschnittstelle ist sehr einfach gehalten. Im folgenden findet sich das HTML-Dokument und das zugeh\u00f6rige CSS-Stylesheet um das Responsive Grid zu erstellen. <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < title > Draggable Grid </ title > < link rel = \"stylesheet\" href = \"style.css\" > </ head > < body > < h1 > Draggable Grid </ h1 > < ul > < li data-index = \"1\" > One </ li > < li data-index = \"2\" > Two </ li > < li data-index = \"3\" > Three </ li > < li data-index = \"4\" > Four </ li > < li data-index = \"5\" > Five </ li > < li data-index = \"6\" > Six </ li > </ ul > </ body > </ html > body { font-family : sans-serif ; margin : 0 ; } h1 { font-size : 18 px ; text-align : center ; } ul { padding : 20 px ; display : grid ; grid-template-columns : repeat ( auto -fit , minmax ( 280 px , 1 fr )); column-gap : 15 px ; row-gap : 15 px ; justify-content : center ; } @ media ( min-width : 992px ) { ul { grid-template-columns : repeat ( 3 , minmax ( 200 px , 400 px )); } } li { list-style : none ; padding : 10 px ; border-radius : 5 px ; border : 1 px solid DarkTurquoise ; background : LightCyan ; cursor : grab ; } Diese beiden Quellcodeabschnitte sind jeweils in die Datei docs/index.html bzw. docs/style.css zu kopieren.","title":"HTML/CSS"},{"location":"mobile-web/draggable-grid/#draggable","text":"Um HTML-Elemente als draggable zu definieren, reicht es grunds\u00e4tzlich aus, dass Attribut draggable und den Wert true zu setzen. Dies soll f\u00fcr die li Elemente durchgef\u00fchrt werden: < li draggable = \"true\" data-index = \"1\" > One </ li > < li draggable = \"true\" data-index = \"2\" > Two </ li > < li draggable = \"true\" data-index = \"3\" > Three </ li > <!-- ... -->","title":"Draggable"},{"location":"mobile-web/draggable-grid/#drag-events","text":"HTML-Elemente die als draggable definiert sind, erzeugen wichtige Events, welche \u00fcber JavaScript abfragbar sind. In der folgenden Tabelle sind die wichtigsten Events aufgef\u00fchrt. Als Target wird das HTML-Element bezeichnet, welches sich im JavaScript Event in der Eigenschaft target befindet. Event Target Beschreibung drag Gezogenes HTML-Element Dieses Event wird alle paar Millisekunden getriggert, wenn das HTML-Element von der Benutzerin gezogen wird. Wichtige Eigenschaften wie die x/y Koordinaten des Mauszeigers befinden sich in diesem Event dragstart Gezogenes HTML-Element Die Benutzerin beginnt die Drag and Drop Operation dragend Gezogenes HTML-Element Die Benutzerin beendet die Drag and Drop Operation (zum Beispiel loslassen des Mouse-Button am Desktop) dragenter Drop-Target HTML-Element Die Benutzerin zieht ein draggable HTML-Element \u00fcber ein Drop-Target dragleave Drop-Target HTML-Element Die Benutzerin zieht ein draggable HTML-Element aus dem Bereich eines Drop-Target dragover Drop-Target HTML-Element Falls die Benutzerin ein draggable HTML-Element \u00fcber ein Drop-Target zieht, wird alle paar Millisekunden das dragover Event mit genauen x/y Koordinaten der Mauszeiger erzeugt drop Drop-Target HTML-Element Dieses Event wird erzeugt, wenn die Drag and Drop Operation auf einem Drop-Target beendet wird Hinweis Ein HTML-Element wird grunds\u00e4tzlich zum Drop-Target , wenn es das Attribut draggable besitzt.","title":"Drag Events"},{"location":"mobile-web/draggable-grid/#drag-start-und-drag-end","text":"Zur Demonstration des dragstart bzw. dragend Events soll eine CSS-Klasse auf dem HTML-Element gesetzt werden, welches sich in einer Drag and Drop Operation befindet. Dazu soll im ersten Schritt die CSS-Klasse dragged im CSS-Stylestheet hinzugef\u00fcgt werden: /* ... */ . dragged { opacity : 30 % ; } Zus\u00e4tzlich soll eine index.js Datei erzeugt werden, welche das notwendige JavaScript enth\u00e4lt. Die JavaScript Datei soll \u00fcber ein script Tag im HTML-Head eingebunden werden: <!-- ... --> < head > <!-- ... --> < script defer src = \"index.js\" ></ script > </ head > <!-- ... --> Als Inhalt der JavaScript Datei soll folgendes hinzugef\u00fcgt werden: const draggableItemsContainer = document . querySelector ( 'ul' ); draggableItemsContainer . addEventListener ( 'dragstart' , ( e ) => { e . target . classList . add ( 'dragged' ); }); draggableItemsContainer . addEventListener ( 'dragend' , ( e ) => { e . target . classList . remove ( 'dragged' ); }); Im Skript wird das Elternelement der draggable HTML-Elemente selektiert. Es wird der EventListener dragstart oder dragend gesetzt, welcher die CSS-Klasse dragged am Event Target setzt oder entfernt.","title":"Drag Start und Drag End"},{"location":"mobile-web/draggable-grid/#drag-enter-und-drag-leave","text":"Am Drop-Target soll ebenfalls eine CSS-Style\u00e4nderung durchgef\u00fchrt werden, wenn eine Drag and Drop Operation \u00fcber dem HTML-Element durchgef\u00fchrt wird. Es soll die CSS-Klasse dragover erstellt werden. Diese CSS-Klasse soll \u00fcber die Events dragenter bzw. dragleave am Drop-Target \"getoggled\" werden. /* ... */ . dragover { border : 1 px dotted OrangeRed ; background : Coral ; } Die \u00c4nderung der CSS-Klasse soll dabei nur durchgef\u00fchrt werden, wenn das Event Target ein index Attribut im Dataset definiert hat. Dies wurde f\u00fcr alle draggable HTML-Elemente bereits definiert. Ansonsten w\u00fcrden alle m\u00f6glichen HTML-Elemente, \u00fcber welche das HTML-Element gezogen wird mit der CSS-Klasse ausgestattet. // ... draggableItemsContainer . addEventListener ( 'dragenter' , ( e ) => { if ( e . target . dataset . index ) { e . target . classList . add ( 'dragover' ); } }); draggableItemsContainer . addEventListener ( 'dragleave' , ( e ) => { if ( e . target . dataset . index ) { e . target . classList . remove ( 'dragover' ); } });","title":"Drag Enter und Drag Leave"},{"location":"mobile-web/draggable-grid/#drag-over-und-drop","text":"Damit das entsprechende Drop Event ausgef\u00fchrt wird und die HTML-Elemente entsprechend getauscht werden, m\u00fcssen EventListener f\u00fcr dragover und drop hinzugef\u00fcgt werde. Damit das drop Event korrekt ausgef\u00fchrt wird, muss f\u00fcr das dragover Event die Function preventDefault ausgef\u00fchrt werden. Nur in diesem Fall erlaub der Web-Browser drop Events. Um im drop Event, welches auf dem Drop-Target ausgef\u00fchrt wird, das gezogene HTML-Element anzufragen, soll im dragstart der data-index vom gezogenen HTML-Element innerhalb des DataTransfer Objektes mitgeben werden. Hinweis Das DataTransfer Objekt k\u00f6nnte zB auch eine Datei enthalten, welche am Desktop vom Datei-Explorer in den Web-Browser gezogen wird (per Drag and Drop). Im datastart Event soll am entsprechenden DataTransfer Objekt \u00fcber die Methode setData der data-index des gezogenen HTML-Elements hinzugef\u00fcgt werden. Die setData Methode verlangt als ersten Parameter den Mime-Type des 2. Parameters. In diesem Fall handelt es sich um Plaintext. Falls es sich um ein Bild handeln w\u00fcrde, k\u00f6nnte zB image/jpg als Mime-Type angegeben werden. Im drop Event kann dann der Wert, welcher im DataTransfer Objekt gesetzt wurde wieder abgefrag werden. Somit k\u00f6nnen beide Indizes (vom gezogenen HTML-Element und vom Drop-Target ) abgefragt werden. Mit den beiden Indizes Werten kann im folgenden die \u00c4nderung im DOM vorgenommen werden, sodass eben die beiden HTML-Elemente ausgetauscht werden. draggableItemsContainer . addEventListener ( 'dragstart' , ( e ) => { e . dataTransfer . setData ( 'text/plain' , e . target . dataset . index ); // data-index e . target . classList . add ( 'dragged' ); }); // ... draggableItemsContainer . addEventListener ( 'dragover' , ( e ) => { e . preventDefault (); }); draggableItemsContainer . addEventListener ( 'drop' , ( e ) => { e . preventDefault (); const index1 = e . dataTransfer . getData ( 'text/plain' ); const index2 = e . target . dataset . index ; // TODO: HTML-Elemente tauschen });","title":"Drag Over und Drop"},{"location":"mobile-web/draggable-grid/#aufgabe-1a","text":"Das HTML-Element, welches gerade gezogen wird, soll beim dragenter Event die CSS-Klasse dragover nicht gesetzt bekommen.","title":"Aufgabe 1a"},{"location":"mobile-web/draggable-grid/#aufgabe-1b","text":"Im drop Event wurde ein TODO hinterlegt, welches die beiden \u00fcber die entsprechenden data-index Attribute identifizierbaren HTML-Elemente tauschen soll. Erstellen Sie dazu eine globale Funktion swapItems , welche die beiden Indizes index1 und index2 \u00fcbergeben bekommt. Die Funktion soll dann die beiden HTML-Elemente im DOM austauschen. Dabei sollte nicht nur der Textinhalt getauscht werden, sondern tats\u00e4chlich die HTML-Elemente. Hinweis: F\u00fcr die DOM-API gibt es eine Vielzahl hilfreicher Funktionen, welche generell f\u00fcr \u00c4nderungen im DOM verwendet werden k\u00f6nnen. Im konkreten Fall, gibt es Funktionen wie zB insertAdjacentElement , appendChild oder removeChild , welche hier n\u00fctzlich sein k\u00f6nnen. Ebenfalls gibt es zum jeweiligen DOM-Knoten (aka HTML-Element) wichtige und n\u00fctzliche Attribute, im konkreten Fall zum Beispiel previousElementSibling oder nextElementSibling .","title":"Aufgabe 1b"},{"location":"mobile-web/draggable-grid/#ausfuhrung-am-smartphone","text":"Wenn die Web-Applikation auf Github gestellt wird und dort \u00fcber Github Pages deployed wird, wird ersichtlich, dass das Drag and Drop nicht am Smartphone funktioniert. Leider funktioniert die aktuelle Implementierung nur f\u00fcr Desktop Browser, dass h\u00e4tte man vielleicht am Beginn des Tutorials bereits erw\u00e4hnen sollen .","title":"Ausf\u00fchrung am Smartphone"},{"location":"mobile-web/draggable-grid/#touch-events","text":"Der Web-Browser ist multitouchf\u00e4hig. Das bedeutet, dass jeder Finger am Display einzeln abgebildet werden kann. Jeder Finger ist als Touch Objekt repr\u00e4sentiert. Am Touch Objekt wird \u00fcber die Eigenschaften clientX bzw. clientY die Koordinaten des Fingers am Display angegeben. Ensprechend des Verhaltens der Finger am Display sind unterschiedliche Events definiert: Event Beschreibung touchstart Ein Finger ist auf das Display gelegt worden, am entsprechenden HTML-Element wird das touchstart Event ausgel\u00f6st touchend Ein Finger ist vom Display entfernt worden, am entsprechenden HTML-Element wird das touchend Event ausgel\u00f6st touchmove Ein Finger am Display wird bewegt touchcancel Der Touch-Vorgang wurde unsachgem\u00e4\u00df beendet, zum Beispiel wurde der Finger \u00fcber das Display hinausgezogen","title":"Touch Events"},{"location":"mobile-web/draggable-grid/#html-element-bewegen-touch-basiert","text":"\u00c4hnlich zum klassischen Drag and Drop werden f\u00fcr das Touch Handling die EventListener ebenfalls am Elternelement ul gesetzt. Im ersten Schritt ist es wichtig zu verstehen, wie ein HTML-Element bewegt werden kann. Eine effiziente Form kann \u00fcber die CSS-Eigenschaft transform mit dem Wert translate(x,y) durchgef\u00fchrt werden. Dies kann eben unter anderem \u00fcber JavaScript durchgef\u00fchrt werden. Folgender Javascript Quellcode w\u00fcrde ein bestehendes HTML-Element 15px nach rechts und 15px nach oben verschieben. W\u00e4hlen Sie dazu ein beliebiges HTML-Element einer Website \u00fcber die Web-Entwickler Werkzeuge aus und f\u00fcgen Sie in der Konsole folgendes JavaScript ein: $0 . style . transform = \"translate(15px, -15px)\" ; Wichtig zu verstehen ist, dass der Platz an dem das HTML-Element vor dem Transformationsschritt gezeichnet wurde frei bleibt. Die umliegenden HTML-Element f\u00fcllen den leeren Platz nicht auf. Das transformierte HTML-Element \u00fcberdeckt die umliegenden HTML-Elemente. Aus diesem Grund ist generell nur die Composite Phase des Rendering Vorgangs im Web-Browser notwendig. Die Bewegung \u00fcber JavaScript w\u00fcrde so enstehen, dass bei jedem touchmove Event die x/y Koordinaten f\u00fcr die Transformation am zu bewegenden HTML-Element ( translate(x, y) ) angepasst wird. Die x bzw. y Werte f\u00fcr die translate Funktion sollen dabei immer als Differenz zum initialen Wert der x/y Koordinaten des Touch Events gesetzt werden. Dies soll hoffentlich \u00fcber die unten angef\u00fchrte Grafik verst\u00e4ndlich gemacht werden: Der gesamte Drag and Drop Quellcode aus den vorangegangenen Abschnitten soll innerhalb einer Funktion initDragAndDrop hinterlegt werden. Die von Ihnen entwickelte globale Funktion swapItems soll nicht innerhalb der initDragAndDrop gesetzt werden, diese wird auch im Touch Handling wiederverwendet. Vorerst soll nur die initTouch Funktion ausgef\u00fchrt werden. function initDragAndDrop () { const draggableItemsContainer = document . querySelector ( 'ul' ); // ... // Drag and Drop Quellcode aus dem vorangegangenen Abschnitten // hier einf\u00fcgen } function initTouch () { const draggableItemsContainer = document . querySelector ( 'ul' ); let initialX = 0 ; let initialY = 0 ; draggableItemsContainer . addEventListener ( 'touchstart' , ( e ) => { initialX = e . touches [ 0 ]. clientX ; initialY = e . touches [ 0 ]. clientY ; }); draggableItemsContainer . addEventListener ( 'touchmove' , ( e ) => { const x = e . touches [ 0 ]. clientX - initialX ; const y = e . touches [ 0 ]. clientY - initialY ; e . target . style . transform = \"translate(\" + x + \"px, \" + y + \"px)\" ; }); draggableItemsContainer . addEventListener ( 'touchend' , ( e ) => { e . target . style . transform = \"\" ; }); } initTouch (); Mit dem touchstart Event sollen die initialen x/y Koordinaten des Fingers gespeichert werden. Zu jedem touchmove Event soll die Transformation des HTML-Elements \u00fcber die Differenz der initialen Position des Fingers zur aktuellen Position des Fingers berechnet werden. Im touchend Event soll die Transformation wieder auf ihren Ursprungszustand zur\u00fcckgesetzt werden.","title":"HTML-Element bewegen (Touch-basiert)"},{"location":"mobile-web/draggable-grid/#html-element-tauschen-touch-basiert","text":"Um das Tauschen der HTML-Elemente durchzuf\u00fchren, muss im touchend Event das HTML-Element detektiert werden, welches unterhalb des Fingers liegt (aka Drop-Target im Fall von Drag and Drop). Dazu gibt es die hilfreiche DOM-API Funktion document.elementsFromPoint(x, y) . Mit dieser Funktion kann \u00fcber die Angabe einer beliebigen x/y Koordinate das entsprechende HTML-Element, welches sich an dieser Position befindet abgefragt werden. Dazu wird eine Variable lastX bzw. lastY eingef\u00fchrt. Diese wird innerhalb jedes touchmove Events gesetzt. Damit k\u00f6nnen wir im touchend die letzte Position des Fingers (als er noch am Display war) bestimmen. Mit der Funktion elementsFromPoint und den letzten bekannten x/y Koordinaten kann letzlich das HTML-Element, welches in als Drop-Target fungiert bestimmt werden. Der gesamte Quellcode der initTouch Funktion findet sich nun unten: function initTouch () { const draggableItemsContainer = document . querySelector ( 'ul' ); let initialX = 0 ; let initialY = 0 ; let lastX = 0 ; let lastY = 0 ; draggableItemsContainer . addEventListener ( 'touchstart' , ( e ) => { initialX = e . touches [ 0 ]. clientX ; initialY = e . touches [ 0 ]. clientY ; }); draggableItemsContainer . addEventListener ( 'touchmove' , ( e ) => { const x = e . touches [ 0 ]. clientX - initialX ; const y = e . touches [ 0 ]. clientY - initialY ; lastX = e . touches [ 0 ]. clientX ; lastY = e . touches [ 0 ]. clientY ; e . target . style . transform = \"translate(\" + x + \"px, \" + y + \"px)\" ; }); draggableItemsContainer . addEventListener ( 'touchend' , ( e ) => { const elementList = document . elementsFromPoint ( lastX , lastY ) if ( elementList . length > 1 && elementList [ 1 ]. hasAttribute ( 'draggable' )) { // die swapItems Funktion wurde bereits in Aufgabe 1b von Ihnen erstellt swapItems ( e . target . dataset . index , elementList [ 1 ]. dataset . index ); } e . target . style . transform = \"translate(0px, 0px)\" ; }); } initTouch (); Um die Funktionalit\u00e4t des Touch-Handlings \u00e4hnlich zum Drag and Drop herzustellen, m\u00fcssen noch einige Kleinigkeiten gel\u00f6st werden. Dazu sollen die Aufgaben 2a, 2b und 2c abgearbeitet werden.","title":"HTML-Element tauschen (Touch-basiert)"},{"location":"mobile-web/draggable-grid/#aufgabe-2a","text":"Mit dem touchstart soll die CSS-Klasse dragged am gezogenen HTML-Element gesetzt werden. Mit dem touchend Event soll diese Klasse wieder entfernt werden. Dies soll einen \u00e4hnlichen Effekt zeigen wie im Drag and Drop Beispiel.","title":"Aufgabe 2a"},{"location":"mobile-web/draggable-grid/#aufgabe-2b","text":"Die CSS-Klasse dragover soll ebenfalls bei den HTML-Elementen gesetzt werden, \u00fcber welche das gezogenen HTML-Element f\u00e4hrt. Dabei muss im touchmove Event das HTML-Element bestimmt werden, \u00fcber das gerade gezogen wird. Dazu kann wiederum die bekannte Funktion elementsFromPoint verwendet werden. Es gibt kein dragenter bzw. dragleave Event, welches im Touch-Handling verf\u00fcgbar ist. Sie m\u00fcssen sich eine entsprechende Logik \u00fcberlegen, wie innerhalb des touchmove Events die CSS-Klasse dragover gesetzt bzw. entfernt wird, sodass der entsprechende Effekt gew\u00e4hrleistet ist.","title":"Aufgabe 2b"},{"location":"mobile-web/draggable-grid/#aufgabe-2c","text":"Am Smartphone bzw. Tablet soll im JavaScript die Funktion initTouch ausgef\u00fchrt werden, sodass das Drag and Drop funktioniert. Am Desktop bzw. Laptop soll die Funktion initDragAndDrop ausgef\u00fchrt werden. Die entsprechenden Funktionen m\u00fcssen also konditional geladen werden, jenachdem welche Funktionen der Web-Browser unterst\u00fctzt (Touch-Handling oder Drag and Drop). Recherchieren Sie einen geeigneten Weg um dies zu bewerkstelligen.","title":"Aufgabe 2c"},{"location":"mobile-web/fx-calculator/","text":"Fx Calculator Fx Calculator ist eine einfache PWA um W\u00e4hrungen umzurechnen. Projekt Setup Erstellen Sie einen leeren Projektordner auf Ihrem Rechner die Bennenung ist grunds\u00e4tzlich egal, jedoch fx-calculator w\u00fcrde sich anbieten. Innerhalb des Ordners erstellen Sie eine Datei package.json . Als Inhalt der Datei f\u00fcgen Sie 2 geschweifte Klammern ein: {} Installieren Sie einen Web-Server zur lokalen Entwicklung mit npm i http-server --save-dev . Nach der Installation k\u00f6nnen Sie ein script in der Datei package.json hinzuf\u00fcgen um den Web-Server zu starten. Das finale package.json sollte folgenden Inhalt aufweisen: { \"scripts\" : { \"start\" : \"http-server docs -p 8080\" }, \"devDependencies\" : { \"http-server\" : \"^0.12.3\" } } Es soll noch ein Ordner docs erstellt werden, welcher alle Projektdateien enh\u00e4lt. Durch die Ausf\u00fchrung von npm start kann nun die lokale Entwicklung begonnen werden. Hinweis F\u00fcr ein Deployment auf Github Pages sollten alle Dateien, welche zur App geh\u00f6ren im Ordner docs liegen. Dieser Ordner wird dann \u00fcber einen Web-Server \u00f6ffentlich bereitgestellt. Es soll ebenfalls 3 Bilder ( Icon 1 , Icon 2 , Icon 3 ) heruntergeladen werden und im Ordner docs abgelegt werden. HTML/CSS Die Benutzerschnittstelle ist sehr einfach gehalten. Im folgenden findet sich das HTML-Dokument und das zugeh\u00f6rige CSS-Stylesheet: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < meta name = \"description\" content = \"FX-Calculator Demo PWA\" > < title > Fx Calculator PWA </ title > < link rel = \"stylesheet\" href = \"style.css\" > </ head > < body > < main > < h1 > Fx Calculator </ h1 > < section > < label for = \"input-value\" > Input </ label > < input id = \"input-value\" type = \"number\" name = \"input-value\" > < select title = \"Input Currency\" name = \"input-currency\" ></ select > </ section > < section > < label for = \"output-value\" > Output </ label > < input id = \"output-value\" name = \"output-value\" readonly > < select title = \"Output Currency\" id = \"output-currency\" name = \"output-currency\" ></ select > </ section > < button > Calculate </ button > </ main > </ body > </ html > body { margin : 0 ; background : #ccffcc ; font-family : sans-serif ; } h1 { text-align : center ; } main { padding : 10 px ; } section { border : 1 px solid black ; padding : 5 px ; margin-bottom : 5 px ; display : flex ; justify-content : space-between ; align-items : center ; } section label { flex : 0 0 60 px ; } section input { flex : 1 1 100 % ; padding : 4 px ; border : 1 px solid #aaa ; border-right : none ; outline : none ; } section select { flex : 0 0 60 px ; padding : 3 px ; border : 1 px solid #aaa ; border-left : none ; } button { border : 1 px solid black ; background : white ; width : 100 % ; padding : 8 px ; } Diese beiden Quellcodeabschnitte sind jeweils in die Datei docs/index.html bzw. docs/style.css zu kopieren. Verhalten Dropdown Inhalt f\u00fcllen Es gibt zwei Dropdowns ( select ), welche noch keine Inhalte ( option ) haben. Da die beiden Dropdowns dieselben Inhalte haben, k\u00f6nnen diese dynamisch gef\u00fcllt werden. Mit der Funktion querySelectorAll sollen alle Dropdowns ausgew\u00e4hlt werden. querySelectorAll liefert eine NodeList als Resultat. Mit der Funktion forEach der NodeList kann durch die Ergebnismenge iteriert werden. \u00dcber die Eigenschaft innerHTML wird der HTML-Inhalt des entsprechenden Elements angegeben. document . querySelectorAll ( 'select' ). forEach ( element => { element . innerHTML = ` <option value=\"EUR\">EUR</option> <option value=\"USD\">USD</option> <option value=\"CHF\">CHF</option> <option value=\"SEK\">SEK</option> ` ; }); Funktion zur W\u00e4hrungsumrechnung Um aktuelle W\u00e4hrungskurse abzufragen kann die Fixer API verwendet werden. In der Dokumentation wird der Latest Rates Endpoint beschrieben, welcher im Kontext des W\u00e4hrungsrechners verwendet werden kann. Die Struktur des Endpoints sieht so aus, dass base eine Ausgangsw\u00e4hrung und als symbols Zielw\u00e4hrungen angegeben werden k\u00f6nnen: https://data.fixer.io/api/latest?base=EUR&symbols=USD,SEK,CHF&access_key=API_KEY Das Ergebnis des Aufrufes sieht folgenderma\u00dfen aus: { \"success\" : true , \"timestamp\" : 1591604165 , \"base\" : \"EUR\" , \"date\" : \"2020-06-08\" , \"rates\" : { \"USD\" : 1.130998 , \"SEK\" : 10.395589 , \"CHF\" : 1.088433 } } Da die Fixer API mittlerweile einen API-Key ben\u00f6tigt und ab 1000 Aufrufen/Monat kostenpflichtig ist, soll die API gemockt werden. Dazu kann einfach eine Antwort der API als JSON-Dokument abgelegt und anstelle der richtigen API abgefragt werden. Es sollte dazu eine Datei docs/fixer.json angelegt werden und das JSON-Beispiel von oben hineikopiert werden. // const fixerUri = 'https://data.fixer.io/api/latest?base=EUR&symbols=USD,SEK,CHF&access_key=API_KEY'; const fixerUri = \"fixer.json\" ; Um nun die tats\u00e4chliche W\u00e4hrungsumrechnung durchzuf\u00fchren soll eine Function convert erstellt werden. Da diese Funktion immer den aktuellen W\u00e4hrungskurs \u00fcber die API abfragen soll, wird diese als async deklariert. Als \u00dcbergabeparameter bekommt die Funktion den Ausgangswert ( inputValue ), die Ausgangsw\u00e4hrung ( inputCurrency ) und die Zielw\u00e4hrung ( outputCurrency ). Als R\u00fcckgabewert soll die Funktion den Ausgangswert in die Zielw\u00e4hrung umrechnen. Da die Funktion als async deklariert ist, kann await f\u00fcr asynchrone Aufrufe wie zum Beispiel fetch verwendet werden. Im ersten Schritt wird also die W\u00e4hrungskurse \u00fcber die Fixer API abgefragt und der Response-Body (welcher als String repr\u00e4sentiert ist) in JSON umgewandelt ( response.json() ). Der Rest der Funktion f\u00fchrt die W\u00e4hrungsumrechnung durch: async function convert ( inputValue , inputCurrency , outputCurrency ) { const response = await fetch ( fixerUri ); const data = await response . json (); const rates = data [ 'rates' ]; rates [ \"EUR\" ] = 1. ; return inputValue / rates [ inputCurrency ] * rates [ outputCurrency ]; } Um das Runden von W\u00e4hrungen auf fixe Dezimalstellen durchzuf\u00fchren wird noch eine round Funktion implementiert: function round ( value , decimals ) { return ( Math . round ( value * 100 ) / 100 ). toFixed ( decimals ); } Button Click Um nun die eigentliche Aufgabe der App zu realisieren wird ein EventListener f\u00fcr das Click-Event auf dem Button registriert. Der anonyme EventListener ist ebenfalls als async deklariert, da die Funktion convert mit await aufgerufen wird. document . querySelector ( 'button' ). addEventListener ( 'click' , async () => { const inputCurrency = document . querySelector ( '[name=\"input-currency\"]' ). value ; const outputCurrency = document . querySelector ( '[name=\"output-currency\"]' ). value ; const inputValue = document . querySelector ( '[name=\"input-value\"]' ). value ; const outputValue = await convert ( inputValue , inputCurrency , outputCurrency ); document . querySelector ( '[name=\"output-value\"]' ). value = round ( outputValue , 2 ); }); Die Funktion selektiert alle wichtigen Werte aus dem DOM, welche f\u00fcr die Berechnung wichtig sind ( inputCurrency , outputCurrency und inputValue ). Diese Parameter werden an die Funktion convert \u00fcbergeben und das Ergebnis wird am entsprechenden DOM-Element gesetzt. F\u00fcr eine sch\u00f6nere Darstellung wird noch die Funktion round genutzt, um den Zielbetrag auf 2 Dezimalstellen zu runden. Zwischenstand mit Lighthouse pr\u00fcfen Die App ist nun vollkommen funktionsf\u00e4hig umgesetzt. Die Pr\u00fcfung mit Lighthouse zeigt ebenfalls ein passables Bild: Die fehlenden 100 bei den Best Practices resultieren daher, dass der lokale Web-Server kein HTTP/2 unterst\u00fctz, dies wird \u00fcber ein Deployment auf zum Beipsiel Github Pages beseitigt. Die PWA hat 3 Aspekte, welche mit Lighthouse gepr\u00fcft werden: Fast and reliable Installable PWA Optimized Alle diese Aspekte sind derzeit noch unzureichend unters\u00fctzt. Web-App Manifest F\u00fcr Web-Apps welche am Homescreen installierbar sein sollen, muss ein Web-App Manifest erzeugt und im HTML verlinkt werden. Der Name des JSON-Dokuments soll manifest.webmanifest lauten. Das Web-App Manifest ist ein JSON-Dokument mit wichtigen Eigenschaften der App: Jede PWA ben\u00f6tigt zumindest ein Icon, es k\u00f6nnen f\u00fcr unterschiedliche Ansichten (zB Android Recents) weitere Icons angegeben werden ( icons ) Jede PWA ben\u00f6tigt einen Titel ( name ), dar\u00fcberhinaus kann auch ein Kurztitel als Abk\u00fcrzung angegeben werden ( short_name ) Es k\u00f6nnen Farbwerte f\u00fcr unterschiedliche Ansichten definiert werden ( background_color oder theme_color ) Mit display wird definiert, ob Teile des Web-Browsers noch angezeigt wreden sollen oder nicht. standalone bedeutet die Addressleiste wird versteckt. Mit start_url wird angegeben, welche URL der PWA ge\u00f6ffnet werden soll, wenn eine Benutzerin die App vom Homescreen startet. Mit scope wird angegeben, welche Pfade Teil der PWA sind und welche nicht. Mit / wird angegen das alles unter der Baseurl Teil der PWA ist. { \"name\" : \"Fx Calculator\" , \"short_name\" : \"Fx Calc\" , \"display\" : \"standalone\" , \"start_url\" : \".\" , \"scope\" : \"/\" , \"background_color\" : \"#cfc\" , \"theme_color\" : \"#cfc\" , \"description\" : \"Simple Fx Calculator based on fixer.io API\" , \"icons\" : [ { \"src\" : \"icon512.png\" , \"sizes\" : \"512x512\" , \"type\" : \"image/png\" }, { \"src\" : \"icon16.png\" , \"sizes\" : \"16x16\" , \"type\" : \"image/png\" , \"purpose\" : \"badge\" } ] } Weitere Details zum Manifest und die entsprechende Web-Browser Unterst\u00fctzung sollte im Mozilla Developer Network nachgeschlagen werden. Das oben gezeigte JSON soll in die Datei docs/manifest.webmanifest kopiert werden. Das Manifest soll im head des HTML-Dokumentes \u00fcber ein link eingebunden werden: < link rel = \"manifest\" href = \"manifest.webmanifest\" > Installable Die Installierbarkeit einer PWA ist sichergestellt, wenn ein Web-App Manifest vorliegt und ein Service Worker registriert ist. Der Service Worker kann auch eine leere JavaScript Datei sein. Es soll dazu eine leere sw.js Datei erstellt werden. Im HTML-Dokument soll des Weiteren ein Skript-Tag angegeben werden, welches die Registrierung des Service Workers enthalten soll. Mit if ('serviceWorker' in navigator) wird gepr\u00fcft ob die Service Worker Funktionalit\u00e4t im Web-Browser unterst\u00fctzt wird. < script > if ( 'serviceWorker' in navigator ) { navigator . serviceWorker . register ( 'sw.js' ); } </ script > PWA Optimized F\u00fcr diesen Aspekt m\u00fcssen einige allgemeine Einstellungen der PWA vorgenommen werden. F\u00fcr den Fx Calculator m\u00fcssen dazu noch ein Apple Touch Icon und eine Theme Color als Meta-Tag hinzugef\u00fcgt werden: < meta name = \"theme-color\" content = \"#ccffcc\" > < link rel = \"apple-touch-icon\" href = \"icon192.png\" > Um diesen Aspekt voll zu unters\u00fctzten wird HTTPs ben\u00f6tigt. Dies wird erst durch ein Deployment auf zum Beispiel Github Pages erm\u00f6glicht. Service Worker Implementierung Der Service Worker wurde \u00fcber die Datei sw.js registriert. Dabei gibt es 2 wichtige Events, welche vom Service Worker bearbeitet werden k\u00f6nnen: Install-Event: Dieses Event wird getriggert, wenn der Service-Worker das erstemal installiert wird. Dort k\u00f6nnen zum Beispiel alle Dateien, welche f\u00fcr die PWA ben\u00f6tigt werden bereits geladen und in einen Cache geladen werden. Fetch-Event: Dieses Event wird immer getriggert, wenn die App einen HTTP-Request triggert. Der Service Worker fungiert dabei \u00e4hnlich wie ein Proxy und es k\u00f6nnen beliebige Strategien implementiert werden. Install-Event Mit dem Schl\u00fcsselwort self wird der Service Worker referenziert und damit k\u00f6nnen EventListener registriert werden. Der EventListener bekommt dabei ein Event vom Typ InstallEvent , welches die Methode waitUntil aufweist. An die Methode waitUntil kann eine asynchrone Funktion \u00fcbergeben werden. Der Service Worker w\u00fcrde erst in den Status installed wechseln, wenn die \u00fcbergebenen Funktion ihre Aufgabe beendet hat. Im unten angef\u00fchrten Fall wird ein neuer Cache mit dem Namen fxcalc-v1 erzeugt und es werden \u00fcber die Methode addAll einige Ressourcen vom Netzwerk geladen und in den Cache gelegt. self . addEventListener ( 'install' , ( event ) => { event . waitUntil ( caches . open ( 'fxcalc-v1' ) . then ( cache => cache . addAll ([ 'index.html' , 'app.js' , 'icon512.png' , 'icon192.png' , 'icon16.png' , 'fixer.json' , 'manifest.webmanifest' ])) ); }); Hinweis Der Service Worker wird nicht im Main-Thread ausgef\u00fchrt und beeinflusst damit die Performance des Pageloads nicht. Am Besten sehen Sie sich dazu den Pageload im Performance-Tab der DevTools an. Wichtig ist dabei, dass Sie im Application-Tab der DevTools mit Clear Site Data alle Caches und sonstigen Daten l\u00f6schen. Fetch-Event Mit dem Fetch-Event kann die Strategie des Service Workers implementiert werden, welche verfolgt werden soll im Umgang mit Caching, Netzwerk-Optimierung und Offline-Verf\u00fcgbarkeit. Mit der Methode respondWith des Events kann dabei spezifiziert werden, welches Ergebnis vom Netzwerk an die Render Engine zur\u00fcckgegeben werden soll. Im folgenden wird folgende Strategie implementiert: Falls eine Netzwerkverbindung vorhanden ist, soll diese immer verwendet werden Eine Antwort vom Netzwerk soll immer gecacht werden, sodass sich immer der neueste Stand einer Ressource im Cache befindet Falls keine Netzwerkverbindung vorhanden ist, sollen Ressourcen aus dem Cache geladen werden self . addEventListener ( 'fetch' , ( event ) => { event . respondWith ( caches . open ( 'fxcalc-v1' ). then (( cache ) => { return fetch ( event . request ) . then (( response ) => { cache . put ( event . request , response . clone ()); return response ; }) . catch (() => cache . match ( event . request )); }) ); }); Hinweis Es k\u00f6nnen nat\u00fcrlich viele andere Service Worker Strategien implementiert werden. Die Website serviceworke.rs zeigt einige Strategien auf. Es k\u00f6nnen beliebige Strategien implementiert werden, welche nat\u00fcrlich komplett vom Use-Case abh\u00e4ngen. Finale Lighthouse Pr\u00fcfung Nachdem alle Komponenten der App inkl. Service Worker implementiert wurden, soll nun ein Deployment auf Github Pages stattfinden. Github Pages erm\u00f6glicht HTTP/2 und HTTPs , sodass alle offenen Punkte von Lighthouse behoben werden konnten. Das Ergebnis sollte folgenderma\u00dfen aussehen (inkl. Easteregg): Eine vollst\u00e4ndige L\u00f6sung des Projekt findet sich als App auf Github Pages sowie der Quellcode innerhalb eines Git-Repositories .","title":"Fx Calculator"},{"location":"mobile-web/fx-calculator/#fx-calculator","text":"Fx Calculator ist eine einfache PWA um W\u00e4hrungen umzurechnen.","title":"Fx Calculator"},{"location":"mobile-web/fx-calculator/#projekt-setup","text":"Erstellen Sie einen leeren Projektordner auf Ihrem Rechner die Bennenung ist grunds\u00e4tzlich egal, jedoch fx-calculator w\u00fcrde sich anbieten. Innerhalb des Ordners erstellen Sie eine Datei package.json . Als Inhalt der Datei f\u00fcgen Sie 2 geschweifte Klammern ein: {} Installieren Sie einen Web-Server zur lokalen Entwicklung mit npm i http-server --save-dev . Nach der Installation k\u00f6nnen Sie ein script in der Datei package.json hinzuf\u00fcgen um den Web-Server zu starten. Das finale package.json sollte folgenden Inhalt aufweisen: { \"scripts\" : { \"start\" : \"http-server docs -p 8080\" }, \"devDependencies\" : { \"http-server\" : \"^0.12.3\" } } Es soll noch ein Ordner docs erstellt werden, welcher alle Projektdateien enh\u00e4lt. Durch die Ausf\u00fchrung von npm start kann nun die lokale Entwicklung begonnen werden. Hinweis F\u00fcr ein Deployment auf Github Pages sollten alle Dateien, welche zur App geh\u00f6ren im Ordner docs liegen. Dieser Ordner wird dann \u00fcber einen Web-Server \u00f6ffentlich bereitgestellt. Es soll ebenfalls 3 Bilder ( Icon 1 , Icon 2 , Icon 3 ) heruntergeladen werden und im Ordner docs abgelegt werden.","title":"Projekt Setup"},{"location":"mobile-web/fx-calculator/#htmlcss","text":"Die Benutzerschnittstelle ist sehr einfach gehalten. Im folgenden findet sich das HTML-Dokument und das zugeh\u00f6rige CSS-Stylesheet: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < meta name = \"description\" content = \"FX-Calculator Demo PWA\" > < title > Fx Calculator PWA </ title > < link rel = \"stylesheet\" href = \"style.css\" > </ head > < body > < main > < h1 > Fx Calculator </ h1 > < section > < label for = \"input-value\" > Input </ label > < input id = \"input-value\" type = \"number\" name = \"input-value\" > < select title = \"Input Currency\" name = \"input-currency\" ></ select > </ section > < section > < label for = \"output-value\" > Output </ label > < input id = \"output-value\" name = \"output-value\" readonly > < select title = \"Output Currency\" id = \"output-currency\" name = \"output-currency\" ></ select > </ section > < button > Calculate </ button > </ main > </ body > </ html > body { margin : 0 ; background : #ccffcc ; font-family : sans-serif ; } h1 { text-align : center ; } main { padding : 10 px ; } section { border : 1 px solid black ; padding : 5 px ; margin-bottom : 5 px ; display : flex ; justify-content : space-between ; align-items : center ; } section label { flex : 0 0 60 px ; } section input { flex : 1 1 100 % ; padding : 4 px ; border : 1 px solid #aaa ; border-right : none ; outline : none ; } section select { flex : 0 0 60 px ; padding : 3 px ; border : 1 px solid #aaa ; border-left : none ; } button { border : 1 px solid black ; background : white ; width : 100 % ; padding : 8 px ; } Diese beiden Quellcodeabschnitte sind jeweils in die Datei docs/index.html bzw. docs/style.css zu kopieren.","title":"HTML/CSS"},{"location":"mobile-web/fx-calculator/#verhalten","text":"","title":"Verhalten"},{"location":"mobile-web/fx-calculator/#dropdown-inhalt-fullen","text":"Es gibt zwei Dropdowns ( select ), welche noch keine Inhalte ( option ) haben. Da die beiden Dropdowns dieselben Inhalte haben, k\u00f6nnen diese dynamisch gef\u00fcllt werden. Mit der Funktion querySelectorAll sollen alle Dropdowns ausgew\u00e4hlt werden. querySelectorAll liefert eine NodeList als Resultat. Mit der Funktion forEach der NodeList kann durch die Ergebnismenge iteriert werden. \u00dcber die Eigenschaft innerHTML wird der HTML-Inhalt des entsprechenden Elements angegeben. document . querySelectorAll ( 'select' ). forEach ( element => { element . innerHTML = ` <option value=\"EUR\">EUR</option> <option value=\"USD\">USD</option> <option value=\"CHF\">CHF</option> <option value=\"SEK\">SEK</option> ` ; });","title":"Dropdown Inhalt f\u00fcllen"},{"location":"mobile-web/fx-calculator/#funktion-zur-wahrungsumrechnung","text":"Um aktuelle W\u00e4hrungskurse abzufragen kann die Fixer API verwendet werden. In der Dokumentation wird der Latest Rates Endpoint beschrieben, welcher im Kontext des W\u00e4hrungsrechners verwendet werden kann. Die Struktur des Endpoints sieht so aus, dass base eine Ausgangsw\u00e4hrung und als symbols Zielw\u00e4hrungen angegeben werden k\u00f6nnen: https://data.fixer.io/api/latest?base=EUR&symbols=USD,SEK,CHF&access_key=API_KEY Das Ergebnis des Aufrufes sieht folgenderma\u00dfen aus: { \"success\" : true , \"timestamp\" : 1591604165 , \"base\" : \"EUR\" , \"date\" : \"2020-06-08\" , \"rates\" : { \"USD\" : 1.130998 , \"SEK\" : 10.395589 , \"CHF\" : 1.088433 } } Da die Fixer API mittlerweile einen API-Key ben\u00f6tigt und ab 1000 Aufrufen/Monat kostenpflichtig ist, soll die API gemockt werden. Dazu kann einfach eine Antwort der API als JSON-Dokument abgelegt und anstelle der richtigen API abgefragt werden. Es sollte dazu eine Datei docs/fixer.json angelegt werden und das JSON-Beispiel von oben hineikopiert werden. // const fixerUri = 'https://data.fixer.io/api/latest?base=EUR&symbols=USD,SEK,CHF&access_key=API_KEY'; const fixerUri = \"fixer.json\" ; Um nun die tats\u00e4chliche W\u00e4hrungsumrechnung durchzuf\u00fchren soll eine Function convert erstellt werden. Da diese Funktion immer den aktuellen W\u00e4hrungskurs \u00fcber die API abfragen soll, wird diese als async deklariert. Als \u00dcbergabeparameter bekommt die Funktion den Ausgangswert ( inputValue ), die Ausgangsw\u00e4hrung ( inputCurrency ) und die Zielw\u00e4hrung ( outputCurrency ). Als R\u00fcckgabewert soll die Funktion den Ausgangswert in die Zielw\u00e4hrung umrechnen. Da die Funktion als async deklariert ist, kann await f\u00fcr asynchrone Aufrufe wie zum Beispiel fetch verwendet werden. Im ersten Schritt wird also die W\u00e4hrungskurse \u00fcber die Fixer API abgefragt und der Response-Body (welcher als String repr\u00e4sentiert ist) in JSON umgewandelt ( response.json() ). Der Rest der Funktion f\u00fchrt die W\u00e4hrungsumrechnung durch: async function convert ( inputValue , inputCurrency , outputCurrency ) { const response = await fetch ( fixerUri ); const data = await response . json (); const rates = data [ 'rates' ]; rates [ \"EUR\" ] = 1. ; return inputValue / rates [ inputCurrency ] * rates [ outputCurrency ]; } Um das Runden von W\u00e4hrungen auf fixe Dezimalstellen durchzuf\u00fchren wird noch eine round Funktion implementiert: function round ( value , decimals ) { return ( Math . round ( value * 100 ) / 100 ). toFixed ( decimals ); }","title":"Funktion zur W\u00e4hrungsumrechnung"},{"location":"mobile-web/fx-calculator/#button-click","text":"Um nun die eigentliche Aufgabe der App zu realisieren wird ein EventListener f\u00fcr das Click-Event auf dem Button registriert. Der anonyme EventListener ist ebenfalls als async deklariert, da die Funktion convert mit await aufgerufen wird. document . querySelector ( 'button' ). addEventListener ( 'click' , async () => { const inputCurrency = document . querySelector ( '[name=\"input-currency\"]' ). value ; const outputCurrency = document . querySelector ( '[name=\"output-currency\"]' ). value ; const inputValue = document . querySelector ( '[name=\"input-value\"]' ). value ; const outputValue = await convert ( inputValue , inputCurrency , outputCurrency ); document . querySelector ( '[name=\"output-value\"]' ). value = round ( outputValue , 2 ); }); Die Funktion selektiert alle wichtigen Werte aus dem DOM, welche f\u00fcr die Berechnung wichtig sind ( inputCurrency , outputCurrency und inputValue ). Diese Parameter werden an die Funktion convert \u00fcbergeben und das Ergebnis wird am entsprechenden DOM-Element gesetzt. F\u00fcr eine sch\u00f6nere Darstellung wird noch die Funktion round genutzt, um den Zielbetrag auf 2 Dezimalstellen zu runden.","title":"Button Click"},{"location":"mobile-web/fx-calculator/#zwischenstand-mit-lighthouse-prufen","text":"Die App ist nun vollkommen funktionsf\u00e4hig umgesetzt. Die Pr\u00fcfung mit Lighthouse zeigt ebenfalls ein passables Bild: Die fehlenden 100 bei den Best Practices resultieren daher, dass der lokale Web-Server kein HTTP/2 unterst\u00fctz, dies wird \u00fcber ein Deployment auf zum Beipsiel Github Pages beseitigt. Die PWA hat 3 Aspekte, welche mit Lighthouse gepr\u00fcft werden: Fast and reliable Installable PWA Optimized Alle diese Aspekte sind derzeit noch unzureichend unters\u00fctzt.","title":"Zwischenstand mit Lighthouse pr\u00fcfen"},{"location":"mobile-web/fx-calculator/#web-app-manifest","text":"F\u00fcr Web-Apps welche am Homescreen installierbar sein sollen, muss ein Web-App Manifest erzeugt und im HTML verlinkt werden. Der Name des JSON-Dokuments soll manifest.webmanifest lauten. Das Web-App Manifest ist ein JSON-Dokument mit wichtigen Eigenschaften der App: Jede PWA ben\u00f6tigt zumindest ein Icon, es k\u00f6nnen f\u00fcr unterschiedliche Ansichten (zB Android Recents) weitere Icons angegeben werden ( icons ) Jede PWA ben\u00f6tigt einen Titel ( name ), dar\u00fcberhinaus kann auch ein Kurztitel als Abk\u00fcrzung angegeben werden ( short_name ) Es k\u00f6nnen Farbwerte f\u00fcr unterschiedliche Ansichten definiert werden ( background_color oder theme_color ) Mit display wird definiert, ob Teile des Web-Browsers noch angezeigt wreden sollen oder nicht. standalone bedeutet die Addressleiste wird versteckt. Mit start_url wird angegeben, welche URL der PWA ge\u00f6ffnet werden soll, wenn eine Benutzerin die App vom Homescreen startet. Mit scope wird angegeben, welche Pfade Teil der PWA sind und welche nicht. Mit / wird angegen das alles unter der Baseurl Teil der PWA ist. { \"name\" : \"Fx Calculator\" , \"short_name\" : \"Fx Calc\" , \"display\" : \"standalone\" , \"start_url\" : \".\" , \"scope\" : \"/\" , \"background_color\" : \"#cfc\" , \"theme_color\" : \"#cfc\" , \"description\" : \"Simple Fx Calculator based on fixer.io API\" , \"icons\" : [ { \"src\" : \"icon512.png\" , \"sizes\" : \"512x512\" , \"type\" : \"image/png\" }, { \"src\" : \"icon16.png\" , \"sizes\" : \"16x16\" , \"type\" : \"image/png\" , \"purpose\" : \"badge\" } ] } Weitere Details zum Manifest und die entsprechende Web-Browser Unterst\u00fctzung sollte im Mozilla Developer Network nachgeschlagen werden. Das oben gezeigte JSON soll in die Datei docs/manifest.webmanifest kopiert werden. Das Manifest soll im head des HTML-Dokumentes \u00fcber ein link eingebunden werden: < link rel = \"manifest\" href = \"manifest.webmanifest\" >","title":"Web-App Manifest"},{"location":"mobile-web/fx-calculator/#installable","text":"Die Installierbarkeit einer PWA ist sichergestellt, wenn ein Web-App Manifest vorliegt und ein Service Worker registriert ist. Der Service Worker kann auch eine leere JavaScript Datei sein. Es soll dazu eine leere sw.js Datei erstellt werden. Im HTML-Dokument soll des Weiteren ein Skript-Tag angegeben werden, welches die Registrierung des Service Workers enthalten soll. Mit if ('serviceWorker' in navigator) wird gepr\u00fcft ob die Service Worker Funktionalit\u00e4t im Web-Browser unterst\u00fctzt wird. < script > if ( 'serviceWorker' in navigator ) { navigator . serviceWorker . register ( 'sw.js' ); } </ script >","title":"Installable"},{"location":"mobile-web/fx-calculator/#pwa-optimized","text":"F\u00fcr diesen Aspekt m\u00fcssen einige allgemeine Einstellungen der PWA vorgenommen werden. F\u00fcr den Fx Calculator m\u00fcssen dazu noch ein Apple Touch Icon und eine Theme Color als Meta-Tag hinzugef\u00fcgt werden: < meta name = \"theme-color\" content = \"#ccffcc\" > < link rel = \"apple-touch-icon\" href = \"icon192.png\" > Um diesen Aspekt voll zu unters\u00fctzten wird HTTPs ben\u00f6tigt. Dies wird erst durch ein Deployment auf zum Beispiel Github Pages erm\u00f6glicht.","title":"PWA Optimized"},{"location":"mobile-web/fx-calculator/#service-worker-implementierung","text":"Der Service Worker wurde \u00fcber die Datei sw.js registriert. Dabei gibt es 2 wichtige Events, welche vom Service Worker bearbeitet werden k\u00f6nnen: Install-Event: Dieses Event wird getriggert, wenn der Service-Worker das erstemal installiert wird. Dort k\u00f6nnen zum Beispiel alle Dateien, welche f\u00fcr die PWA ben\u00f6tigt werden bereits geladen und in einen Cache geladen werden. Fetch-Event: Dieses Event wird immer getriggert, wenn die App einen HTTP-Request triggert. Der Service Worker fungiert dabei \u00e4hnlich wie ein Proxy und es k\u00f6nnen beliebige Strategien implementiert werden.","title":"Service Worker Implementierung"},{"location":"mobile-web/fx-calculator/#install-event","text":"Mit dem Schl\u00fcsselwort self wird der Service Worker referenziert und damit k\u00f6nnen EventListener registriert werden. Der EventListener bekommt dabei ein Event vom Typ InstallEvent , welches die Methode waitUntil aufweist. An die Methode waitUntil kann eine asynchrone Funktion \u00fcbergeben werden. Der Service Worker w\u00fcrde erst in den Status installed wechseln, wenn die \u00fcbergebenen Funktion ihre Aufgabe beendet hat. Im unten angef\u00fchrten Fall wird ein neuer Cache mit dem Namen fxcalc-v1 erzeugt und es werden \u00fcber die Methode addAll einige Ressourcen vom Netzwerk geladen und in den Cache gelegt. self . addEventListener ( 'install' , ( event ) => { event . waitUntil ( caches . open ( 'fxcalc-v1' ) . then ( cache => cache . addAll ([ 'index.html' , 'app.js' , 'icon512.png' , 'icon192.png' , 'icon16.png' , 'fixer.json' , 'manifest.webmanifest' ])) ); }); Hinweis Der Service Worker wird nicht im Main-Thread ausgef\u00fchrt und beeinflusst damit die Performance des Pageloads nicht. Am Besten sehen Sie sich dazu den Pageload im Performance-Tab der DevTools an. Wichtig ist dabei, dass Sie im Application-Tab der DevTools mit Clear Site Data alle Caches und sonstigen Daten l\u00f6schen.","title":"Install-Event"},{"location":"mobile-web/fx-calculator/#fetch-event","text":"Mit dem Fetch-Event kann die Strategie des Service Workers implementiert werden, welche verfolgt werden soll im Umgang mit Caching, Netzwerk-Optimierung und Offline-Verf\u00fcgbarkeit. Mit der Methode respondWith des Events kann dabei spezifiziert werden, welches Ergebnis vom Netzwerk an die Render Engine zur\u00fcckgegeben werden soll. Im folgenden wird folgende Strategie implementiert: Falls eine Netzwerkverbindung vorhanden ist, soll diese immer verwendet werden Eine Antwort vom Netzwerk soll immer gecacht werden, sodass sich immer der neueste Stand einer Ressource im Cache befindet Falls keine Netzwerkverbindung vorhanden ist, sollen Ressourcen aus dem Cache geladen werden self . addEventListener ( 'fetch' , ( event ) => { event . respondWith ( caches . open ( 'fxcalc-v1' ). then (( cache ) => { return fetch ( event . request ) . then (( response ) => { cache . put ( event . request , response . clone ()); return response ; }) . catch (() => cache . match ( event . request )); }) ); }); Hinweis Es k\u00f6nnen nat\u00fcrlich viele andere Service Worker Strategien implementiert werden. Die Website serviceworke.rs zeigt einige Strategien auf. Es k\u00f6nnen beliebige Strategien implementiert werden, welche nat\u00fcrlich komplett vom Use-Case abh\u00e4ngen.","title":"Fetch-Event"},{"location":"mobile-web/fx-calculator/#finale-lighthouse-prufung","text":"Nachdem alle Komponenten der App inkl. Service Worker implementiert wurden, soll nun ein Deployment auf Github Pages stattfinden. Github Pages erm\u00f6glicht HTTP/2 und HTTPs , sodass alle offenen Punkte von Lighthouse behoben werden konnten. Das Ergebnis sollte folgenderma\u00dfen aussehen (inkl. Easteregg): Eine vollst\u00e4ndige L\u00f6sung des Projekt findet sich als App auf Github Pages sowie der Quellcode innerhalb eines Git-Repositories .","title":"Finale Lighthouse Pr\u00fcfung"}]}